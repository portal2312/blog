<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.6.1 -->
<title>Details of the Object Model(객체 모델의 세부사항, 오브젝트 모델) | Portal2312&#39;s blog</title>
<meta name="generator" content="Jekyll v3.8.6" />
<meta property="og:title" content="Details of the Object Model(객체 모델의 세부사항, 오브젝트 모델)" />
<meta name="author" content="mkkim" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="자바스크립트는 클래스 기반이 아닌 prototype에 기초한 객체 기반 언어 입니다." />
<meta property="og:description" content="자바스크립트는 클래스 기반이 아닌 prototype에 기초한 객체 기반 언어 입니다." />
<link rel="canonical" href="/blog/docs/develop/A-M/Javascript/tutorials/guide/12_details_of_the_object_model.html" />
<meta property="og:url" content="/blog/docs/develop/A-M/Javascript/tutorials/guide/12_details_of_the_object_model.html" />
<meta property="og:site_name" content="Portal2312&#39;s blog" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2019-12-02T16:38:51+09:00" />
<script type="application/ld+json">
{"description":"자바스크립트는 클래스 기반이 아닌 prototype에 기초한 객체 기반 언어 입니다.","headline":"Details of the Object Model(객체 모델의 세부사항, 오브젝트 모델)","dateModified":"2019-12-02T16:38:51+09:00","datePublished":"2019-12-02T16:38:51+09:00","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"/blog/docs/develop/A-M/Javascript/tutorials/guide/12_details_of_the_object_model.html"},"url":"/blog/docs/develop/A-M/Javascript/tutorials/guide/12_details_of_the_object_model.html","author":{"@type":"Person","name":"mkkim"},"@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href='/blog/assets/main.css'><link type="application/atom+xml" rel="alternate" href="/blog/feed.xml" title="Portal2312's blog" /><script>
if(!(window.doNotTrack === "1" || navigator.doNotTrack === "1" || navigator.doNotTrack === "yes" || navigator.msDoNotTrack === "1")) {
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-113063601-1', 'auto');
  ga('send', 'pageview');
}
</script>
  
<script src='/blog/dist/js/common.bundle.js'></script>
</head>
<body><header class="site-header" role="banner">
  <div class="wrapper">
    <a class="site-title" rel="author" href="/blog/">Portal2312&#39;s blog</a>
    <nav class="site-nav">
    <input type="checkbox" id="nav-trigger" class="nav-trigger" />
    <label for="nav-trigger">
      <span class="menu-icon">
        <svg viewBox="0 0 18 15" width="18px" height="15px">
          <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
        </svg>
      </span>
    </label>

    <div class="trigger"><a class="page-link" href="/blog/about.html">
            About
          </a><a class="page-link" href="/blog/posts.html">
            Posts
          </a><a class="page-link" href="/blog/history.html">
            History
          </a><a class="page-link" href="/blog/docs/index.html">
            Docs
          </a></div>
  </nav>
  </div>
  <div class="scroll-indicator-container">
  <div class="scroll-indicator-bar" id="scrollIndicatorBar"></div>
</div>

</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <h1>Details of the Object Model(객체 모델의 세부사항, 오브젝트 모델)</h1>

  <div>
    <h2>Table of contents</h2>
    <ul class="section-nav">
<li class="toc-entry toc-h2"><a href="#class-based-vs-prototype-based-langauges">Class-based vs Prototype-based langauges</a>
<ul>
<li class="toc-entry toc-h3"><a href="#class">Class 정의</a></li>
<li class="toc-entry toc-h3"><a href="#part-9839acbb1e4b1afc">하위 클래스와 상속</a></li>
<li class="toc-entry toc-h3"><a href="#part-8272f31070b84699">속성의 추가 삭제</a></li>
<li class="toc-entry toc-h3"><a href="#part-b000f0e7cbda942a">차이점들에 대한 정리</a></li>
</ul>
</li>
<li class="toc-entry toc-h2"><a href="#part-1d99b059aa36b674">계층 구조 생성</a>
<ul>
<li class="toc-entry toc-h3"><a href="#part-551bcf64b39d327f">간단한 정의로 객체 생성</a></li>
</ul>
</li>
<li class="toc-entry toc-h2"><a href="#object-properties">Object properties(객체 속성들)</a></li>
<li class="toc-entry toc-h2"><a href="#property">Property 상속</a>
<ul>
<li class="toc-entry toc-h3"><a href="#property">Property 추가</a></li>
</ul>
</li>
<li class="toc-entry toc-h2"><a href="#part-fcedba69a4267b41">좀 더 유연한 생성자들</a></li>
<li class="toc-entry toc-h2"><a href="#part-d02444ebf5cd0c68">속성 상속의 재고</a>
<ul>
<li class="toc-entry toc-h3"><a href="#part-2737e4eda5b160bf">객체 자신의 값과 상속받은 값</a></li>
<li class="toc-entry toc-h3"><a href="#instances">Instances 관계 설정</a></li>
<li class="toc-entry toc-h3"><a href="#part-e607827fbf5de040">생성자내에서의 전역 정보</a></li>
<li class="toc-entry toc-h3"><a href="#part-a70ffb3f5d37ea0c">다중상속 금지</a></li>
</ul>
</li>
<li class="toc-entry toc-h2"><a href="#reference">Reference</a></li>
</ul><p>자바스크립트는 클래스 기반이 아닌 prototype에 기초한 객체 기반 언어 입니다.</p>

<p>이런 차이점으로 인해, 객체들의 계층 구조의 생성과 속성 및 속성 값의 상속을 어떻게 구현해야 하는지에 대한 부분이 덜 분명할 수 있습니다.</p>

<p>이번 장에서는 이런 상황을 명확하게 하고자 합니다.</p>

<p>이번 장에선 이미 자바스크립트를 어느 정도 알고 있고, 간단한 객체를 생성하는 함수들을 사용해보았다는 가정하에 진행합니다.</p>

<hr>

<h2 id="class-based-vs-prototype-based-langauges">
<a class="anchor" href="#class-based-vs-prototype-based-langauges" aria-hidden="true"><span class="octicon octicon-link"></span></a>Class-based vs Prototype-based langauges</h2>

<p>Java와 C++같은 클래스 기반의 언어들은 두개의 구별되는 개념에 기반을 두고 있습니다: 그건 바로 클래스와 인스턴스입니다.</p>

<ul>
<li>
<p>Class는 특정 객체군을 특징 짓는 모든 속성들(Java에서는 메서드들과 필드들을, C++에서는 멤버들을 속성으로 간주)을 정의합니다.</p>

<p>클래스는 해당 객체군을 표현할 수 있는 특정 멤버를 지칭하는 것이 아닌 그보다 더 추상적인 것입니다.</p>

<p>예를 들어, 직원클래스는 직원들을 대표할 수 있습니다.</p>
</li>
<li>
<p>반면 인스턴스는 클래스를 기반으로 실체화된 것입니다.</p>

<p>예를 들어, 빅토리아는 특정 직원 개인을 나타내는 직원 클래스의 인스턴스가 될 수 있습니다.</p>

<p>인스턴스는 부모 클래스의 속성과 동일한 속성들을 가집니다.</p>
</li>
</ul>

<p>자바스크립트같은 프로토타입기반의 언어들은 위와 같은 클래스와 인스턴스의 차이를 두지 않습니다. 간단하게 객체들을 가질 뿐입니다. prototype기반의 언어는 원형(프로토타입)의 객체 개념을 가지고 있습니다. 하나의 객체는 새로운 객체를 생성했을 때 초기 속성을 가질 수 있도록 하는 형판(template)으로 사용됩니다. 객체는 생성될 때 혹은 실행 시에 자기 자신의 속성을 명시할 수 있습니다. 추가적으로, 객체들은 또 다른 객체를 생성하기 위한 프로토타입으로 연관지어 질 수 있으며 프로토타입으로부터 생성된 두번째 객체가 프로토타입인 첫번째 객체의 속성을 공유(혹은 접근)하는 것을 허용합니다.</p>

<h3 id="class">
<a class="anchor" href="#class" aria-hidden="true"><span class="octicon octicon-link"></span></a>Class 정의</h3>

<p>클래스 기반의 언어들에서, 별도의 클래스를 생성하고 그 안에서 해당 클래스를 정의 할 수 있습니다.
해당 정의에서 클래스의 인스턴스를 생성할 수 있는 <strong>생성자</strong>라고하는 특별한 메서드를 명시할 수 있습니다.
생성자는 해당 인스턴스의 초기 속성 값을 지정할 수 있고, 생성 시점에, 다른 적절한 처리를 수행 할 수 있습니다.
클래스의 인스턴스를 생성하기 위해서 new 연산자와 함께 생성자를 호출해야 합니다.</p>

<p>자바스크립는 위와 비슷한 방법을 취합니다.
하지만 <strong>생성자 이외에 따로 클래스 정의를 가지고 있지는 않습니다.</strong>
대신, 특정 속성 및 속성값들을 가지고 객체를 생성하는 <strong>생성자 함수</strong>를 정의할 수 있습니다.
특정 자바스크립트 함수는 생성자로 사용될 수 있습니다.
새로운 객체를 생성할려면 new 연산자와 함께 생성자 함수를 사용해야 합니다.</p>

<h3 id="part-9839acbb1e4b1afc">
<a class="anchor" href="#part-9839acbb1e4b1afc" aria-hidden="true"><span class="octicon octicon-link"></span></a>하위 클래스와 상속</h3>

<blockquote>
<p>Note:</p>

<p>주의: 클래스 기반언어에서 상위 클래스와 하위 클래스간 상속을 구현할 경우 상위 클래스에서 private 접근 제한자로 정의된 속성은 하위 클래스로 상속되지 않습니다.</p>
</blockquote>

<h3 id="part-8272f31070b84699">
<a class="anchor" href="#part-8272f31070b84699" aria-hidden="true"><span class="octicon octicon-link"></span></a>속성의 추가 삭제</h3>

<h3 id="part-b000f0e7cbda942a">
<a class="anchor" href="#part-b000f0e7cbda942a" aria-hidden="true"><span class="octicon octicon-link"></span></a>차이점들에 대한 정리</h3>

<p>클래스 기반(자바)과 프로토타입(prototype)기반(자바스크립트) 객체 시스템의 비교:</p>

<table>
<thead>
<tr>
<th>클래스 기반(자바)</th>
<th>원형 기반(자바스크립트)</th>
</tr>
</thead>
<tbody>
<tr>
<td>클래스와 인스턴스는 별개입니다.</td>
<td>모든 객체는 다른 객체로부터 상속을 받습니다.</td>
</tr>
<tr>
<td>클래스 정의를 가지고 클래스를 생성하고 생성자 메서드로 인스턴스를 생성합니다.</td>
<td>생성자 함수를 가지고 객체군을 정의 및 생성합니다.</td>
</tr>
<tr>
<td>new 연산자로 하나의 객체(인스턴스)를 생성합니다.</td>
<td>동일</td>
</tr>
<tr>
<td>이미 존재하는 클래스에 대한 하위 클래스를 정의함으로써 객체의 계층구조를 생성합니다.</td>
<td>하나의 객체를 생성자 함수와 결합된 프로토타입에 할당함으로써 객체의 계층구조를 생성 합니다.</td>
</tr>
<tr>
<td>클래스의 상속 구조에 따라 속성을 상속 받습니다.</td>
<td>프로토타입 체인에 따라  속성을 상속 받습니다.</td>
</tr>
<tr>
<td>클래스 정의는 모든 인스턴스의 모든 속성을 명시합니다.</td>
<td>실행시에 동적으로 속성을 추가할 수 없습니다.</td>
</tr>
<tr>
<td>생성자 함수 혹은 프로토타입은 초기 속성들을 명시합니다.</td>
<td>개별 객체 혹은 전체 객체군에 동적으로 속성을 추가 삭제할 수 있습니다.</td>
</tr>
</tbody>
</table>

<hr>

<h2 id="part-1d99b059aa36b674">
<a class="anchor" href="#part-1d99b059aa36b674" aria-hidden="true"><span class="octicon octicon-link"></span></a>계층 구조 생성</h2>

<p>다음의 자바와 자바스크립트로 작성된 직원 정의는 비슷합니다. 차이점은 자바언어에서는 개별 속성에 대한 타입(type)을 일일이 지정을 해야 하지만  자바스크립트에서는 일일이 개별 속성에 대한 타입(type)을 지정할 필요가 없다는 것입니다.(이런 이유로 자바스크립트가 약하게 형식화된 언어로 불리는 반면 자바는 강력하게 형식화된 언어로 불립니다.)</p>

<p>Javascript:</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="kd">function</span> <span class="nx">Employee</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="dl">""</span><span class="p">;</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">dept</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">general</span><span class="dl">"</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<p>Java:</p>
<div class="highlight"><pre><code class="language-jar" data-lang="jar">public class Employee {
   public String name = "";
   public String dept = "general";
}
</code></pre></div>
<p>관리자와 근로자 정의는 계층 구조상에서 상위에 위치하는 객체를 어떻게 표시하는지에 대한 차이점을 보여 줍니다.</p>

<p>Javascript는 생성자 함수 정의 이후에 언제든 생성자 함수의 프로토타입(prototype) 속성의 값으로 프로토타입 인스턴스를 추가할 수 있습니다.</p>

<p>Java는 클래스 정의에 상위 클래스를 명시해야 합니다. 클래스 정의 이후에는 상위 클래스를 변경할 수 없습니다.</p>

<p>Javascript:</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="kd">function</span> <span class="nx">Manager</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">Employee</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">reports</span> <span class="o">=</span> <span class="p">[];</span>
<span class="p">}</span>
<span class="nx">Manager</span><span class="p">.</span><span class="nx">prototype</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">create</span><span class="p">(</span><span class="nx">Employee</span><span class="p">.</span><span class="nx">prototype</span><span class="p">);</span>

<span class="kd">function</span> <span class="nx">WorkerBee</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">Employee</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">projects</span> <span class="o">=</span> <span class="p">[];</span>
<span class="p">}</span>
<span class="nx">WorkerBee</span><span class="p">.</span><span class="nx">prototype</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">create</span><span class="p">(</span><span class="nx">Employee</span><span class="p">.</span><span class="nx">prototype</span><span class="p">);</span>
</code></pre></div>
<p>Java:</p>
<div class="highlight"><pre><code class="language-jar" data-lang="jar">public class Manager extends Employee {
   public Employee[] reports = new Employee[0];
}


public class WorkerBee extends Employee {
   public String[] projects = new String[0];
}
</code></pre></div>
<p>엔지니어와 영업사원 정의들은 객체들을 생성합니다.</p>

<p>생성된 객체는 근로자 객체의 하위 객체이고 따라서 직원 객체의 하위 객체가 됩니다.</p>

<p>상속 관계에 따라 엔지니어와 영업사원 객체들은 근로자와 직원객체의 속성을 가지게 됩니다.</p>

<p>게다가, 상속받은 부서 속성은 엔지니어와 영업사원에서 재정되어 새로운 값을 가지게 됩니다.</p>

<p>Javascript:</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="kd">function</span> <span class="nx">SalesPerson</span><span class="p">()</span> <span class="p">{</span>
   <span class="nx">WorkerBee</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
   <span class="k">this</span><span class="p">.</span><span class="nx">dept</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">sales</span><span class="dl">"</span><span class="p">;</span>
   <span class="k">this</span><span class="p">.</span><span class="nx">quota</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>
<span class="p">}</span>
<span class="nx">SalesPerson</span><span class="p">.</span><span class="nx">prototype</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">create</span><span class="p">(</span><span class="nx">WorkerBee</span><span class="p">.</span><span class="nx">prototype</span><span class="p">);</span>

<span class="kd">function</span> <span class="nx">Engineer</span><span class="p">()</span> <span class="p">{</span>
   <span class="nx">WorkerBee</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
   <span class="k">this</span><span class="p">.</span><span class="nx">dept</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">engineering</span><span class="dl">"</span><span class="p">;</span>
   <span class="k">this</span><span class="p">.</span><span class="nx">machine</span> <span class="o">=</span> <span class="dl">""</span><span class="p">;</span>
<span class="p">}</span>
<span class="nx">Engineer</span><span class="p">.</span><span class="nx">prototype</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">create</span><span class="p">(</span><span class="nx">WorkerBee</span><span class="p">.</span><span class="nx">prototype</span><span class="p">);</span>
</code></pre></div>
<p>Java:</p>
<div class="highlight"><pre><code class="language-jar" data-lang="jar">public class SalesPerson extends WorkerBee {
   public double quota;
   public dept = "sales";
   public quota = 100.0;
}


public class Engineer extends WorkerBee {
   public String machine;
   public dept = "engineering";
   public machine = "";
}
</code></pre></div>
<p>이런 정의 방법을 통해, 기본값을 가지는 각각의 속성을 포함하는 객체의 인스턴스를 생성할 수 있습니다.</p>

<p>다음 그림은 새로운 객체를 생성하고 새로운 객체에 대한 속성값들을 보여 표시하기 위한 자바스크립트의 정의들을 보여 줍니다.</p>

<blockquote>
<p>Note: 유의사항</p>

<p>클래스 기반 언어들에서 인스턴스라는 용어는 특정한 기술적 의미를 가지고 있습니다. 이러한 언어들에서,  하나의 인스턴스란 하나의 클래스의 개별적인  실체이며 클래스와는 근본적으로 다릅니다. 자바스크립트에서는 클래스와 인스턴스 간의 차이가 없기 때문에, "인스턴스"가 이런 기술적 의미를 갖지 않습니다. 하지만, 자바스크립트에 대해서 얘기하자면, 비공식적으로 "인스턴스"는 특정한 생성자 함수를 이용하여 생성된 오브젝트를  의미합니다. 그래서 이번 예제에서는 jane이  Engineer 의 인스턴스라고 할 수 있습니다. 이와 유사하게, 부모, 자식, 상위, 하위의 용어들은 자바스크립트에서 공식적인 의미를 갖지 않습니다; 다만 프로토타입 체인 상의 상위 또는 하위 객체를 지칭하기 위해서 비공식적으로 사용할 수 있습니다.</p>
</blockquote>

<h3 id="part-551bcf64b39d327f">
<a class="anchor" href="#part-551bcf64b39d327f" aria-hidden="true"><span class="octicon octicon-link"></span></a>간단한 정의로 객체 생성</h3>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="kd">var</span> <span class="nx">jim</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Employee</span><span class="p">;</span>
<span class="c1">// jim.name is ''</span>
<span class="c1">// jim.dept is 'general'</span>

<span class="kd">var</span> <span class="nx">sally</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Manager</span><span class="p">;</span>
<span class="c1">// sally.name is ''</span>
<span class="c1">// sally.dept is 'general'</span>
<span class="c1">// sally.reports is []</span>

<span class="kd">var</span> <span class="nx">mark</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">WorkerBee</span><span class="p">;</span>
<span class="c1">// mark.name is ''</span>
<span class="c1">// mark.dept is 'general'</span>
<span class="c1">// mark.projects is []</span>

<span class="kd">var</span> <span class="nx">fred</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">SalesPerson</span><span class="p">;</span>
<span class="c1">// fred.name is ''</span>
<span class="c1">// fred.dept is 'sales'</span>
<span class="c1">// fred.projects is []</span>
<span class="c1">// fred.quota is 100</span>

<span class="kd">var</span> <span class="nx">jane</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Engineer</span><span class="p">;</span>
<span class="c1">// jane.name is ''</span>
<span class="c1">// jane.dept is 'engineering'</span>
<span class="c1">// jane.projects is []</span>
<span class="c1">// jane.machine is ''</span>
</code></pre></div>
<hr>

<h2 id="object-properties">
<a class="anchor" href="#object-properties" aria-hidden="true"><span class="octicon octicon-link"></span></a>Object properties(객체 속성들)</h2>

<p>이번 장에서는 객체가 프로토타입체인 상의 다른 객체로부터 특성을 상속받는 방법과 런타임 상에서 프로퍼티를 추가하면 무슨 일이 일어나는 지 살펴봅니다.</p>

<h2 id="property">
<a class="anchor" href="#property" aria-hidden="true"><span class="octicon octicon-link"></span></a>Property 상속</h2>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="kd">var</span> <span class="nx">mark</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">WorkerBee</span><span class="p">;</span>
</code></pre></div>
<p><code>new</code> 연산자를 만나면, Javascript는 새로운 일반 객체를 생성하고 암묵적으로 내부의 <code>[[Prototype]](__proto__)</code> 속성의 값을 <code>WorkerBee.prototype</code> 의 값으로 할당하며, 해당 객체를 <code>this</code> 키워드의 값으로써 생성자 함수 WorkerBee에 전달합니다.</p>

<p>내부의 <code>[[Prototype]]</code> 속성은 속성값을 반환하기 위해 사용할 프로토타입 체인을 결정합니다.</p>

<p>이런 속성들이 할당되면, Javascript는 새 객체를 반환하고, 할당 구문에 의해 변수 mark를 객체에 할당합니다.</p>

<p>이러한 절차는 mark가 프로토타입 체인으로부터 상속받는 속성의 값을 mark 객체 내부에(local values) 명시적으로 부여하진 않습니다.</p>

<p>당신이 속성의 값을 요청하면,
자바스크립트는 먼저 해당 객체에 값이 존재하는지 확인합니다.
존재한다면, 해당 값이 반환됩니다.
만약 해당 객체에 값이 없다면, 프로토타입 체인을 (내장 <code>[[Prototype]]</code> 속성;<code>__proto__</code>을 이용하여)확인합니다.
체인 상의 어떤 객체가 해당 속성의 값을 가지고 있다면 그 값이 반환됩니다.
그런 속성이 발견되지 않는다면, 자바스크립트는 객체가 속성을 가지고있지 않다고 할 것입니다.
이런 식으로, mark 객체는 다음의 속성과 값을 가집니다.</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="nx">mark</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="dl">""</span><span class="p">;</span>
<span class="nx">mark</span><span class="p">.</span><span class="nx">dept</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">general</span><span class="dl">"</span><span class="p">;</span>
<span class="nx">mark</span><span class="p">.</span><span class="nx">projects</span> <span class="o">=</span> <span class="p">[];</span>
</code></pre></div>
<p>mark 객체는 <code>mark.__proto__</code>로 연결되어 있는 원형의 객체로부터 이름(name)과 부서(dept)에 대한 값을 상속 받습니다.
근로자(WorkerBee) 생성자로부터 projects속성에 대한 값을 할당을 받습니다.
이것들이 Javascript 내에서 속성과 속성 값의 상속입니다.
이런 과정의 몇몇 세부 사항들은 <a href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Guide/%EA%B0%9D%EC%B2%B4_%EB%AA%A8%EB%8D%B8%EC%9D%98_%EC%84%B8%EB%B6%80%EC%82%AC%ED%95%AD#Property_inheritance_revisited" title="Property inheritance revisited">Property inheritance revisited</a>에서 다룹니다.</p>

<p>이런 생성자들은 당신이 직접 인스턴스에만 해당 하는 값을 설정하도록 하지 않기때문에, 객체에 대한 이런 정보들은 일반적으로 적용됩니다.
근로자(WorkerBee)로부터 생성된 모든 새로운 객체들은 기본값이 적용된 속성 값들을 가지게 됩니다.
물론, 속성 값들을 변경할 수 있습니다. 아래처럼 특정 인스턴스에만 해당하는 값을 설정할 수 있습니다.</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="nx">mark</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">Doe, Mark</span><span class="dl">"</span><span class="p">;</span>
<span class="nx">mark</span><span class="p">.</span><span class="nx">dept</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">admin</span><span class="dl">"</span><span class="p">;</span>
<span class="nx">mark</span><span class="p">.</span><span class="nx">projects</span> <span class="o">=</span> <span class="p">[</span><span class="dl">"</span><span class="s2">navigator</span><span class="dl">"</span><span class="p">];</span>
</code></pre></div>
<h3 id="property">
<a class="anchor" href="#property" aria-hidden="true"><span class="octicon octicon-link"></span></a>Property 추가</h3>

<p>자바스크립트에선, 실행 시점에 특정 객체에 속성들을 추가 할 수 있습니다.
생성자 함수가 제공하는 속성외에 다른 속성을 추가할 수 있습니다.
특정 단일 객체에 속성을 추가하기 위해선, 다음과 같이 해당 객체에 값을 할당 하면 됩니다:</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="nx">mark</span><span class="p">.</span><span class="nx">bonus</span> <span class="o">=</span> <span class="mi">3000</span><span class="p">;</span>
</code></pre></div>
<p>이렇게 하면 mark객체는 보너스(bonus)속성을 가지게 됩니다. 하지만 mark객체를 제외한 나머지 근로자(WorkerBee)객체들은 보너스 속성을 가지지 않습니다.</p>

<p>만약 생성자 함수의 원형으로 사용되는 객체에 새로운 속성을 추가한다면,  해당 프로토타입 객체(prototype)의 속성을 상속받는 모든 객체에 해당 속성이 추가됩니다. 예를 들면, 전문분야(specialty)속성을 모든 직원 객체에 다음과 같은 구문으로 추가할 수 있습니다:</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="nx">Employee</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">specialty</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">none</span><span class="dl">"</span><span class="p">;</span>
</code></pre></div>
<p>위의 구문을 실행한 직후, mark객체는 "none"이라는 값을 가지는 전문분야(specialty)속성을 가지게 됩니다. 아래의 그림들은 해당 속성을 추가한 후 엔지니어(Engineer) 프로토타입에 대해 해당 속성을 재정의 했을 경우 각 객체에 미치는 영향을 보여줍니다.</p>

<p><img src="../../img/figure8.4.png" alt="Property 추가"></p>

<hr>

<h2 id="part-fcedba69a4267b41">
<a class="anchor" href="#part-fcedba69a4267b41" aria-hidden="true"><span class="octicon octicon-link"></span></a>좀 더 유연한 생성자들</h2>

<p>지금까지 살펴 본 생성자 함수들은 인스턴스를 생성하면서 동시에 속성값을 지정할 수 없었습니다.
Java의 경우, 인스턴스를 생성 시 생성자에 인자들을 넘겨주어 인스턴스의 속성들을 초기화 할 수 있습니다.
다음의 예제 그림들은 자바처럼 인스턴스 생성 시 속성값을 설정하는 방법을 보여줍니다.</p>

<p>Javascript:</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="kd">function</span> <span class="nx">Employee</span> <span class="p">(</span><span class="nx">name</span><span class="p">,</span> <span class="nx">dept</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="nx">name</span> <span class="o">||</span> <span class="dl">""</span><span class="p">;</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">dept</span> <span class="o">=</span> <span class="nx">dept</span> <span class="o">||</span> <span class="dl">"</span><span class="s2">general</span><span class="dl">"</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nx">WorkerBee</span> <span class="p">(</span><span class="nx">projs</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">projects</span> <span class="o">=</span> <span class="nx">projs</span> <span class="o">||</span> <span class="p">[];</span>
<span class="p">}</span>
<span class="nx">WorkerBee</span><span class="p">.</span><span class="nx">prototype</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Employee</span><span class="p">;</span>

<span class="kd">function</span> <span class="nx">Engineer</span> <span class="p">(</span><span class="nx">mach</span><span class="p">)</span> <span class="p">{</span>
   <span class="k">this</span><span class="p">.</span><span class="nx">dept</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">engineering</span><span class="dl">"</span><span class="p">;</span>
   <span class="k">this</span><span class="p">.</span><span class="nx">machine</span> <span class="o">=</span> <span class="nx">mach</span> <span class="o">||</span> <span class="dl">""</span><span class="p">;</span>
<span class="p">}</span>
<span class="nx">Engineer</span><span class="p">.</span><span class="nx">prototype</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">WorkerBee</span><span class="p">;</span>
</code></pre></div>
<p>Java:</p>
<div class="highlight"><pre><code class="language-jar" data-lang="jar">public class Employee {
   public String name;
   public String dept;
   public Employee () {
      this("", "general");
   }
   public Employee (String name) {
      this(name, "general");
   }
   public Employee (String name, String dept) {
      this.name = name;
      this.dept = dept;
   }
}

public class WorkerBee extends Employee {
   public String[] projects;
   public WorkerBee () {
      this(new String[0]);
   }
   public WorkerBee (String[] projs) {
      projects = projs;
   }
}

public class Engineer extends WorkerBee {
   public String machine;
   public Engineer () {
      dept = "engineering";
      machine = "";
   }
   public Engineer (String mach) {
      dept = "engineering";
      machine = mach;
   }
}
</code></pre></div>
<p>자바스크립트의 속성값을 설정하는 방법은 기본값을 설정하기 위한 관용구를 사용합니다.</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="k">this</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="nx">name</span> <span class="o">||</span> <span class="dl">""</span><span class="p">;</span>
</code></pre></div>
<p>자바스크립트의 OR 논리 연산자(||) 첫번째 인자를 평가합니다.
첫번째 인자가 참이면 첫번째 인자를 반환하고 그렇지 않은 경우는 두번째 인자를 반환합니다.
그러므로, 위의 코드는 name인자가 name 속성에 사용 가능한 값을 가지고 있는지 확인합니다.
확인 결과 name속성에 사용가능한 값을 가지고 있을 경우, 해당 값을 this.name에 설정하게 됩니다.
반대로 그렇지 않은 경우는 빈 문자열을 this.name에 설정합니다.
얼핏 보면 헷갈리지만 보다 짧은 관용구를 사용하였습니다.</p>

<blockquote>
<p>주의:
만약 인자로 false와 빈 문자열 값을 줄 경우 해당 구문은 예상한 대로 작동하지 않을 수 있습니다.</p>
</blockquote>

<p>이런 정의들을 가지고, 객체의 인스턴스를 생성할때, 객체 자신만의 속성에 대한 값을 지정할 수 있습니다. 새로운 Engineer를 생성하기 위해서 다음과 같은 구문을 사용할 수 있습니다:</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="kd">var</span> <span class="nx">jane</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Engineer</span><span class="p">(</span><span class="dl">"</span><span class="s2">belau</span><span class="dl">"</span><span class="p">);</span>
<span class="c1">// jane.name == "";</span>
<span class="c1">// jane.dept == "engineering";</span>
<span class="c1">// jane.projects == [];</span>
<span class="c1">// jane.machine == "belau"</span>
</code></pre></div>
<p>위와 같은 코드 구문으로는 name과 같이 상속받은 속성에 대한 초기값을 지정할 수 없습니다.
만약 상속 받은 속성의 초기값을 설정하고자 한다면, 생성자 함수의 코드를 변경해야 합니다.</p>

<p>지금까지, 원형 객체를 생성한 후, 그 새로운 객체 자신의 속성과 속성 값을 지정하는 것을 살펴 보았습니다.
프로토타입 체인상에서 해당 생성자가 상위 객체에 대한 생성자를 직접 호출 함으로써 더 많은 속성을 추가하도록 할 수 있습니다.
다음의 그림은 새로운 정의 방법을 보여 줍니다.</p>

<p><img src="../../img/figure8.6.png" alt="생성자내에서 속성들 정의, 그림 2"></p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="kd">function</span> <span class="nx">WorkerBee</span> <span class="p">(</span><span class="nx">name</span><span class="p">,</span> <span class="nx">dept</span><span class="p">,</span> <span class="nx">projs</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">base</span> <span class="o">=</span> <span class="nx">Employee</span><span class="p">;</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">base</span><span class="p">(</span><span class="nx">name</span><span class="p">,</span> <span class="nx">dept</span><span class="p">);</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">projects</span> <span class="o">=</span> <span class="nx">projs</span> <span class="o">||</span> <span class="p">[];</span>
<span class="p">}</span>

<span class="nx">WorkerBee</span><span class="p">.</span><span class="nx">prototype</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Employee</span><span class="p">;</span>

<span class="kd">function</span> <span class="nx">Engineer</span> <span class="p">(</span><span class="nx">name</span><span class="p">,</span> <span class="nx">projs</span><span class="p">,</span> <span class="nx">mach</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">base</span> <span class="o">=</span> <span class="nx">WorkerBee</span><span class="p">;</span>  <span class="c1">// WorkerBee 안에서 호출된 this 는 Engineer 를 나타낸다</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">base</span><span class="p">(</span><span class="nx">name</span><span class="p">,</span> <span class="dl">"</span><span class="s2">engineering</span><span class="dl">"</span><span class="p">,</span> <span class="nx">projs</span><span class="p">);</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">machine</span> <span class="o">=</span> <span class="nx">mach</span> <span class="o">||</span> <span class="dl">""</span><span class="p">;</span>
<span class="p">}</span>

<span class="nx">Engineer</span><span class="p">.</span><span class="nx">prototype</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">WorkerBee</span><span class="p">;</span>
</code></pre></div><div class="highlight"><pre><code class="language-js" data-lang="js"><span class="kd">var</span> <span class="nx">jane</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Engineer</span><span class="p">(</span><span class="dl">"</span><span class="s2">Doe, Jane</span><span class="dl">"</span><span class="p">,</span> <span class="p">[</span><span class="dl">"</span><span class="s2">navigator</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">javascript</span><span class="dl">"</span><span class="p">],</span> <span class="dl">"</span><span class="s2">belau</span><span class="dl">"</span><span class="p">);</span>
</code></pre></div>
<p>다음과 같은 순서에 따라 객체를 생성하고 속성을 정의하게 됩니다:</p>

<ol>
<li><p>new 연산자는 프로토타입 객체를 생성하고 생성된 객체의 <code>__proto__</code>속성을 <code>Engineer.prototype</code>으로 설정합니다.</p></li>
<li><p>new 연산자는 새로이 생성된 객체를 엔지니어(Engineer)생성자에 this 키워드의 값으로 전달합니다.</p></li>
<li><p>생성자는 생성한 객체에 대한 base라는 새로운 속성을 생성하고 근로자(WorkerBee) 생성자의 값을 base 속성에 할당합니다.
이런 과정은 근로자(WorkerBee) 생성자를 엔지니어(Engineer)객체의 메서드로 만듭니다.
base 속성의 이름은 그리 특별하지 않습니다.
다른 어떤 속성명을 사용해도 무방합니다.
base 속성명은 단지 해당 속성의 목적을 환기시키기 위한 것입니다.</p></li>
<li><p>생성자는 base 메서드에 필요한 인자들 <code>("Doe, Jane" and ["navigator", "javascript"])</code>을 주어 호출합니다.
명시적으로 생성자에서 사용한 "engineering"은 모든 엔지니어(Engineer)객체들이 상속받은 부서 속성에 대한 동일한 값을 가지며, 직원(Employee)으로부터 상속받은 값을 재정의 하는 것을 나타냅니다.</p></li>
<li><p>base가 엔지니어(Engineer)의 메서드이기때문에 base메서드 내에서 this 키워드를 스텝1에서 생성한 객체를 지칭하도록 해줍니다.
따라서, 근로자(WorkerBee) 함수는 차례대로 "Doe, Jane"과 "engineering" 인자를 직원(Employee)생성자에 전달합니다.
직원(Employee)생성자로부터 반환 시, 근로자(WorkerBee)함수는 남은 인자들을 프로젝트(projects)속성을 설정하기 위해 사용합니다.</p></li>
<li><p>base메서드로부터 반환 시, 엔지니어(Engineer) 생성자는 해당 객체의 장비(machine)속성을 "belau"로 초기화 합니다.</p></li>
<li><p>생성자로부터 반환 시, 새롭게 생성된 객체를 jane변수에 할당 합니다.</p></li>
</ol>

<p>엔지니어(Engineer) 생성자내에서 근로자(WorkerBee) 생성자를 호출하면, 엔지니어(Engineer)에 대한 상속을 적절하게 설정할 수 도 있을 것이라고 생각할 수 있을 것입니다.
하지만 그렇지 않습니다.
근로자(WorkerBee)생성자를 호출하는 것은 엔지니어(Engineer)객체로 하여금 호출되는 모든 생성자 함수내에서 열거된 속성들을 가지고도록 보장합니다.
그러나, 나중에 직원(Employee)혹은 근로자(WorkerBee) 원형에 속성을 추가한다면, 엔지니어(Engineer)객체에 의해 추가된 속성들은 상속이 되지 않습니다.
예를 들어, 아래와 같은 구문을 작성하였다고 가정합니다:</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="kd">function</span> <span class="nx">Engineer</span> <span class="p">(</span><span class="nx">name</span><span class="p">,</span> <span class="nx">projs</span><span class="p">,</span> <span class="nx">mach</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">base</span> <span class="o">=</span> <span class="nx">WorkerBee</span><span class="p">;</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">base</span><span class="p">(</span><span class="nx">name</span><span class="p">,</span> <span class="dl">"</span><span class="s2">engineering</span><span class="dl">"</span><span class="p">,</span> <span class="nx">projs</span><span class="p">);</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">machine</span> <span class="o">=</span> <span class="nx">mach</span> <span class="o">||</span> <span class="dl">""</span><span class="p">;</span>
<span class="p">}</span>
<span class="kd">var</span> <span class="nx">jane</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Engineer</span><span class="p">(</span><span class="dl">"</span><span class="s2">Doe, Jane</span><span class="dl">"</span><span class="p">,</span> <span class="p">[</span><span class="dl">"</span><span class="s2">navigator</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">javascript</span><span class="dl">"</span><span class="p">],</span> <span class="dl">"</span><span class="s2">belau</span><span class="dl">"</span><span class="p">);</span>
<span class="nx">Employee</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">specialty</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">none</span><span class="dl">"</span><span class="p">;</span>
</code></pre></div>
<p>위는 jane객체는 전문분야(specialty)속성을 상속받지 않습니다.</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="kd">function</span> <span class="nx">Engineer</span> <span class="p">(</span><span class="nx">name</span><span class="p">,</span> <span class="nx">projs</span><span class="p">,</span> <span class="nx">mach</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">base</span> <span class="o">=</span> <span class="nx">WorkerBee</span><span class="p">;</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">base</span><span class="p">(</span><span class="nx">name</span><span class="p">,</span> <span class="dl">"</span><span class="s2">engineering</span><span class="dl">"</span><span class="p">,</span> <span class="nx">projs</span><span class="p">);</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">machine</span> <span class="o">=</span> <span class="nx">mach</span> <span class="o">||</span> <span class="dl">""</span><span class="p">;</span>
<span class="p">}</span>
<span class="nx">Engineer</span><span class="p">.</span><span class="nx">prototype</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">WorkerBee</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">jane</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Engineer</span><span class="p">(</span><span class="dl">"</span><span class="s2">Doe, Jane</span><span class="dl">"</span><span class="p">,</span> <span class="p">[</span><span class="dl">"</span><span class="s2">navigator</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">javascript</span><span class="dl">"</span><span class="p">],</span> <span class="dl">"</span><span class="s2">belau</span><span class="dl">"</span><span class="p">);</span>
<span class="nx">Employee</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">specialty</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">none</span><span class="dl">"</span><span class="p">;</span>
</code></pre></div>
<p>이제 jane객체의 전문분야(specialty)속성은 "none"이 되었습니다.</p>

<p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/call">call()</a> 혹은 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/apply">apply()</a> 메서드를 사용는 것은 상속을 구현하는 또 다른 방법입니다.
다음의 두 예제는 동일한 결과를 보여줍니다.</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="kd">function</span> <span class="nx">Engineer</span> <span class="p">(</span><span class="nx">name</span><span class="p">,</span> <span class="nx">projs</span><span class="p">,</span> <span class="nx">mach</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">base</span> <span class="o">=</span> <span class="nx">WorkerBee</span><span class="p">;</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">base</span><span class="p">(</span><span class="nx">name</span><span class="p">,</span> <span class="dl">"</span><span class="s2">engineering</span><span class="dl">"</span><span class="p">,</span> <span class="nx">projs</span><span class="p">);</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">machine</span> <span class="o">=</span> <span class="nx">mach</span> <span class="o">||</span> <span class="dl">""</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><div class="highlight"><pre><code class="language-js" data-lang="js"><span class="kd">function</span> <span class="nx">Engineer</span> <span class="p">(</span><span class="nx">name</span><span class="p">,</span> <span class="nx">projs</span><span class="p">,</span> <span class="nx">mach</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">WorkerBee</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="nx">name</span><span class="p">,</span> <span class="dl">"</span><span class="s2">engineering</span><span class="dl">"</span><span class="p">,</span> <span class="nx">projs</span><span class="p">);</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">machine</span> <span class="o">=</span> <span class="nx">mach</span> <span class="o">||</span> <span class="dl">""</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<p><code>this.base</code>를 사용하지 않고 구현을 하기 때문에, <code>call()</code> 메서드를 사용하여 상속을 구현하는 것이 보다 깔끔합니다.</p>

<hr>

<h2 id="part-d02444ebf5cd0c68">
<a class="anchor" href="#part-d02444ebf5cd0c68" aria-hidden="true"><span class="octicon octicon-link"></span></a>속성 상속의 재고</h2>

<p>이전 절에서 자바스크립트의 생성자와 원형(prototype)이 어떤 방식으로 상속과 객체의 계층 구조를 제공하는지를 살펴 보았습니다. 이번장에서는 이전 절에서 반드시 명백하게 짚고 넘어가지 않은 일부 미묘한 점들에 대해 살펴보겠습니다.</p>

<h3 id="part-2737e4eda5b160bf">
<a class="anchor" href="#part-2737e4eda5b160bf" aria-hidden="true"><span class="octicon octicon-link"></span></a>객체 자신의 값과 상속받은 값</h3>

<p>이번 장에서 이미 설명된 것 처럼, 객체의 속성에 접근할 때, Javascript는 아래와 같은 절차를 따릅니다.</p>

<ol>
<li> 해당 속성에 대한 객체 자신의 값이 있는지 확인하고 있으면 그 값을 반환한다.</li>
<li> 객체 자신의 값이 없으면 <code>__proto__</code> 속성을 사용하여 prototype 체인을 확인한다.</li>
<li> 프로토타입 체인상의 특정 객체가 해당 속성에 대한 값을 가지고 있다면 해당 객체의 값을 반환한다.</li>
<li> 해당 속성을 가진 어떤 객체도 발견하지 못하면 해당 객체는 그 속성을 가지고 있지 않은 것으로 판단한다.</li>
</ol>

<p>이런 단계들의 결과는 생성자 및 prototype 체인등의 것들을 어떻게 정의 하느냐에 따라 달라집니다.</p>

<p>아래와 같은 원래의 예제는 이런 정의들을 가지고 있습니다.</p>

<p>이런 정의들을 가지고, amy라는 근로자(WorkerBee)인스턴스를 아래와 같이 생성하였다고 가정합니다:</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="kd">function</span> <span class="nx">Employee</span> <span class="p">()</span> <span class="p">{</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="dl">""</span><span class="p">;</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">dept</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">general</span><span class="dl">"</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nx">WorkerBee</span> <span class="p">()</span> <span class="p">{</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">projects</span> <span class="o">=</span> <span class="p">[];</span>
<span class="p">}</span>
<span class="nx">WorkerBee</span><span class="p">.</span><span class="nx">prototype</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Employee</span><span class="p">;</span>

<span class="kd">var</span> <span class="nx">amy</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">WorkerBee</span><span class="p">;</span>

<span class="nx">Employee</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">Unknown</span><span class="dl">"</span>

<span class="c1">// 따라서 amy는 이런 속성들의 값을 가지게 됩니다.</span>
<span class="nx">amy</span><span class="p">.</span><span class="nx">name</span>  <span class="c1">// ""</span>
<span class="nx">amy</span><span class="p">.</span><span class="nx">dept</span>  <span class="c1">// "general"</span>
<span class="nx">amy</span><span class="p">.</span><span class="nx">projects</span>  <span class="c1">// []</span>
</code></pre></div>
<p>amy 객체는 프로젝트라는 자신만의 속성을 가집니다.
이름과 부서 속성들은 amy 자신의 속성이 아닌 amy객체의 <code>__proto__</code> 속성을 통해 가지고 온 속성들입니다.</p>

<p>얼핏보기에, 새로운 값이 모든 직원 인스턴스에 적용이 될것으로 예상하겠지만 그렇지 않습니다.</p>

<p><strong>직원 객체의 인스턴스를 생성할때, 해당 인스턴스는 이름 속성에 대해 자신이 가지고 있는 값(빈 문자열)을 취하게 됩니다.
이것이 의미하는 것은 새로운 직원 객체를 생성하여 근로자(WorkerBee)의 프로토타입에 설정을 할때, WorkerBee.prototype이 이름 속성에 대한 자신만의 값을 가지고 있다는 것입니다.
그러므로, amy객체(근로자 인스턴스)의 이름 속성에 대해 검색할때, WorkerBee.prototype내에서 이름 속성에 대한 amy 객체 자신의 값을 찾게 됩니다.
그렇기 때문에 Employee.prototype까지의 프로토타입 체인을 검색하지 않게 됩니다.</strong></p>

<p>실행시에 객체의 속성 값을 변경하고 새로운 값이 모든 하위 객체들에게도 적용되도록 할려면, 객체의 생성자함수에서는 속성을 정의할 수 없습니다.
대신에, 생성자와 연결된 프로토타입에 추가할 수 있습니다. 예를 들어, 이전의 코드를 아래와 같이 변경하였다고 가정합니다:</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="kd">function</span> <span class="nx">Employee</span> <span class="p">()</span> <span class="p">{</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">dept</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">general</span><span class="dl">"</span><span class="p">;</span>
<span class="p">}</span>
<span class="nx">Employee</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="dl">""</span><span class="p">;</span>

<span class="kd">function</span> <span class="nx">WorkerBee</span> <span class="p">()</span> <span class="p">{</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">projects</span> <span class="o">=</span> <span class="p">[];</span>
<span class="p">}</span>
<span class="nx">WorkerBee</span><span class="p">.</span><span class="nx">prototype</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Employee</span><span class="p">;</span>

<span class="kd">var</span> <span class="nx">amy</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">WorkerBee</span><span class="p">;</span>

<span class="nx">Employee</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">Unknown</span><span class="dl">"</span><span class="p">;</span>

<span class="nx">amy</span><span class="p">.</span><span class="nx">name</span>  <span class="c1">// "Unknown"</span>
</code></pre></div>
<p>위의 예제에서처럼, 객체 생성 시에 객체의 속성에 대한 기본 값을 설정하고 실행 시에 해당 속성의 값을 변경하기를 원한다면, 해당 속성들을 생성자 함수 자체안에가 아닌 생성자의 프로토타입에 설정 하여야 합니다.</p>

<h3 id="instances">
<a class="anchor" href="#instances" aria-hidden="true"><span class="octicon octicon-link"></span></a>Instances 관계 설정</h3>

<p>Javascript에서의 속성 검색은 <strong>객체 자신의 속성들을 먼저 살펴보고 해당 속성명을 찾지 못할 경우, 객체의 특별한 속성인 <code>__proto__</code> 내에서 찾게 됩니다.
이런 검색은 재귀적으로 진행되며, 이런 과정을 "프로토타입 체인에서의 검색"이라고 합니다.</strong></p>

<p>특별한 속성인 <code>__proto__</code> 객체가 생성이 될때 설정이 됩니다.
<code>__proto__</code> 속성은 생성자의 프로토타입 속성의 값으로 설정이 됩니다.
따라서 <code>new Foo()</code> 표현식은 <code>__proto__</code> == Foo.prototype인 객체를 생성합니다.
결과적으로 <code>Foo.prototype</code>의 속성들에 대한 변경은 <code>new Foo()</code> 표현식으로 생성한 모든 객체에 대한 속성 검색을 변경하게 됩니다.</p>

<p>모든 객체는 <code>__proto__</code> 라는 객체 속성을 가집니다.(예외: Object).
모든 함수들은 prototype 이라는 객체 속성을 가집니다.
따라서 객체들은 '프로토타입 상속'에 의해 다른 객체들과의 관계를 가지게 됩니다.
객체의 <code>__proto__</code> 속성과 함수의 prototype 객체를 비교하여 상속을 테스트 해볼 수 있습니다.
Javascript는 특정 객체가 함수 prototype으로부터 상속 받는 객체일 경우 참(true)를 반환하는  instanceof라는 연산자를 제공합니다. 예를 들면,</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="kd">var</span> <span class="nx">f</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Foo</span><span class="p">();</span>
<span class="kd">var</span> <span class="nx">isTrue</span> <span class="o">=</span> <span class="p">(</span><span class="nx">f</span> <span class="k">instanceof</span> <span class="nx">Foo</span><span class="p">);</span>
</code></pre></div>
<p>Inheriting properties에 나오는 예제와 동일한 정의들을 작성해 놓았을 경우, 보다 상세한 예제는 아래와 같습니다.엔지니어(Engineer)객체를 아래와 같이 생성합니다:</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="kd">var</span> <span class="nx">chris</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Engineer</span><span class="p">(</span><span class="dl">"</span><span class="s2">Pigman, Chris</span><span class="dl">"</span><span class="p">,</span> <span class="p">[</span><span class="dl">"</span><span class="s2">jsd</span><span class="dl">"</span><span class="p">],</span> <span class="dl">"</span><span class="s2">fiji</span><span class="dl">"</span><span class="p">);</span>
</code></pre></div>
<p>생성된 객체를 가지고 아래와 같은 구문을 실행할 경우 각 구문에 대한 결과는 모두 참(true)입니다.</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="nx">chris</span><span class="p">.</span><span class="nx">__proto__</span> <span class="o">==</span> <span class="nx">Engineer</span><span class="p">.</span><span class="nx">prototype</span><span class="p">;</span>
<span class="nx">chris</span><span class="p">.</span><span class="nx">__proto__</span><span class="p">.</span><span class="nx">__proto__</span> <span class="o">==</span> <span class="nx">WorkerBee</span><span class="p">.</span><span class="nx">prototype</span><span class="p">;</span>
<span class="nx">chris</span><span class="p">.</span><span class="nx">__proto__</span><span class="p">.</span><span class="nx">__proto__</span><span class="p">.</span><span class="nx">__proto__</span> <span class="o">==</span> <span class="nx">Employee</span><span class="p">.</span><span class="nx">prototype</span><span class="p">;</span>
<span class="nx">chris</span><span class="p">.</span><span class="nx">__proto__</span><span class="p">.</span><span class="nx">__proto__</span><span class="p">.</span><span class="nx">__proto__</span><span class="p">.</span><span class="nx">__proto__</span> <span class="o">==</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">prototype</span><span class="p">;</span>
<span class="nx">chris</span><span class="p">.</span><span class="nx">__proto__</span><span class="p">.</span><span class="nx">__proto__</span><span class="p">.</span><span class="nx">__proto__</span><span class="p">.</span><span class="nx">__proto__</span><span class="p">.</span><span class="nx">__proto__</span> <span class="o">==</span> <span class="kc">null</span><span class="p">;</span>
</code></pre></div>
<h3 id="part-e607827fbf5de040">
<a class="anchor" href="#part-e607827fbf5de040" aria-hidden="true"><span class="octicon octicon-link"></span></a>생성자내에서의 전역 정보</h3>

<p>생성자를 생성할때, 생성자내에서 전역 정보를 설정할 경우, 주의를 해야 합니다. 예를 들어, 각각의 새로운 직원에게 자동으로 고유한 ID값을 할당하기를 원한다고 했을 때, 다음과 같은 직원(Employee) 정의를 사용할 수 있을 것입니다:</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="kd">var</span> <span class="nx">idCounter</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

<span class="kd">function</span> <span class="nx">Employee</span> <span class="p">(</span><span class="nx">name</span><span class="p">,</span> <span class="nx">dept</span><span class="p">)</span> <span class="p">{</span>
   <span class="k">this</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="nx">name</span> <span class="o">||</span> <span class="dl">""</span><span class="p">;</span>
   <span class="k">this</span><span class="p">.</span><span class="nx">dept</span> <span class="o">=</span> <span class="nx">dept</span> <span class="o">||</span> <span class="dl">"</span><span class="s2">general</span><span class="dl">"</span><span class="p">;</span>
   <span class="k">this</span><span class="p">.</span><span class="nx">id</span> <span class="o">=</span> <span class="nx">idCounter</span><span class="o">++</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<p>이런 정의 내용을 가지고, 새로운 직원을 생성했을 때, 생성자는 다음의 고유한 ID값을 새로운 직원객체에 할당하고 전역 ID 카운터를 증가 시킵니다. 따라서 다음과 같은 구문으로 각각의 객체를 생성한다면, 결과는 victoria.id는 1 그리고 harry.id는 2가 됩니다:</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="kd">var</span> <span class="nx">victoria</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Employee</span><span class="p">(</span><span class="dl">"</span><span class="s2">Pigbert, Victoria</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">pubs</span><span class="dl">"</span><span class="p">);</span>
<span class="kd">var</span> <span class="nx">harry</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Employee</span><span class="p">(</span><span class="dl">"</span><span class="s2">Tschopik, Harry</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">sales</span><span class="dl">"</span><span class="p">);</span>
</code></pre></div>
<p>얼핏보면 괜찮아 보입니다. 하지만 이유를 불문하고 직원 객체가 생성될때마다 idCounter는 증가분을 가지게 됩니다.이번장에서 나온 예제에서처럼 전체 직원 객체의 계층 구조를 생성하였다면, 프로토타입을 설정할때마다 직원 생성자는 매번 호출 됩니다.다음과 같은 코드를 작성하였다고 가정합니다:</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="kd">var</span> <span class="nx">idCounter</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

<span class="kd">function</span> <span class="nx">Employee</span> <span class="p">(</span><span class="nx">name</span><span class="p">,</span> <span class="nx">dept</span><span class="p">)</span> <span class="p">{</span>
   <span class="k">this</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="nx">name</span> <span class="o">||</span> <span class="dl">""</span><span class="p">;</span>
   <span class="k">this</span><span class="p">.</span><span class="nx">dept</span> <span class="o">=</span> <span class="nx">dept</span> <span class="o">||</span> <span class="dl">"</span><span class="s2">general</span><span class="dl">"</span><span class="p">;</span>
   <span class="k">this</span><span class="p">.</span><span class="nx">id</span> <span class="o">=</span> <span class="nx">idCounter</span><span class="o">++</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nx">Manager</span> <span class="p">(</span><span class="nx">name</span><span class="p">,</span> <span class="nx">dept</span><span class="p">,</span> <span class="nx">reports</span><span class="p">)</span> <span class="p">{...}</span>
<span class="nx">Manager</span><span class="p">.</span><span class="nx">prototype</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Employee</span><span class="p">;</span>

<span class="kd">function</span> <span class="nx">WorkerBee</span> <span class="p">(</span><span class="nx">name</span><span class="p">,</span> <span class="nx">dept</span><span class="p">,</span> <span class="nx">projs</span><span class="p">)</span> <span class="p">{...}</span>
<span class="nx">WorkerBee</span><span class="p">.</span><span class="nx">prototype</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Employee</span><span class="p">;</span>

<span class="kd">function</span> <span class="nx">Engineer</span> <span class="p">(</span><span class="nx">name</span><span class="p">,</span> <span class="nx">projs</span><span class="p">,</span> <span class="nx">mach</span><span class="p">)</span> <span class="p">{...}</span>
<span class="nx">Engineer</span><span class="p">.</span><span class="nx">prototype</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">WorkerBee</span><span class="p">;</span>

<span class="kd">function</span> <span class="nx">SalesPerson</span> <span class="p">(</span><span class="nx">name</span><span class="p">,</span> <span class="nx">projs</span><span class="p">,</span> <span class="nx">quota</span><span class="p">)</span> <span class="p">{...}</span>
<span class="nx">SalesPerson</span><span class="p">.</span><span class="nx">prototype</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">WorkerBee</span><span class="p">;</span>

<span class="kd">var</span> <span class="nx">mac</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Engineer</span><span class="p">(</span><span class="dl">"</span><span class="s2">Wood, Mac</span><span class="dl">"</span><span class="p">);</span>
</code></pre></div>
<p>여기서 생략된 정의가 base속성을 가지고 해당 생성자를 프로토타입 체인내의 상위 생성자들을 호출한닥고 좀 더 가정하면, 이런 경우, 생성된 mac객체의 id값은 5가 됩니다.</p>

<p>어플리케이셔네 따라, 카운터가 이렇게 추가적으로 증가된 것은 문제가 될 수도 그렇지 않을 수 도 있습니다. 카운터에 정확한 값이 설정되기를 원한다면, 사용가능한 해결적은 아래와 같은 생성자를 대신 사용하는 것입니다:</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="kd">function</span> <span class="nx">Employee</span> <span class="p">(</span><span class="nx">name</span><span class="p">,</span> <span class="nx">dept</span><span class="p">)</span> <span class="p">{</span>
   <span class="k">this</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="nx">name</span> <span class="o">||</span> <span class="dl">""</span><span class="p">;</span>
   <span class="k">this</span><span class="p">.</span><span class="nx">dept</span> <span class="o">=</span> <span class="nx">dept</span> <span class="o">||</span> <span class="dl">"</span><span class="s2">general</span><span class="dl">"</span><span class="p">;</span>
   <span class="k">if</span> <span class="p">(</span><span class="nx">name</span><span class="p">)</span>
      <span class="k">this</span><span class="p">.</span><span class="nx">id</span> <span class="o">=</span> <span class="nx">idCounter</span><span class="o">++</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<p>prototype으로 사용할 직원 인스턴스를 생성할 때, 생성자에 인자들을 주어선 안됩니다. 이 생성자 정의를 사용하여, 인자들을 주지 않을 경우, 생성자는 id에 값을 할당하지 않으며 카운터를 갱신하지 않습니다. 따라서, id값을 가지는 직원 객체에 대해, 반드시 해당 직원의 이름을 명시해야 합니다. 이 예제의 경우 mac인스턴스의 id값은 1이 됩니다.</p>

<h3 id="part-a70ffb3f5d37ea0c">
<a class="anchor" href="#part-a70ffb3f5d37ea0c" aria-hidden="true"><span class="octicon octicon-link"></span></a>다중상속 금지</h3>

<p>몇몇 객체 지향언어들은 다중 상속을 허용합니다. 그것은, 관련이 없는 부모 객체들로 부터 속성들과 값들을 상속 받을 수 있는 것을 말합니다. 자바스크립트는 다중 상속을 지원하지 않습니다.</p>

<p>속성 값의 상속은 속성에 대한 값을 찾기 위한 프로토타입 체인을 검색에 의해 실행 시점에 이루어 집니다. 하나의 객체는 오로지 하나의 결합된 prototype만을 가지기 때문에, 자바스크립트는 동적으로 하나 이상의 프로토타입 체인으로 부터 상속을 할 수 없습니다.</p>

<p>자바스크립트에서, 하나 이상의 다른 생성자 함수를 호출하는 생성자를 사용할 수 있습니다. 이것은 다중 상속처럼 보여질 수 있습니다. 예를 들어, 다음과 같은 구문들을 살펴보세요:</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="kd">function</span> <span class="nx">Hobbyist</span> <span class="p">(</span><span class="nx">hobby</span><span class="p">)</span> <span class="p">{</span>
   <span class="k">this</span><span class="p">.</span><span class="nx">hobby</span> <span class="o">=</span> <span class="nx">hobby</span> <span class="o">||</span> <span class="dl">"</span><span class="s2">scuba</span><span class="dl">"</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nx">Engineer</span> <span class="p">(</span><span class="nx">name</span><span class="p">,</span> <span class="nx">projs</span><span class="p">,</span> <span class="nx">mach</span><span class="p">,</span> <span class="nx">hobby</span><span class="p">)</span> <span class="p">{</span>
   <span class="k">this</span><span class="p">.</span><span class="nx">base1</span> <span class="o">=</span> <span class="nx">WorkerBee</span><span class="p">;</span>
   <span class="k">this</span><span class="p">.</span><span class="nx">base1</span><span class="p">(</span><span class="nx">name</span><span class="p">,</span> <span class="dl">"</span><span class="s2">engineering</span><span class="dl">"</span><span class="p">,</span> <span class="nx">projs</span><span class="p">);</span>
   <span class="k">this</span><span class="p">.</span><span class="nx">base2</span> <span class="o">=</span> <span class="nx">Hobbyist</span><span class="p">;</span>
   <span class="k">this</span><span class="p">.</span><span class="nx">base2</span><span class="p">(</span><span class="nx">hobby</span><span class="p">);</span>
   <span class="k">this</span><span class="p">.</span><span class="nx">machine</span> <span class="o">=</span> <span class="nx">mach</span> <span class="o">||</span> <span class="dl">""</span><span class="p">;</span>
<span class="p">}</span>
<span class="nx">Engineer</span><span class="p">.</span><span class="nx">prototype</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">WorkerBee</span><span class="p">;</span>

<span class="kd">var</span> <span class="nx">dennis</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Engineer</span><span class="p">(</span><span class="dl">"</span><span class="s2">Doe, Dennis</span><span class="dl">"</span><span class="p">,</span> <span class="p">[</span><span class="dl">"</span><span class="s2">collabra</span><span class="dl">"</span><span class="p">],</span> <span class="dl">"</span><span class="s2">hugo</span><span class="dl">"</span><span class="p">);</span>

<span class="nx">dennis</span><span class="p">.</span><span class="nx">name</span> <span class="o">==</span> <span class="dl">"</span><span class="s2">Doe, Dennis</span><span class="dl">"</span>
<span class="nx">dennis</span><span class="p">.</span><span class="nx">dept</span> <span class="o">==</span> <span class="dl">"</span><span class="s2">engineering</span><span class="dl">"</span>
<span class="nx">dennis</span><span class="p">.</span><span class="nx">projects</span> <span class="o">==</span> <span class="p">[</span><span class="dl">"</span><span class="s2">collabra</span><span class="dl">"</span><span class="p">]</span>
<span class="nx">dennis</span><span class="p">.</span><span class="nx">machine</span> <span class="o">==</span> <span class="dl">"</span><span class="s2">hugo</span><span class="dl">"</span>
<span class="nx">dennis</span><span class="p">.</span><span class="nx">hobby</span> <span class="o">==</span> <span class="dl">"</span><span class="s2">scuba</span><span class="dl">"</span>
</code></pre></div>
<p>따라서 dennis객체는 Hobbyist 생성자로부터 취미(hobby)속성을 받아 오지 않습니다. 그런데,Hobbyist생성자의 프로토타입에 속성을 추가 했다고 가정하면</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="nx">Hobbyist</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">equipment</span> <span class="o">=</span> <span class="p">[</span><span class="dl">"</span><span class="s2">mask</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">fins</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">regulator</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">bcd</span><span class="dl">"</span><span class="p">]</span>
</code></pre></div>
<p>객체는 새로이 추가된 속성을 상속받지 않습니다.</p>

<hr>

<h2 id="reference">
<a class="anchor" href="#reference" aria-hidden="true"><span class="octicon octicon-link"></span></a>Reference</h2>

<p><a href="https://developer.mozilla.org/en-us/docs/web/javascript/guide/details_of_the_object_model">details of the object model(객체 모델의 세부사항)</a></p>

  </div>

<div>
  <p>자바스크립트는 클래스 기반이 아닌 prototype에 기초한 객체 기반 언어 입니다.</p>

<p>이런 차이점으로 인해, 객체들의 계층 구조의 생성과 속성 및 속성 값의 상속을 어떻게 구현해야 하는지에 대한 부분이 덜 분명할 수 있습니다.</p>

<p>이번 장에서는 이런 상황을 명확하게 하고자 합니다.</p>

<p>이번 장에선 이미 자바스크립트를 어느 정도 알고 있고, 간단한 객체를 생성하는 함수들을 사용해보았다는 가정하에 진행합니다.</p>

<hr>

<h2 id="class-based-vs-prototype-based-langauges">Class-based vs Prototype-based langauges</h2>

<p>Java와 C++같은 클래스 기반의 언어들은 두개의 구별되는 개념에 기반을 두고 있습니다: 그건 바로 클래스와 인스턴스입니다.</p>

<ul>
<li>
<p>Class는 특정 객체군을 특징 짓는 모든 속성들(Java에서는 메서드들과 필드들을, C++에서는 멤버들을 속성으로 간주)을 정의합니다.</p>

<p>클래스는 해당 객체군을 표현할 수 있는 특정 멤버를 지칭하는 것이 아닌 그보다 더 추상적인 것입니다.</p>

<p>예를 들어, 직원클래스는 직원들을 대표할 수 있습니다.</p>
</li>
<li>
<p>반면 인스턴스는 클래스를 기반으로 실체화된 것입니다.</p>

<p>예를 들어, 빅토리아는 특정 직원 개인을 나타내는 직원 클래스의 인스턴스가 될 수 있습니다.</p>

<p>인스턴스는 부모 클래스의 속성과 동일한 속성들을 가집니다.</p>
</li>
</ul>

<p>자바스크립트같은 프로토타입기반의 언어들은 위와 같은 클래스와 인스턴스의 차이를 두지 않습니다. 간단하게 객체들을 가질 뿐입니다. prototype기반의 언어는 원형(프로토타입)의 객체 개념을 가지고 있습니다. 하나의 객체는 새로운 객체를 생성했을 때 초기 속성을 가질 수 있도록 하는 형판(template)으로 사용됩니다. 객체는 생성될 때 혹은 실행 시에 자기 자신의 속성을 명시할 수 있습니다. 추가적으로, 객체들은 또 다른 객체를 생성하기 위한 프로토타입으로 연관지어 질 수 있으며 프로토타입으로부터 생성된 두번째 객체가 프로토타입인 첫번째 객체의 속성을 공유(혹은 접근)하는 것을 허용합니다.</p>

<h3 id="class">Class 정의</h3>

<p>클래스 기반의 언어들에서, 별도의 클래스를 생성하고 그 안에서 해당 클래스를 정의 할 수 있습니다.
해당 정의에서 클래스의 인스턴스를 생성할 수 있는 <strong>생성자</strong>라고하는 특별한 메서드를 명시할 수 있습니다.
생성자는 해당 인스턴스의 초기 속성 값을 지정할 수 있고, 생성 시점에, 다른 적절한 처리를 수행 할 수 있습니다.
클래스의 인스턴스를 생성하기 위해서 new 연산자와 함께 생성자를 호출해야 합니다.</p>

<p>자바스크립는 위와 비슷한 방법을 취합니다.
하지만 <strong>생성자 이외에 따로 클래스 정의를 가지고 있지는 않습니다.</strong>
대신, 특정 속성 및 속성값들을 가지고 객체를 생성하는 <strong>생성자 함수</strong>를 정의할 수 있습니다.
특정 자바스크립트 함수는 생성자로 사용될 수 있습니다.
새로운 객체를 생성할려면 new 연산자와 함께 생성자 함수를 사용해야 합니다.</p>

<h3 id="part-9839acbb1e4b1afc">하위 클래스와 상속</h3>

<blockquote>
<p>Note:</p>

<p>주의: 클래스 기반언어에서 상위 클래스와 하위 클래스간 상속을 구현할 경우 상위 클래스에서 private 접근 제한자로 정의된 속성은 하위 클래스로 상속되지 않습니다.</p>
</blockquote>

<h3 id="part-8272f31070b84699">속성의 추가 삭제</h3>

<h3 id="part-b000f0e7cbda942a">차이점들에 대한 정리</h3>

<p>클래스 기반(자바)과 프로토타입(prototype)기반(자바스크립트) 객체 시스템의 비교:</p>

<table>
<thead>
<tr>
<th>클래스 기반(자바)</th>
<th>원형 기반(자바스크립트)</th>
</tr>
</thead>
<tbody>
<tr>
<td>클래스와 인스턴스는 별개입니다.</td>
<td>모든 객체는 다른 객체로부터 상속을 받습니다.</td>
</tr>
<tr>
<td>클래스 정의를 가지고 클래스를 생성하고 생성자 메서드로 인스턴스를 생성합니다.</td>
<td>생성자 함수를 가지고 객체군을 정의 및 생성합니다.</td>
</tr>
<tr>
<td>new 연산자로 하나의 객체(인스턴스)를 생성합니다.</td>
<td>동일</td>
</tr>
<tr>
<td>이미 존재하는 클래스에 대한 하위 클래스를 정의함으로써 객체의 계층구조를 생성합니다.</td>
<td>하나의 객체를 생성자 함수와 결합된 프로토타입에 할당함으로써 객체의 계층구조를 생성 합니다.</td>
</tr>
<tr>
<td>클래스의 상속 구조에 따라 속성을 상속 받습니다.</td>
<td>프로토타입 체인에 따라  속성을 상속 받습니다.</td>
</tr>
<tr>
<td>클래스 정의는 모든 인스턴스의 모든 속성을 명시합니다.</td>
<td>실행시에 동적으로 속성을 추가할 수 없습니다.</td>
</tr>
<tr>
<td>생성자 함수 혹은 프로토타입은 초기 속성들을 명시합니다.</td>
<td>개별 객체 혹은 전체 객체군에 동적으로 속성을 추가 삭제할 수 있습니다.</td>
</tr>
</tbody>
</table>

<hr>

<h2 id="part-1d99b059aa36b674">계층 구조 생성</h2>

<p>다음의 자바와 자바스크립트로 작성된 직원 정의는 비슷합니다. 차이점은 자바언어에서는 개별 속성에 대한 타입(type)을 일일이 지정을 해야 하지만  자바스크립트에서는 일일이 개별 속성에 대한 타입(type)을 지정할 필요가 없다는 것입니다.(이런 이유로 자바스크립트가 약하게 형식화된 언어로 불리는 반면 자바는 강력하게 형식화된 언어로 불립니다.)</p>

<p>Javascript:</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="kd">function</span> <span class="nx">Employee</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="dl">""</span><span class="p">;</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">dept</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">general</span><span class="dl">"</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<p>Java:</p>
<div class="highlight"><pre><code class="language-jar" data-lang="jar">public class Employee {
   public String name = "";
   public String dept = "general";
}
</code></pre></div>
<p>관리자와 근로자 정의는 계층 구조상에서 상위에 위치하는 객체를 어떻게 표시하는지에 대한 차이점을 보여 줍니다.</p>

<p>Javascript는 생성자 함수 정의 이후에 언제든 생성자 함수의 프로토타입(prototype) 속성의 값으로 프로토타입 인스턴스를 추가할 수 있습니다.</p>

<p>Java는 클래스 정의에 상위 클래스를 명시해야 합니다. 클래스 정의 이후에는 상위 클래스를 변경할 수 없습니다.</p>

<p>Javascript:</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="kd">function</span> <span class="nx">Manager</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">Employee</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">reports</span> <span class="o">=</span> <span class="p">[];</span>
<span class="p">}</span>
<span class="nx">Manager</span><span class="p">.</span><span class="nx">prototype</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">create</span><span class="p">(</span><span class="nx">Employee</span><span class="p">.</span><span class="nx">prototype</span><span class="p">);</span>

<span class="kd">function</span> <span class="nx">WorkerBee</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">Employee</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">projects</span> <span class="o">=</span> <span class="p">[];</span>
<span class="p">}</span>
<span class="nx">WorkerBee</span><span class="p">.</span><span class="nx">prototype</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">create</span><span class="p">(</span><span class="nx">Employee</span><span class="p">.</span><span class="nx">prototype</span><span class="p">);</span>
</code></pre></div>
<p>Java:</p>
<div class="highlight"><pre><code class="language-jar" data-lang="jar">public class Manager extends Employee {
   public Employee[] reports = new Employee[0];
}


public class WorkerBee extends Employee {
   public String[] projects = new String[0];
}
</code></pre></div>
<p>엔지니어와 영업사원 정의들은 객체들을 생성합니다.</p>

<p>생성된 객체는 근로자 객체의 하위 객체이고 따라서 직원 객체의 하위 객체가 됩니다.</p>

<p>상속 관계에 따라 엔지니어와 영업사원 객체들은 근로자와 직원객체의 속성을 가지게 됩니다.</p>

<p>게다가, 상속받은 부서 속성은 엔지니어와 영업사원에서 재정되어 새로운 값을 가지게 됩니다.</p>

<p>Javascript:</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="kd">function</span> <span class="nx">SalesPerson</span><span class="p">()</span> <span class="p">{</span>
   <span class="nx">WorkerBee</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
   <span class="k">this</span><span class="p">.</span><span class="nx">dept</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">sales</span><span class="dl">"</span><span class="p">;</span>
   <span class="k">this</span><span class="p">.</span><span class="nx">quota</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>
<span class="p">}</span>
<span class="nx">SalesPerson</span><span class="p">.</span><span class="nx">prototype</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">create</span><span class="p">(</span><span class="nx">WorkerBee</span><span class="p">.</span><span class="nx">prototype</span><span class="p">);</span>

<span class="kd">function</span> <span class="nx">Engineer</span><span class="p">()</span> <span class="p">{</span>
   <span class="nx">WorkerBee</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
   <span class="k">this</span><span class="p">.</span><span class="nx">dept</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">engineering</span><span class="dl">"</span><span class="p">;</span>
   <span class="k">this</span><span class="p">.</span><span class="nx">machine</span> <span class="o">=</span> <span class="dl">""</span><span class="p">;</span>
<span class="p">}</span>
<span class="nx">Engineer</span><span class="p">.</span><span class="nx">prototype</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">create</span><span class="p">(</span><span class="nx">WorkerBee</span><span class="p">.</span><span class="nx">prototype</span><span class="p">);</span>
</code></pre></div>
<p>Java:</p>
<div class="highlight"><pre><code class="language-jar" data-lang="jar">public class SalesPerson extends WorkerBee {
   public double quota;
   public dept = "sales";
   public quota = 100.0;
}


public class Engineer extends WorkerBee {
   public String machine;
   public dept = "engineering";
   public machine = "";
}
</code></pre></div>
<p>이런 정의 방법을 통해, 기본값을 가지는 각각의 속성을 포함하는 객체의 인스턴스를 생성할 수 있습니다.</p>

<p>다음 그림은 새로운 객체를 생성하고 새로운 객체에 대한 속성값들을 보여 표시하기 위한 자바스크립트의 정의들을 보여 줍니다.</p>

<blockquote>
<p>Note: 유의사항</p>

<p>클래스 기반 언어들에서 인스턴스라는 용어는 특정한 기술적 의미를 가지고 있습니다. 이러한 언어들에서,  하나의 인스턴스란 하나의 클래스의 개별적인  실체이며 클래스와는 근본적으로 다릅니다. 자바스크립트에서는 클래스와 인스턴스 간의 차이가 없기 때문에, "인스턴스"가 이런 기술적 의미를 갖지 않습니다. 하지만, 자바스크립트에 대해서 얘기하자면, 비공식적으로 "인스턴스"는 특정한 생성자 함수를 이용하여 생성된 오브젝트를  의미합니다. 그래서 이번 예제에서는 jane이  Engineer 의 인스턴스라고 할 수 있습니다. 이와 유사하게, 부모, 자식, 상위, 하위의 용어들은 자바스크립트에서 공식적인 의미를 갖지 않습니다; 다만 프로토타입 체인 상의 상위 또는 하위 객체를 지칭하기 위해서 비공식적으로 사용할 수 있습니다.</p>
</blockquote>

<h3 id="part-551bcf64b39d327f">간단한 정의로 객체 생성</h3>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="kd">var</span> <span class="nx">jim</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Employee</span><span class="p">;</span>
<span class="c1">// jim.name is ''</span>
<span class="c1">// jim.dept is 'general'</span>

<span class="kd">var</span> <span class="nx">sally</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Manager</span><span class="p">;</span>
<span class="c1">// sally.name is ''</span>
<span class="c1">// sally.dept is 'general'</span>
<span class="c1">// sally.reports is []</span>

<span class="kd">var</span> <span class="nx">mark</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">WorkerBee</span><span class="p">;</span>
<span class="c1">// mark.name is ''</span>
<span class="c1">// mark.dept is 'general'</span>
<span class="c1">// mark.projects is []</span>

<span class="kd">var</span> <span class="nx">fred</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">SalesPerson</span><span class="p">;</span>
<span class="c1">// fred.name is ''</span>
<span class="c1">// fred.dept is 'sales'</span>
<span class="c1">// fred.projects is []</span>
<span class="c1">// fred.quota is 100</span>

<span class="kd">var</span> <span class="nx">jane</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Engineer</span><span class="p">;</span>
<span class="c1">// jane.name is ''</span>
<span class="c1">// jane.dept is 'engineering'</span>
<span class="c1">// jane.projects is []</span>
<span class="c1">// jane.machine is ''</span>
</code></pre></div>
<hr>

<h2 id="object-properties">Object properties(객체 속성들)</h2>

<p>이번 장에서는 객체가 프로토타입체인 상의 다른 객체로부터 특성을 상속받는 방법과 런타임 상에서 프로퍼티를 추가하면 무슨 일이 일어나는 지 살펴봅니다.</p>

<h2 id="property">Property 상속</h2>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="kd">var</span> <span class="nx">mark</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">WorkerBee</span><span class="p">;</span>
</code></pre></div>
<p><code>new</code> 연산자를 만나면, Javascript는 새로운 일반 객체를 생성하고 암묵적으로 내부의 <code>[[Prototype]](__proto__)</code> 속성의 값을 <code>WorkerBee.prototype</code> 의 값으로 할당하며, 해당 객체를 <code>this</code> 키워드의 값으로써 생성자 함수 WorkerBee에 전달합니다.</p>

<p>내부의 <code>[[Prototype]]</code> 속성은 속성값을 반환하기 위해 사용할 프로토타입 체인을 결정합니다.</p>

<p>이런 속성들이 할당되면, Javascript는 새 객체를 반환하고, 할당 구문에 의해 변수 mark를 객체에 할당합니다.</p>

<p>이러한 절차는 mark가 프로토타입 체인으로부터 상속받는 속성의 값을 mark 객체 내부에(local values) 명시적으로 부여하진 않습니다.</p>

<p>당신이 속성의 값을 요청하면,
자바스크립트는 먼저 해당 객체에 값이 존재하는지 확인합니다.
존재한다면, 해당 값이 반환됩니다.
만약 해당 객체에 값이 없다면, 프로토타입 체인을 (내장 <code>[[Prototype]]</code> 속성;<code>__proto__</code>을 이용하여)확인합니다.
체인 상의 어떤 객체가 해당 속성의 값을 가지고 있다면 그 값이 반환됩니다.
그런 속성이 발견되지 않는다면, 자바스크립트는 객체가 속성을 가지고있지 않다고 할 것입니다.
이런 식으로, mark 객체는 다음의 속성과 값을 가집니다.</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="nx">mark</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="dl">""</span><span class="p">;</span>
<span class="nx">mark</span><span class="p">.</span><span class="nx">dept</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">general</span><span class="dl">"</span><span class="p">;</span>
<span class="nx">mark</span><span class="p">.</span><span class="nx">projects</span> <span class="o">=</span> <span class="p">[];</span>
</code></pre></div>
<p>mark 객체는 <code>mark.__proto__</code>로 연결되어 있는 원형의 객체로부터 이름(name)과 부서(dept)에 대한 값을 상속 받습니다.
근로자(WorkerBee) 생성자로부터 projects속성에 대한 값을 할당을 받습니다.
이것들이 Javascript 내에서 속성과 속성 값의 상속입니다.
이런 과정의 몇몇 세부 사항들은 <a href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Guide/%EA%B0%9D%EC%B2%B4_%EB%AA%A8%EB%8D%B8%EC%9D%98_%EC%84%B8%EB%B6%80%EC%82%AC%ED%95%AD#Property_inheritance_revisited" title="Property inheritance revisited" rel="nofollow" target="_blank">Property inheritance revisited</a>에서 다룹니다.</p>

<p>이런 생성자들은 당신이 직접 인스턴스에만 해당 하는 값을 설정하도록 하지 않기때문에, 객체에 대한 이런 정보들은 일반적으로 적용됩니다.
근로자(WorkerBee)로부터 생성된 모든 새로운 객체들은 기본값이 적용된 속성 값들을 가지게 됩니다.
물론, 속성 값들을 변경할 수 있습니다. 아래처럼 특정 인스턴스에만 해당하는 값을 설정할 수 있습니다.</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="nx">mark</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">Doe, Mark</span><span class="dl">"</span><span class="p">;</span>
<span class="nx">mark</span><span class="p">.</span><span class="nx">dept</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">admin</span><span class="dl">"</span><span class="p">;</span>
<span class="nx">mark</span><span class="p">.</span><span class="nx">projects</span> <span class="o">=</span> <span class="p">[</span><span class="dl">"</span><span class="s2">navigator</span><span class="dl">"</span><span class="p">];</span>
</code></pre></div>
<h3 id="property">Property 추가</h3>

<p>자바스크립트에선, 실행 시점에 특정 객체에 속성들을 추가 할 수 있습니다.
생성자 함수가 제공하는 속성외에 다른 속성을 추가할 수 있습니다.
특정 단일 객체에 속성을 추가하기 위해선, 다음과 같이 해당 객체에 값을 할당 하면 됩니다:</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="nx">mark</span><span class="p">.</span><span class="nx">bonus</span> <span class="o">=</span> <span class="mi">3000</span><span class="p">;</span>
</code></pre></div>
<p>이렇게 하면 mark객체는 보너스(bonus)속성을 가지게 됩니다. 하지만 mark객체를 제외한 나머지 근로자(WorkerBee)객체들은 보너스 속성을 가지지 않습니다.</p>

<p>만약 생성자 함수의 원형으로 사용되는 객체에 새로운 속성을 추가한다면,  해당 프로토타입 객체(prototype)의 속성을 상속받는 모든 객체에 해당 속성이 추가됩니다. 예를 들면, 전문분야(specialty)속성을 모든 직원 객체에 다음과 같은 구문으로 추가할 수 있습니다:</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="nx">Employee</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">specialty</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">none</span><span class="dl">"</span><span class="p">;</span>
</code></pre></div>
<p>위의 구문을 실행한 직후, mark객체는 "none"이라는 값을 가지는 전문분야(specialty)속성을 가지게 됩니다. 아래의 그림들은 해당 속성을 추가한 후 엔지니어(Engineer) 프로토타입에 대해 해당 속성을 재정의 했을 경우 각 객체에 미치는 영향을 보여줍니다.</p>

<p><img src="../../img/figure8.4.png" alt="Property 추가"></p>

<hr>

<h2 id="part-fcedba69a4267b41">좀 더 유연한 생성자들</h2>

<p>지금까지 살펴 본 생성자 함수들은 인스턴스를 생성하면서 동시에 속성값을 지정할 수 없었습니다.
Java의 경우, 인스턴스를 생성 시 생성자에 인자들을 넘겨주어 인스턴스의 속성들을 초기화 할 수 있습니다.
다음의 예제 그림들은 자바처럼 인스턴스 생성 시 속성값을 설정하는 방법을 보여줍니다.</p>

<p>Javascript:</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="kd">function</span> <span class="nx">Employee</span> <span class="p">(</span><span class="nx">name</span><span class="p">,</span> <span class="nx">dept</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="nx">name</span> <span class="o">||</span> <span class="dl">""</span><span class="p">;</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">dept</span> <span class="o">=</span> <span class="nx">dept</span> <span class="o">||</span> <span class="dl">"</span><span class="s2">general</span><span class="dl">"</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nx">WorkerBee</span> <span class="p">(</span><span class="nx">projs</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">projects</span> <span class="o">=</span> <span class="nx">projs</span> <span class="o">||</span> <span class="p">[];</span>
<span class="p">}</span>
<span class="nx">WorkerBee</span><span class="p">.</span><span class="nx">prototype</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Employee</span><span class="p">;</span>

<span class="kd">function</span> <span class="nx">Engineer</span> <span class="p">(</span><span class="nx">mach</span><span class="p">)</span> <span class="p">{</span>
   <span class="k">this</span><span class="p">.</span><span class="nx">dept</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">engineering</span><span class="dl">"</span><span class="p">;</span>
   <span class="k">this</span><span class="p">.</span><span class="nx">machine</span> <span class="o">=</span> <span class="nx">mach</span> <span class="o">||</span> <span class="dl">""</span><span class="p">;</span>
<span class="p">}</span>
<span class="nx">Engineer</span><span class="p">.</span><span class="nx">prototype</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">WorkerBee</span><span class="p">;</span>
</code></pre></div>
<p>Java:</p>
<div class="highlight"><pre><code class="language-jar" data-lang="jar">public class Employee {
   public String name;
   public String dept;
   public Employee () {
      this("", "general");
   }
   public Employee (String name) {
      this(name, "general");
   }
   public Employee (String name, String dept) {
      this.name = name;
      this.dept = dept;
   }
}

public class WorkerBee extends Employee {
   public String[] projects;
   public WorkerBee () {
      this(new String[0]);
   }
   public WorkerBee (String[] projs) {
      projects = projs;
   }
}

public class Engineer extends WorkerBee {
   public String machine;
   public Engineer () {
      dept = "engineering";
      machine = "";
   }
   public Engineer (String mach) {
      dept = "engineering";
      machine = mach;
   }
}
</code></pre></div>
<p>자바스크립트의 속성값을 설정하는 방법은 기본값을 설정하기 위한 관용구를 사용합니다.</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="k">this</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="nx">name</span> <span class="o">||</span> <span class="dl">""</span><span class="p">;</span>
</code></pre></div>
<p>자바스크립트의 OR 논리 연산자(||) 첫번째 인자를 평가합니다.
첫번째 인자가 참이면 첫번째 인자를 반환하고 그렇지 않은 경우는 두번째 인자를 반환합니다.
그러므로, 위의 코드는 name인자가 name 속성에 사용 가능한 값을 가지고 있는지 확인합니다.
확인 결과 name속성에 사용가능한 값을 가지고 있을 경우, 해당 값을 this.name에 설정하게 됩니다.
반대로 그렇지 않은 경우는 빈 문자열을 this.name에 설정합니다.
얼핏 보면 헷갈리지만 보다 짧은 관용구를 사용하였습니다.</p>

<blockquote>
<p>주의:
만약 인자로 false와 빈 문자열 값을 줄 경우 해당 구문은 예상한 대로 작동하지 않을 수 있습니다.</p>
</blockquote>

<p>이런 정의들을 가지고, 객체의 인스턴스를 생성할때, 객체 자신만의 속성에 대한 값을 지정할 수 있습니다. 새로운 Engineer를 생성하기 위해서 다음과 같은 구문을 사용할 수 있습니다:</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="kd">var</span> <span class="nx">jane</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Engineer</span><span class="p">(</span><span class="dl">"</span><span class="s2">belau</span><span class="dl">"</span><span class="p">);</span>
<span class="c1">// jane.name == "";</span>
<span class="c1">// jane.dept == "engineering";</span>
<span class="c1">// jane.projects == [];</span>
<span class="c1">// jane.machine == "belau"</span>
</code></pre></div>
<p>위와 같은 코드 구문으로는 name과 같이 상속받은 속성에 대한 초기값을 지정할 수 없습니다.
만약 상속 받은 속성의 초기값을 설정하고자 한다면, 생성자 함수의 코드를 변경해야 합니다.</p>

<p>지금까지, 원형 객체를 생성한 후, 그 새로운 객체 자신의 속성과 속성 값을 지정하는 것을 살펴 보았습니다.
프로토타입 체인상에서 해당 생성자가 상위 객체에 대한 생성자를 직접 호출 함으로써 더 많은 속성을 추가하도록 할 수 있습니다.
다음의 그림은 새로운 정의 방법을 보여 줍니다.</p>

<p><img src="../../img/figure8.6.png" alt="생성자내에서 속성들 정의, 그림 2"></p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="kd">function</span> <span class="nx">WorkerBee</span> <span class="p">(</span><span class="nx">name</span><span class="p">,</span> <span class="nx">dept</span><span class="p">,</span> <span class="nx">projs</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">base</span> <span class="o">=</span> <span class="nx">Employee</span><span class="p">;</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">base</span><span class="p">(</span><span class="nx">name</span><span class="p">,</span> <span class="nx">dept</span><span class="p">);</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">projects</span> <span class="o">=</span> <span class="nx">projs</span> <span class="o">||</span> <span class="p">[];</span>
<span class="p">}</span>

<span class="nx">WorkerBee</span><span class="p">.</span><span class="nx">prototype</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Employee</span><span class="p">;</span>

<span class="kd">function</span> <span class="nx">Engineer</span> <span class="p">(</span><span class="nx">name</span><span class="p">,</span> <span class="nx">projs</span><span class="p">,</span> <span class="nx">mach</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">base</span> <span class="o">=</span> <span class="nx">WorkerBee</span><span class="p">;</span>  <span class="c1">// WorkerBee 안에서 호출된 this 는 Engineer 를 나타낸다</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">base</span><span class="p">(</span><span class="nx">name</span><span class="p">,</span> <span class="dl">"</span><span class="s2">engineering</span><span class="dl">"</span><span class="p">,</span> <span class="nx">projs</span><span class="p">);</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">machine</span> <span class="o">=</span> <span class="nx">mach</span> <span class="o">||</span> <span class="dl">""</span><span class="p">;</span>
<span class="p">}</span>

<span class="nx">Engineer</span><span class="p">.</span><span class="nx">prototype</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">WorkerBee</span><span class="p">;</span>
</code></pre></div><div class="highlight"><pre><code class="language-js" data-lang="js"><span class="kd">var</span> <span class="nx">jane</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Engineer</span><span class="p">(</span><span class="dl">"</span><span class="s2">Doe, Jane</span><span class="dl">"</span><span class="p">,</span> <span class="p">[</span><span class="dl">"</span><span class="s2">navigator</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">javascript</span><span class="dl">"</span><span class="p">],</span> <span class="dl">"</span><span class="s2">belau</span><span class="dl">"</span><span class="p">);</span>
</code></pre></div>
<p>다음과 같은 순서에 따라 객체를 생성하고 속성을 정의하게 됩니다:</p>

<ol>
<li><p>new 연산자는 프로토타입 객체를 생성하고 생성된 객체의 <code>__proto__</code>속성을 <code>Engineer.prototype</code>으로 설정합니다.</p></li>
<li><p>new 연산자는 새로이 생성된 객체를 엔지니어(Engineer)생성자에 this 키워드의 값으로 전달합니다.</p></li>
<li><p>생성자는 생성한 객체에 대한 base라는 새로운 속성을 생성하고 근로자(WorkerBee) 생성자의 값을 base 속성에 할당합니다.
이런 과정은 근로자(WorkerBee) 생성자를 엔지니어(Engineer)객체의 메서드로 만듭니다.
base 속성의 이름은 그리 특별하지 않습니다.
다른 어떤 속성명을 사용해도 무방합니다.
base 속성명은 단지 해당 속성의 목적을 환기시키기 위한 것입니다.</p></li>
<li><p>생성자는 base 메서드에 필요한 인자들 <code>("Doe, Jane" and ["navigator", "javascript"])</code>을 주어 호출합니다.
명시적으로 생성자에서 사용한 "engineering"은 모든 엔지니어(Engineer)객체들이 상속받은 부서 속성에 대한 동일한 값을 가지며, 직원(Employee)으로부터 상속받은 값을 재정의 하는 것을 나타냅니다.</p></li>
<li><p>base가 엔지니어(Engineer)의 메서드이기때문에 base메서드 내에서 this 키워드를 스텝1에서 생성한 객체를 지칭하도록 해줍니다.
따라서, 근로자(WorkerBee) 함수는 차례대로 "Doe, Jane"과 "engineering" 인자를 직원(Employee)생성자에 전달합니다.
직원(Employee)생성자로부터 반환 시, 근로자(WorkerBee)함수는 남은 인자들을 프로젝트(projects)속성을 설정하기 위해 사용합니다.</p></li>
<li><p>base메서드로부터 반환 시, 엔지니어(Engineer) 생성자는 해당 객체의 장비(machine)속성을 "belau"로 초기화 합니다.</p></li>
<li><p>생성자로부터 반환 시, 새롭게 생성된 객체를 jane변수에 할당 합니다.</p></li>
</ol>

<p>엔지니어(Engineer) 생성자내에서 근로자(WorkerBee) 생성자를 호출하면, 엔지니어(Engineer)에 대한 상속을 적절하게 설정할 수 도 있을 것이라고 생각할 수 있을 것입니다.
하지만 그렇지 않습니다.
근로자(WorkerBee)생성자를 호출하는 것은 엔지니어(Engineer)객체로 하여금 호출되는 모든 생성자 함수내에서 열거된 속성들을 가지고도록 보장합니다.
그러나, 나중에 직원(Employee)혹은 근로자(WorkerBee) 원형에 속성을 추가한다면, 엔지니어(Engineer)객체에 의해 추가된 속성들은 상속이 되지 않습니다.
예를 들어, 아래와 같은 구문을 작성하였다고 가정합니다:</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="kd">function</span> <span class="nx">Engineer</span> <span class="p">(</span><span class="nx">name</span><span class="p">,</span> <span class="nx">projs</span><span class="p">,</span> <span class="nx">mach</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">base</span> <span class="o">=</span> <span class="nx">WorkerBee</span><span class="p">;</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">base</span><span class="p">(</span><span class="nx">name</span><span class="p">,</span> <span class="dl">"</span><span class="s2">engineering</span><span class="dl">"</span><span class="p">,</span> <span class="nx">projs</span><span class="p">);</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">machine</span> <span class="o">=</span> <span class="nx">mach</span> <span class="o">||</span> <span class="dl">""</span><span class="p">;</span>
<span class="p">}</span>
<span class="kd">var</span> <span class="nx">jane</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Engineer</span><span class="p">(</span><span class="dl">"</span><span class="s2">Doe, Jane</span><span class="dl">"</span><span class="p">,</span> <span class="p">[</span><span class="dl">"</span><span class="s2">navigator</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">javascript</span><span class="dl">"</span><span class="p">],</span> <span class="dl">"</span><span class="s2">belau</span><span class="dl">"</span><span class="p">);</span>
<span class="nx">Employee</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">specialty</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">none</span><span class="dl">"</span><span class="p">;</span>
</code></pre></div>
<p>위는 jane객체는 전문분야(specialty)속성을 상속받지 않습니다.</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="kd">function</span> <span class="nx">Engineer</span> <span class="p">(</span><span class="nx">name</span><span class="p">,</span> <span class="nx">projs</span><span class="p">,</span> <span class="nx">mach</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">base</span> <span class="o">=</span> <span class="nx">WorkerBee</span><span class="p">;</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">base</span><span class="p">(</span><span class="nx">name</span><span class="p">,</span> <span class="dl">"</span><span class="s2">engineering</span><span class="dl">"</span><span class="p">,</span> <span class="nx">projs</span><span class="p">);</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">machine</span> <span class="o">=</span> <span class="nx">mach</span> <span class="o">||</span> <span class="dl">""</span><span class="p">;</span>
<span class="p">}</span>
<span class="nx">Engineer</span><span class="p">.</span><span class="nx">prototype</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">WorkerBee</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">jane</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Engineer</span><span class="p">(</span><span class="dl">"</span><span class="s2">Doe, Jane</span><span class="dl">"</span><span class="p">,</span> <span class="p">[</span><span class="dl">"</span><span class="s2">navigator</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">javascript</span><span class="dl">"</span><span class="p">],</span> <span class="dl">"</span><span class="s2">belau</span><span class="dl">"</span><span class="p">);</span>
<span class="nx">Employee</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">specialty</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">none</span><span class="dl">"</span><span class="p">;</span>
</code></pre></div>
<p>이제 jane객체의 전문분야(specialty)속성은 "none"이 되었습니다.</p>

<p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/call" rel="nofollow" target="_blank">call()</a> 혹은 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/apply" rel="nofollow" target="_blank">apply()</a> 메서드를 사용는 것은 상속을 구현하는 또 다른 방법입니다.
다음의 두 예제는 동일한 결과를 보여줍니다.</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="kd">function</span> <span class="nx">Engineer</span> <span class="p">(</span><span class="nx">name</span><span class="p">,</span> <span class="nx">projs</span><span class="p">,</span> <span class="nx">mach</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">base</span> <span class="o">=</span> <span class="nx">WorkerBee</span><span class="p">;</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">base</span><span class="p">(</span><span class="nx">name</span><span class="p">,</span> <span class="dl">"</span><span class="s2">engineering</span><span class="dl">"</span><span class="p">,</span> <span class="nx">projs</span><span class="p">);</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">machine</span> <span class="o">=</span> <span class="nx">mach</span> <span class="o">||</span> <span class="dl">""</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><div class="highlight"><pre><code class="language-js" data-lang="js"><span class="kd">function</span> <span class="nx">Engineer</span> <span class="p">(</span><span class="nx">name</span><span class="p">,</span> <span class="nx">projs</span><span class="p">,</span> <span class="nx">mach</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">WorkerBee</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="nx">name</span><span class="p">,</span> <span class="dl">"</span><span class="s2">engineering</span><span class="dl">"</span><span class="p">,</span> <span class="nx">projs</span><span class="p">);</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">machine</span> <span class="o">=</span> <span class="nx">mach</span> <span class="o">||</span> <span class="dl">""</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<p><code>this.base</code>를 사용하지 않고 구현을 하기 때문에, <code>call()</code> 메서드를 사용하여 상속을 구현하는 것이 보다 깔끔합니다.</p>

<hr>

<h2 id="part-d02444ebf5cd0c68">속성 상속의 재고</h2>

<p>이전 절에서 자바스크립트의 생성자와 원형(prototype)이 어떤 방식으로 상속과 객체의 계층 구조를 제공하는지를 살펴 보았습니다. 이번장에서는 이전 절에서 반드시 명백하게 짚고 넘어가지 않은 일부 미묘한 점들에 대해 살펴보겠습니다.</p>

<h3 id="part-2737e4eda5b160bf">객체 자신의 값과 상속받은 값</h3>

<p>이번 장에서 이미 설명된 것 처럼, 객체의 속성에 접근할 때, Javascript는 아래와 같은 절차를 따릅니다.</p>

<ol>
<li> 해당 속성에 대한 객체 자신의 값이 있는지 확인하고 있으면 그 값을 반환한다.</li>
<li> 객체 자신의 값이 없으면 <code>__proto__</code> 속성을 사용하여 prototype 체인을 확인한다.</li>
<li> 프로토타입 체인상의 특정 객체가 해당 속성에 대한 값을 가지고 있다면 해당 객체의 값을 반환한다.</li>
<li> 해당 속성을 가진 어떤 객체도 발견하지 못하면 해당 객체는 그 속성을 가지고 있지 않은 것으로 판단한다.</li>
</ol>

<p>이런 단계들의 결과는 생성자 및 prototype 체인등의 것들을 어떻게 정의 하느냐에 따라 달라집니다.</p>

<p>아래와 같은 원래의 예제는 이런 정의들을 가지고 있습니다.</p>

<p>이런 정의들을 가지고, amy라는 근로자(WorkerBee)인스턴스를 아래와 같이 생성하였다고 가정합니다:</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="kd">function</span> <span class="nx">Employee</span> <span class="p">()</span> <span class="p">{</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="dl">""</span><span class="p">;</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">dept</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">general</span><span class="dl">"</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nx">WorkerBee</span> <span class="p">()</span> <span class="p">{</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">projects</span> <span class="o">=</span> <span class="p">[];</span>
<span class="p">}</span>
<span class="nx">WorkerBee</span><span class="p">.</span><span class="nx">prototype</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Employee</span><span class="p">;</span>

<span class="kd">var</span> <span class="nx">amy</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">WorkerBee</span><span class="p">;</span>

<span class="nx">Employee</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">Unknown</span><span class="dl">"</span>

<span class="c1">// 따라서 amy는 이런 속성들의 값을 가지게 됩니다.</span>
<span class="nx">amy</span><span class="p">.</span><span class="nx">name</span>  <span class="c1">// ""</span>
<span class="nx">amy</span><span class="p">.</span><span class="nx">dept</span>  <span class="c1">// "general"</span>
<span class="nx">amy</span><span class="p">.</span><span class="nx">projects</span>  <span class="c1">// []</span>
</code></pre></div>
<p>amy 객체는 프로젝트라는 자신만의 속성을 가집니다.
이름과 부서 속성들은 amy 자신의 속성이 아닌 amy객체의 <code>__proto__</code> 속성을 통해 가지고 온 속성들입니다.</p>

<p>얼핏보기에, 새로운 값이 모든 직원 인스턴스에 적용이 될것으로 예상하겠지만 그렇지 않습니다.</p>

<p><strong>직원 객체의 인스턴스를 생성할때, 해당 인스턴스는 이름 속성에 대해 자신이 가지고 있는 값(빈 문자열)을 취하게 됩니다.
이것이 의미하는 것은 새로운 직원 객체를 생성하여 근로자(WorkerBee)의 프로토타입에 설정을 할때, WorkerBee.prototype이 이름 속성에 대한 자신만의 값을 가지고 있다는 것입니다.
그러므로, amy객체(근로자 인스턴스)의 이름 속성에 대해 검색할때, WorkerBee.prototype내에서 이름 속성에 대한 amy 객체 자신의 값을 찾게 됩니다.
그렇기 때문에 Employee.prototype까지의 프로토타입 체인을 검색하지 않게 됩니다.</strong></p>

<p>실행시에 객체의 속성 값을 변경하고 새로운 값이 모든 하위 객체들에게도 적용되도록 할려면, 객체의 생성자함수에서는 속성을 정의할 수 없습니다.
대신에, 생성자와 연결된 프로토타입에 추가할 수 있습니다. 예를 들어, 이전의 코드를 아래와 같이 변경하였다고 가정합니다:</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="kd">function</span> <span class="nx">Employee</span> <span class="p">()</span> <span class="p">{</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">dept</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">general</span><span class="dl">"</span><span class="p">;</span>
<span class="p">}</span>
<span class="nx">Employee</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="dl">""</span><span class="p">;</span>

<span class="kd">function</span> <span class="nx">WorkerBee</span> <span class="p">()</span> <span class="p">{</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">projects</span> <span class="o">=</span> <span class="p">[];</span>
<span class="p">}</span>
<span class="nx">WorkerBee</span><span class="p">.</span><span class="nx">prototype</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Employee</span><span class="p">;</span>

<span class="kd">var</span> <span class="nx">amy</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">WorkerBee</span><span class="p">;</span>

<span class="nx">Employee</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">Unknown</span><span class="dl">"</span><span class="p">;</span>

<span class="nx">amy</span><span class="p">.</span><span class="nx">name</span>  <span class="c1">// "Unknown"</span>
</code></pre></div>
<p>위의 예제에서처럼, 객체 생성 시에 객체의 속성에 대한 기본 값을 설정하고 실행 시에 해당 속성의 값을 변경하기를 원한다면, 해당 속성들을 생성자 함수 자체안에가 아닌 생성자의 프로토타입에 설정 하여야 합니다.</p>

<h3 id="instances">Instances 관계 설정</h3>

<p>Javascript에서의 속성 검색은 <strong>객체 자신의 속성들을 먼저 살펴보고 해당 속성명을 찾지 못할 경우, 객체의 특별한 속성인 <code>__proto__</code> 내에서 찾게 됩니다.
이런 검색은 재귀적으로 진행되며, 이런 과정을 "프로토타입 체인에서의 검색"이라고 합니다.</strong></p>

<p>특별한 속성인 <code>__proto__</code> 객체가 생성이 될때 설정이 됩니다.
<code>__proto__</code> 속성은 생성자의 프로토타입 속성의 값으로 설정이 됩니다.
따라서 <code>new Foo()</code> 표현식은 <code>__proto__</code> == Foo.prototype인 객체를 생성합니다.
결과적으로 <code>Foo.prototype</code>의 속성들에 대한 변경은 <code>new Foo()</code> 표현식으로 생성한 모든 객체에 대한 속성 검색을 변경하게 됩니다.</p>

<p>모든 객체는 <code>__proto__</code> 라는 객체 속성을 가집니다.(예외: Object).
모든 함수들은 prototype 이라는 객체 속성을 가집니다.
따라서 객체들은 '프로토타입 상속'에 의해 다른 객체들과의 관계를 가지게 됩니다.
객체의 <code>__proto__</code> 속성과 함수의 prototype 객체를 비교하여 상속을 테스트 해볼 수 있습니다.
Javascript는 특정 객체가 함수 prototype으로부터 상속 받는 객체일 경우 참(true)를 반환하는  instanceof라는 연산자를 제공합니다. 예를 들면,</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="kd">var</span> <span class="nx">f</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Foo</span><span class="p">();</span>
<span class="kd">var</span> <span class="nx">isTrue</span> <span class="o">=</span> <span class="p">(</span><span class="nx">f</span> <span class="k">instanceof</span> <span class="nx">Foo</span><span class="p">);</span>
</code></pre></div>
<p>Inheriting properties에 나오는 예제와 동일한 정의들을 작성해 놓았을 경우, 보다 상세한 예제는 아래와 같습니다.엔지니어(Engineer)객체를 아래와 같이 생성합니다:</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="kd">var</span> <span class="nx">chris</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Engineer</span><span class="p">(</span><span class="dl">"</span><span class="s2">Pigman, Chris</span><span class="dl">"</span><span class="p">,</span> <span class="p">[</span><span class="dl">"</span><span class="s2">jsd</span><span class="dl">"</span><span class="p">],</span> <span class="dl">"</span><span class="s2">fiji</span><span class="dl">"</span><span class="p">);</span>
</code></pre></div>
<p>생성된 객체를 가지고 아래와 같은 구문을 실행할 경우 각 구문에 대한 결과는 모두 참(true)입니다.</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="nx">chris</span><span class="p">.</span><span class="nx">__proto__</span> <span class="o">==</span> <span class="nx">Engineer</span><span class="p">.</span><span class="nx">prototype</span><span class="p">;</span>
<span class="nx">chris</span><span class="p">.</span><span class="nx">__proto__</span><span class="p">.</span><span class="nx">__proto__</span> <span class="o">==</span> <span class="nx">WorkerBee</span><span class="p">.</span><span class="nx">prototype</span><span class="p">;</span>
<span class="nx">chris</span><span class="p">.</span><span class="nx">__proto__</span><span class="p">.</span><span class="nx">__proto__</span><span class="p">.</span><span class="nx">__proto__</span> <span class="o">==</span> <span class="nx">Employee</span><span class="p">.</span><span class="nx">prototype</span><span class="p">;</span>
<span class="nx">chris</span><span class="p">.</span><span class="nx">__proto__</span><span class="p">.</span><span class="nx">__proto__</span><span class="p">.</span><span class="nx">__proto__</span><span class="p">.</span><span class="nx">__proto__</span> <span class="o">==</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">prototype</span><span class="p">;</span>
<span class="nx">chris</span><span class="p">.</span><span class="nx">__proto__</span><span class="p">.</span><span class="nx">__proto__</span><span class="p">.</span><span class="nx">__proto__</span><span class="p">.</span><span class="nx">__proto__</span><span class="p">.</span><span class="nx">__proto__</span> <span class="o">==</span> <span class="kc">null</span><span class="p">;</span>
</code></pre></div>
<h3 id="part-e607827fbf5de040">생성자내에서의 전역 정보</h3>

<p>생성자를 생성할때, 생성자내에서 전역 정보를 설정할 경우, 주의를 해야 합니다. 예를 들어, 각각의 새로운 직원에게 자동으로 고유한 ID값을 할당하기를 원한다고 했을 때, 다음과 같은 직원(Employee) 정의를 사용할 수 있을 것입니다:</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="kd">var</span> <span class="nx">idCounter</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

<span class="kd">function</span> <span class="nx">Employee</span> <span class="p">(</span><span class="nx">name</span><span class="p">,</span> <span class="nx">dept</span><span class="p">)</span> <span class="p">{</span>
   <span class="k">this</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="nx">name</span> <span class="o">||</span> <span class="dl">""</span><span class="p">;</span>
   <span class="k">this</span><span class="p">.</span><span class="nx">dept</span> <span class="o">=</span> <span class="nx">dept</span> <span class="o">||</span> <span class="dl">"</span><span class="s2">general</span><span class="dl">"</span><span class="p">;</span>
   <span class="k">this</span><span class="p">.</span><span class="nx">id</span> <span class="o">=</span> <span class="nx">idCounter</span><span class="o">++</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<p>이런 정의 내용을 가지고, 새로운 직원을 생성했을 때, 생성자는 다음의 고유한 ID값을 새로운 직원객체에 할당하고 전역 ID 카운터를 증가 시킵니다. 따라서 다음과 같은 구문으로 각각의 객체를 생성한다면, 결과는 victoria.id는 1 그리고 harry.id는 2가 됩니다:</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="kd">var</span> <span class="nx">victoria</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Employee</span><span class="p">(</span><span class="dl">"</span><span class="s2">Pigbert, Victoria</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">pubs</span><span class="dl">"</span><span class="p">);</span>
<span class="kd">var</span> <span class="nx">harry</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Employee</span><span class="p">(</span><span class="dl">"</span><span class="s2">Tschopik, Harry</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">sales</span><span class="dl">"</span><span class="p">);</span>
</code></pre></div>
<p>얼핏보면 괜찮아 보입니다. 하지만 이유를 불문하고 직원 객체가 생성될때마다 idCounter는 증가분을 가지게 됩니다.이번장에서 나온 예제에서처럼 전체 직원 객체의 계층 구조를 생성하였다면, 프로토타입을 설정할때마다 직원 생성자는 매번 호출 됩니다.다음과 같은 코드를 작성하였다고 가정합니다:</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="kd">var</span> <span class="nx">idCounter</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

<span class="kd">function</span> <span class="nx">Employee</span> <span class="p">(</span><span class="nx">name</span><span class="p">,</span> <span class="nx">dept</span><span class="p">)</span> <span class="p">{</span>
   <span class="k">this</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="nx">name</span> <span class="o">||</span> <span class="dl">""</span><span class="p">;</span>
   <span class="k">this</span><span class="p">.</span><span class="nx">dept</span> <span class="o">=</span> <span class="nx">dept</span> <span class="o">||</span> <span class="dl">"</span><span class="s2">general</span><span class="dl">"</span><span class="p">;</span>
   <span class="k">this</span><span class="p">.</span><span class="nx">id</span> <span class="o">=</span> <span class="nx">idCounter</span><span class="o">++</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nx">Manager</span> <span class="p">(</span><span class="nx">name</span><span class="p">,</span> <span class="nx">dept</span><span class="p">,</span> <span class="nx">reports</span><span class="p">)</span> <span class="p">{...}</span>
<span class="nx">Manager</span><span class="p">.</span><span class="nx">prototype</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Employee</span><span class="p">;</span>

<span class="kd">function</span> <span class="nx">WorkerBee</span> <span class="p">(</span><span class="nx">name</span><span class="p">,</span> <span class="nx">dept</span><span class="p">,</span> <span class="nx">projs</span><span class="p">)</span> <span class="p">{...}</span>
<span class="nx">WorkerBee</span><span class="p">.</span><span class="nx">prototype</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Employee</span><span class="p">;</span>

<span class="kd">function</span> <span class="nx">Engineer</span> <span class="p">(</span><span class="nx">name</span><span class="p">,</span> <span class="nx">projs</span><span class="p">,</span> <span class="nx">mach</span><span class="p">)</span> <span class="p">{...}</span>
<span class="nx">Engineer</span><span class="p">.</span><span class="nx">prototype</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">WorkerBee</span><span class="p">;</span>

<span class="kd">function</span> <span class="nx">SalesPerson</span> <span class="p">(</span><span class="nx">name</span><span class="p">,</span> <span class="nx">projs</span><span class="p">,</span> <span class="nx">quota</span><span class="p">)</span> <span class="p">{...}</span>
<span class="nx">SalesPerson</span><span class="p">.</span><span class="nx">prototype</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">WorkerBee</span><span class="p">;</span>

<span class="kd">var</span> <span class="nx">mac</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Engineer</span><span class="p">(</span><span class="dl">"</span><span class="s2">Wood, Mac</span><span class="dl">"</span><span class="p">);</span>
</code></pre></div>
<p>여기서 생략된 정의가 base속성을 가지고 해당 생성자를 프로토타입 체인내의 상위 생성자들을 호출한닥고 좀 더 가정하면, 이런 경우, 생성된 mac객체의 id값은 5가 됩니다.</p>

<p>어플리케이셔네 따라, 카운터가 이렇게 추가적으로 증가된 것은 문제가 될 수도 그렇지 않을 수 도 있습니다. 카운터에 정확한 값이 설정되기를 원한다면, 사용가능한 해결적은 아래와 같은 생성자를 대신 사용하는 것입니다:</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="kd">function</span> <span class="nx">Employee</span> <span class="p">(</span><span class="nx">name</span><span class="p">,</span> <span class="nx">dept</span><span class="p">)</span> <span class="p">{</span>
   <span class="k">this</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="nx">name</span> <span class="o">||</span> <span class="dl">""</span><span class="p">;</span>
   <span class="k">this</span><span class="p">.</span><span class="nx">dept</span> <span class="o">=</span> <span class="nx">dept</span> <span class="o">||</span> <span class="dl">"</span><span class="s2">general</span><span class="dl">"</span><span class="p">;</span>
   <span class="k">if</span> <span class="p">(</span><span class="nx">name</span><span class="p">)</span>
      <span class="k">this</span><span class="p">.</span><span class="nx">id</span> <span class="o">=</span> <span class="nx">idCounter</span><span class="o">++</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<p>prototype으로 사용할 직원 인스턴스를 생성할 때, 생성자에 인자들을 주어선 안됩니다. 이 생성자 정의를 사용하여, 인자들을 주지 않을 경우, 생성자는 id에 값을 할당하지 않으며 카운터를 갱신하지 않습니다. 따라서, id값을 가지는 직원 객체에 대해, 반드시 해당 직원의 이름을 명시해야 합니다. 이 예제의 경우 mac인스턴스의 id값은 1이 됩니다.</p>

<h3 id="part-a70ffb3f5d37ea0c">다중상속 금지</h3>

<p>몇몇 객체 지향언어들은 다중 상속을 허용합니다. 그것은, 관련이 없는 부모 객체들로 부터 속성들과 값들을 상속 받을 수 있는 것을 말합니다. 자바스크립트는 다중 상속을 지원하지 않습니다.</p>

<p>속성 값의 상속은 속성에 대한 값을 찾기 위한 프로토타입 체인을 검색에 의해 실행 시점에 이루어 집니다. 하나의 객체는 오로지 하나의 결합된 prototype만을 가지기 때문에, 자바스크립트는 동적으로 하나 이상의 프로토타입 체인으로 부터 상속을 할 수 없습니다.</p>

<p>자바스크립트에서, 하나 이상의 다른 생성자 함수를 호출하는 생성자를 사용할 수 있습니다. 이것은 다중 상속처럼 보여질 수 있습니다. 예를 들어, 다음과 같은 구문들을 살펴보세요:</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="kd">function</span> <span class="nx">Hobbyist</span> <span class="p">(</span><span class="nx">hobby</span><span class="p">)</span> <span class="p">{</span>
   <span class="k">this</span><span class="p">.</span><span class="nx">hobby</span> <span class="o">=</span> <span class="nx">hobby</span> <span class="o">||</span> <span class="dl">"</span><span class="s2">scuba</span><span class="dl">"</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nx">Engineer</span> <span class="p">(</span><span class="nx">name</span><span class="p">,</span> <span class="nx">projs</span><span class="p">,</span> <span class="nx">mach</span><span class="p">,</span> <span class="nx">hobby</span><span class="p">)</span> <span class="p">{</span>
   <span class="k">this</span><span class="p">.</span><span class="nx">base1</span> <span class="o">=</span> <span class="nx">WorkerBee</span><span class="p">;</span>
   <span class="k">this</span><span class="p">.</span><span class="nx">base1</span><span class="p">(</span><span class="nx">name</span><span class="p">,</span> <span class="dl">"</span><span class="s2">engineering</span><span class="dl">"</span><span class="p">,</span> <span class="nx">projs</span><span class="p">);</span>
   <span class="k">this</span><span class="p">.</span><span class="nx">base2</span> <span class="o">=</span> <span class="nx">Hobbyist</span><span class="p">;</span>
   <span class="k">this</span><span class="p">.</span><span class="nx">base2</span><span class="p">(</span><span class="nx">hobby</span><span class="p">);</span>
   <span class="k">this</span><span class="p">.</span><span class="nx">machine</span> <span class="o">=</span> <span class="nx">mach</span> <span class="o">||</span> <span class="dl">""</span><span class="p">;</span>
<span class="p">}</span>
<span class="nx">Engineer</span><span class="p">.</span><span class="nx">prototype</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">WorkerBee</span><span class="p">;</span>

<span class="kd">var</span> <span class="nx">dennis</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Engineer</span><span class="p">(</span><span class="dl">"</span><span class="s2">Doe, Dennis</span><span class="dl">"</span><span class="p">,</span> <span class="p">[</span><span class="dl">"</span><span class="s2">collabra</span><span class="dl">"</span><span class="p">],</span> <span class="dl">"</span><span class="s2">hugo</span><span class="dl">"</span><span class="p">);</span>

<span class="nx">dennis</span><span class="p">.</span><span class="nx">name</span> <span class="o">==</span> <span class="dl">"</span><span class="s2">Doe, Dennis</span><span class="dl">"</span>
<span class="nx">dennis</span><span class="p">.</span><span class="nx">dept</span> <span class="o">==</span> <span class="dl">"</span><span class="s2">engineering</span><span class="dl">"</span>
<span class="nx">dennis</span><span class="p">.</span><span class="nx">projects</span> <span class="o">==</span> <span class="p">[</span><span class="dl">"</span><span class="s2">collabra</span><span class="dl">"</span><span class="p">]</span>
<span class="nx">dennis</span><span class="p">.</span><span class="nx">machine</span> <span class="o">==</span> <span class="dl">"</span><span class="s2">hugo</span><span class="dl">"</span>
<span class="nx">dennis</span><span class="p">.</span><span class="nx">hobby</span> <span class="o">==</span> <span class="dl">"</span><span class="s2">scuba</span><span class="dl">"</span>
</code></pre></div>
<p>따라서 dennis객체는 Hobbyist 생성자로부터 취미(hobby)속성을 받아 오지 않습니다. 그런데,Hobbyist생성자의 프로토타입에 속성을 추가 했다고 가정하면</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="nx">Hobbyist</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">equipment</span> <span class="o">=</span> <span class="p">[</span><span class="dl">"</span><span class="s2">mask</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">fins</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">regulator</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">bcd</span><span class="dl">"</span><span class="p">]</span>
</code></pre></div>
<p>객체는 새로이 추가된 속성을 상속받지 않습니다.</p>

<hr>

<h2 id="reference">Reference</h2>

<p><a href="https://developer.mozilla.org/en-us/docs/web/javascript/guide/details_of_the_object_model" rel="nofollow" target="_blank">details of the object model(객체 모델의 세부사항)</a></p>

</div>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/blog/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">Portal2312&#39;s blog</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">Portal2312&#39;s blog</li><li><a class="u-email" href="mailto:portal2312@gmail.com">portal2312@gmail.com</a></li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/portal2312"><svg class="svg-icon"><use xlink:href="/blog/assets/minima-social-icons.svg#github"></use></svg> <span class="username">portal2312</span></a></li><li><a href="https://www.twitter.com/portal2312"><svg class="svg-icon"><use xlink:href="/blog/assets/minima-social-icons.svg#twitter"></use></svg> <span class="username">portal2312</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>Welcome to my blog.</p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
