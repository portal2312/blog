<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.6.1 -->
<title>Docker overview | Portal2312&#39;s blog</title>
<meta name="generator" content="Jekyll v3.8.6" />
<meta property="og:title" content="Docker overview" />
<meta name="author" content="mkkim" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Docker는 응용 프로그램을 개발, 운송 및 실행하기위한 개방형 플랫폼입니다. Docker를 사용하면 인프라에서 응용 프로그램을 분리하여 소프트웨어를 신속하게 제공 할 수 있습니다. Docker를 사용하면 응용 프로그램을 관리하는 것과 동일한 방법으로 인프라를 관리 할 수 ​​있습니다. 코드를 신속하게 선적, 테스트 및 배포하는 Docker의 방법론을 활용하면 코드 작성과 프로덕션 환경에서의 실행 간의 지연을 크게 줄일 수 있습니다." />
<meta property="og:description" content="Docker는 응용 프로그램을 개발, 운송 및 실행하기위한 개방형 플랫폼입니다. Docker를 사용하면 인프라에서 응용 프로그램을 분리하여 소프트웨어를 신속하게 제공 할 수 있습니다. Docker를 사용하면 응용 프로그램을 관리하는 것과 동일한 방법으로 인프라를 관리 할 수 ​​있습니다. 코드를 신속하게 선적, 테스트 및 배포하는 Docker의 방법론을 활용하면 코드 작성과 프로덕션 환경에서의 실행 간의 지연을 크게 줄일 수 있습니다." />
<link rel="canonical" href="http://localhost:4000/blog/docs/develop/CaaS/docker/1_Guides/2_Get_started/3_Docker_overview.html" />
<meta property="og:url" content="http://localhost:4000/blog/docs/develop/CaaS/docker/1_Guides/2_Get_started/3_Docker_overview.html" />
<meta property="og:site_name" content="Portal2312&#39;s blog" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2019-11-06T09:31:12+09:00" />
<script type="application/ld+json">
{"description":"Docker는 응용 프로그램을 개발, 운송 및 실행하기위한 개방형 플랫폼입니다. Docker를 사용하면 인프라에서 응용 프로그램을 분리하여 소프트웨어를 신속하게 제공 할 수 있습니다. Docker를 사용하면 응용 프로그램을 관리하는 것과 동일한 방법으로 인프라를 관리 할 수 ​​있습니다. 코드를 신속하게 선적, 테스트 및 배포하는 Docker의 방법론을 활용하면 코드 작성과 프로덕션 환경에서의 실행 간의 지연을 크게 줄일 수 있습니다.","headline":"Docker overview","dateModified":"2019-11-06T09:31:12+09:00","datePublished":"2019-11-06T09:31:12+09:00","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/blog/docs/develop/CaaS/docker/1_Guides/2_Get_started/3_Docker_overview.html"},"url":"http://localhost:4000/blog/docs/develop/CaaS/docker/1_Guides/2_Get_started/3_Docker_overview.html","author":{"@type":"Person","name":"mkkim"},"@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href='/blog/assets/main.css'><link type="application/atom+xml" rel="alternate" href="http://localhost:4000/blog/feed.xml" title="Portal2312's blog" /><script src='/blog/dist/js/common.bundle.js'></script>
</head>
<body><header class="site-header" role="banner">
  <div class="wrapper">
    <a class="site-title" rel="author" href="/blog/">Portal2312&#39;s blog</a>
    <nav class="site-nav">
    <input type="checkbox" id="nav-trigger" class="nav-trigger" />
    <label for="nav-trigger">
      <span class="menu-icon">
        <svg viewBox="0 0 18 15" width="18px" height="15px">
          <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
        </svg>
      </span>
    </label>

    <div class="trigger"><a class="page-link" href="/blog/about.html">
            About
          </a><a class="page-link" href="/blog/posts.html">
            Posts
          </a><a class="page-link" href="/blog/history.html">
            History
          </a><a class="page-link" href="/blog/docs/index.html">
            Docs
          </a></div>
  </nav>
  </div>
  <div class="scroll-indicator-container">
  <div class="scroll-indicator-bar" id="scrollIndicatorBar"></div>
</div>

</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <h1>Docker overview</h1>

  <div>
    <h2>Table of contents</h2>
    <ul class="section-nav">
<li class="toc-entry toc-h2"><a href="#the-docker-platform">The Docker platform</a></li>
<li class="toc-entry toc-h2"><a href="#docker-engine">Docker Engine</a></li>
<li class="toc-entry toc-h2"><a href="#what-can-i-use-docker-for">What can I use Docker for?</a></li>
<li class="toc-entry toc-h2"><a href="#docker-architecture">Docker architecture</a>
<ul>
<li class="toc-entry toc-h3"><a href="#the-docker-daemon">The Docker daemon</a></li>
<li class="toc-entry toc-h3"><a href="#the-docker-client">The Docker client</a></li>
<li class="toc-entry toc-h3"><a href="#docker-registries">Docker registries</a></li>
<li class="toc-entry toc-h3"><a href="#docker-objects">Docker objects</a>
<ul>
<li class="toc-entry toc-h4"><a href="#images">IMAGES</a></li>
<li class="toc-entry toc-h4"><a href="#containers">CONTAINERS</a></li>
<li class="toc-entry toc-h4"><a href="#services">SERVICES</a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-entry toc-h2"><a href="#the-underlying-technology">The underlying technology</a>
<ul>
<li class="toc-entry toc-h3"><a href="#namespaces">Namespaces</a></li>
<li class="toc-entry toc-h3"><a href="#control-groups">Control groups</a></li>
<li class="toc-entry toc-h3"><a href="#union-file-systems">Union file systems</a></li>
<li class="toc-entry toc-h3"><a href="#container-format">Container format</a></li>
</ul>
</li>
<li class="toc-entry toc-h2"><a href="#reference">Reference</a></li>
</ul><p>Docker는 응용 프로그램을 개발, 운송 및 실행하기위한 개방형 플랫폼입니다.
Docker를 사용하면 인프라에서 응용 프로그램을 분리하여 소프트웨어를 신속하게 제공 할 수 있습니다.
Docker를 사용하면 응용 프로그램을 관리하는 것과 동일한 방법으로 인프라를 관리 할 수 ​​있습니다.
코드를 신속하게 선적, 테스트 및 배포하는 Docker의 방법론을 활용하면 코드 작성과 프로덕션 환경에서의 실행 간의 지연을 크게 줄일 수 있습니다.</p>

<h2 id="the-docker-platform">
<a class="anchor" href="#the-docker-platform" aria-hidden="true"><span class="octicon octicon-link"></span></a>The Docker platform</h2>

<p>Docker는 컨테이너라고하는 느슨한 환경에서 응용 프로그램을 패키지화하고 실행할 수있는 기능을 제공합니다.
격리 및 보안을 통해 주어진 호스트에서 여러 컨테이너를 동시에 실행할 수 있습니다.
컨테이너는 하이퍼 바이저의 추가로드가 필요 없기 때문에 경량이지만 호스트 시스템의 커널 내에서 직접 실행됩니다.
즉, 가상 시스템을 사용하는 경우보다 특정 하드웨어 조합에서 더 많은 컨테이너를 실행할 수 있습니다.
Docker 컨테이너는 실제로 가상 시스템 인 호스트 시스템 내에서 실행할 수도 있습니다!</p>

<p>Docker는 컨테이너의 수명주기를 관리하는 툴링 및 플랫폼을 제공합니다:</p>

<ul>
<li>컨테이너를 사용하여 애플리케이션 및 지원 구성 요소를 개발하십시오.</li>
<li>컨테이너는 응용 프로그램을 배포하고 테스트하는 단위가됩니다.</li>
<li>준비가되면 응용 프로그램을 컨테이너 또는 통합 서비스로 프로덕션 환경에 배포하십시오.
이는 프로덕션 환경이 로컬 데이터 센터, 클라우드 공급자 또는 이 둘의 하이브리드 여부에 관계없이 동일하게 작동합니다.</li>
</ul>

<h2 id="docker-engine">
<a class="anchor" href="#docker-engine" aria-hidden="true"><span class="octicon octicon-link"></span></a>Docker Engine</h2>

<p>Docker Engine은 다음과 같은 주요 구성 요소가있는 클라이언트 - 서버 응용 프로그램입니다.</p>

<ul>
<li>데몬 프로세스 (<code>dockerd</code> command)라고 하는 long-running 프로그램 유형의 서버입니다.</li>
<li>인터페이스를 지정하는 REST API 는 프로그램이 데몬과 대화하고 무엇을 해야 하는지 지시하는 데 사용할 수 있습니다.</li>
<li>command line interface (CLI) 클라이언트 (<code>docker</code> command).</li>
</ul>

<p><img src="/Documents/Develop/CaaS(Containers_as_a_Service)/Docker/img/engine-components-flow.png" alt="engine-components-flow"></p>

<p>CLI는 Docker REST API를 사용하여 스크립팅 또는 직접 CLI 명령을 통해 Docker 데몬을 제어하거나 상호 작용합니다.
다른 많은 Docker 응용 프로그램은 기본 API 및 CLI를 사용합니다.</p>

<p>데몬은 images, containers, networks, volumes 과 같은 Docker 객체를 만들고 관리합니다.</p>

<blockquote>
<p><strong>Note:</strong> Docker는 오픈 소스 Apache 2.0 라이센스에 따라 라이센스가 부여됩니다.</p>
</blockquote>

<p>자세한 내용은 아래 <a href="https://docs.docker.com/engine/docker-overview/#docker-architecture">Docker Achitecture</a> 를 참조하십시오.</p>

<h2 id="what-can-i-use-docker-for">
<a class="anchor" href="#what-can-i-use-docker-for" aria-hidden="true"><span class="octicon octicon-link"></span></a>What can I use Docker for?</h2>

<p><strong>Fast, consistent delivery of your applications</strong></p>

<p>애플리케이션의 빠르고 일관된 전달</p>

<p>Docker는 개발자가 응용 프로그램 및 서비스를 제공하는 로컬 컨테이너를 사용하여 표준화 된 환경에서 작업 할 수 있도록하여 개발 수명주기를 간소화합니다.
컨테이너는 지속적인 통합 및 지속적인 개발 (CI/CD) 워크 플로우에 유용합니다.</p>

<p>다음 예제 시나리오를 고려하십시오:</p>

<ul>
<li>개발자는 코드를 로컬에서 작성하고 Docker 컨테이너를 사용하여 동료와 작업을 공유합니다.</li>
<li>Docker를 사용하여 응용 프로그램을 테스트 환경에 적용하고 자동화 된 수동 테스트를 실행합니다.</li>
<li>개발자가 버그를 발견하면 개발 환경에서 버그를 수정하고 테스트 및 검증을 위해 테스트 환경에 재배포 할 수 있습니다.</li>
<li>테스트가 완료되면 업데이트 된 이미지를 프로덕션 환경으로 푸는 것만 큼 간단합니다.</li>
</ul>

<p><strong>Responsive deployment and scaling</strong></p>

<p>응답성 있는 배포 및 확장</p>

<p>Docker의 container 기반 플랫폼은 이동성이 뛰어난 워크로드를 허용합니다.
Docker container 는 개발자의 로컬 랩톱, 데이터 센터의 실제 또는 가상 컴퓨터, 클라우드 공급자 또는 여러 환경에서 실행할 수 있습니다.</p>

<p>Docker의 이식성과 가벼운 특성으로 인해 워크로드를 동적으로 관리하고 비즈니스 요구 사항에 따라 응용 프로그램과 서비스를 거의 실시간으로 축소 또는 축소 할 수 있습니다.</p>

<p><strong>Running more workloads on the same hardware</strong></p>

<p>동일 하드웨어에서 더 많은 workloads 실행</p>

<p>Docker는 가볍고 빠릅니다.
Hypervisor 기반 가상 시스템 대신 실용적이고 비용 효율적인 대안을 제공하므로 더 많은 컴퓨팅 용량을 사용하여 비즈니스 목표를 달성 할 수 있습니다.
Docker는 고밀도 환경과 적은 리소스로 더 많은 작업을 수행해야하는 중소 규모 배포 환경에 이상적입니다.</p>

<h2 id="docker-architecture">
<a class="anchor" href="#docker-architecture" aria-hidden="true"><span class="octicon octicon-link"></span></a>Docker architecture</h2>

<p>Docker는 client-server architecture를 사용합니다.
Docker <em>client</em> 는 Docker <em>daemon</em> 과 대화를 합니다.
Docker <em>daemon</em> 은 Docker container 를 빌드, 실행 및 배포하는 작업을 많이 수행합니다.
docker client 와 daemon 은 동일한 시스템에서 실행되거나 docker 를 원격 docker 데몬에 연결할 수 있습니다.
docker client 와 daemon 은 UNIX socket 또는 네트워크 인터페이스를 통해 REST API를 사용하여 통신합니다.</p>

<p><img src="/Documents/Develop/CaaS(Containers_as_a_Service)/Docker/img/architecture.svg" alt="architecture"></p>

<h3 id="the-docker-daemon">
<a class="anchor" href="#the-docker-daemon" aria-hidden="true"><span class="octicon octicon-link"></span></a>The Docker daemon</h3>

<p>Docker daemon (<code>dockerd</code>)은 Docker API 요청을 수신하고 이미지, 컨테이너, 네트워크 및 볼륨과 같은 Docker 개체를 관리합니다.
daemon 은 Docker 서비스를 관리하기 위해 다른 데몬과 통신할 수도 있습니다.</p>

<h3 id="the-docker-client">
<a class="anchor" href="#the-docker-client" aria-hidden="true"><span class="octicon octicon-link"></span></a>The Docker client</h3>

<p>Docker client (<code>docker</code>)는 많은 Docker 사용자가 Docker와 상호 작용하는 주요 방법입니다.
<code>docker run</code>과 같은 명령을 사용하면 client 는 이 명령을 dockerd로 전송하여 이를 수행합니다.
<code>docker</code> command 은 Docker API를 사용합니다.
Docker client 는 둘 이상의 데몬과 통신 할 수 있습니다.</p>

<h3 id="docker-registries">
<a class="anchor" href="#docker-registries" aria-hidden="true"><span class="octicon octicon-link"></span></a>Docker registries</h3>

<p>Docker <em>registry</em>는 Docker images를 저장합니다.
Docker Hub와 Docker Cloud는 누구나 사용할 수 있는 공용 레지스트리이며 Docker는 기본적으로 Docker Hub에서 이미지를 찾도록 구성되어 있습니다.
자신의 개인 레지스트리를 실행할 수도 있습니다.
Docker Datacenter(DDC)을 사용하는 경우 Docker Trusted Registry(DTR)이 포함됩니다.</p>

<p><code>docker pull</code> 또는 <code>docker run</code> 명령을 사용하면 구성된 레지스트리에서 필요한 이미지를 가져옵니다.
<code>docker push</code> 명령을 사용하면 image 가 구성된 레지스트리로 push 됩니다.</p>

<h3 id="docker-objects">
<a class="anchor" href="#docker-objects" aria-hidden="true"><span class="octicon octicon-link"></span></a>Docker objects</h3>

<p>Docker를 사용하면 images, containers, networks, volumns, plugins 및 기타 개체를 만들고 사용하고 있는 것입니다.
이 섹션에서는 이러한 개체 중 일부에 대해 간단히 설명합니다.</p>

<h4 id="images">
<a class="anchor" href="#images" aria-hidden="true"><span class="octicon octicon-link"></span></a>IMAGES</h4>

<p><em>image</em> 는 Docker container 를 생성하기 위한 지침이 포함된 읽기 전용 템플릿입니다.
종종 이미지는 다른 이미지를 <em>기반</em> 으로 하며 몇 가지 추가 사용자 정의가 있습니다.
예를 들어 <code>ubuntu</code> image 를 기반으로 이미지를 만들 수 있지만, 애플리케이션을 실행하는 데 필요한 구성 세부 사항은 물론 Apache 웹 서버와 애플리케이션을 설치합니다.</p>

<p>나만의 이미지를 만들거나 다른 사람들이 만들고 레지스트리에 게시한 이미지만 사용할 수 있습니다.
자신의 이미지를 만들려면 이미지를 만들고 실행하는 데 필요한 단계를 정의하기 위한 간단한 구문으로 <em>Dockerfile</em> 을 만듭니다.
Dockerfile 의 각 명령은 image 에 layer 를 만듭니다.
Dockerfile 을 변경하고 image 를 다시 작성하면 변경된 layer 만 재구성됩니다.
이는 다른 가상화 기술과 비교할 때 image 를 매우 가볍고 작고 빠르게 만드는 요소의 일부입니다.</p>

<h4 id="containers">
<a class="anchor" href="#containers" aria-hidden="true"><span class="octicon octicon-link"></span></a>CONTAINERS</h4>

<p>container 는 image 의 실행 가능한 인스턴스입니다.
Docker API 또는 CLI를 사용하여 컨테이너를 생성, 시작, 중지, 이동 또는 삭제할 수 있습니다.
Container 를 하나 이상의 네트워크에 연결하거나 여기에 저장소를 연결하거나 현재 상태를 기반으로 새 image 를 만들 수도 있습니다.</p>

<p>기본적으로 container 는 다른 container 와 host 시스템과 비교적 잘 격리되어 있습니다.
container 의 네트워크, 저장소 또는 다른 하위 시스템이 다른 container 나 host 시스템에서 분리된 상태를 제어할 수 있습니다.</p>

<p>container 는 이미지를 작성하거나 시작할 때 사용자가 제공하는 구성 옵션으로 정의됩니다.
container 를 제거하면 영구 저장소에 저장되지 않은 상태의 변경 사항이 사라집니다.</p>

<p><strong>Example <code>docker run</code> command</strong></p>

<p>다음 명령은 <code>ubuntu</code> container 를 실행하고 local command-line 세션에 대화식으로 연결하고 <code>/bin/bash</code> 를 실행합니다.</p>
<div class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nv">$ </span>docker run <span class="nt">-i</span> <span class="nt">-t</span> ubuntu /bin/bash
</code></pre></div>
<p>이 명령을 실행하면 다음이 수행됩니다 (기본 레지스트리 구성을 사용 중이라고 가정):</p>

<ol>
<li>
<code>ubuntu</code> image 가 로컬에 없으면 Docker 는 <code>docker pull ubuntu</code> 를 수동으로 실행 한 것처럼 구성된 레지스트리에서 해당 image 를 가져옵니다.</li>
<li>Docker 는 <code>docker create</code> 명령을 수동으로 실행한 것처럼 새 container 를 만듭니다.</li>
<li>Docker 는 read-write 파일 시스템을 최종 레이어로 컨테이너에 할당합니다.
이를 통해 실행중인 container 는 로컬 파일 시스템의 파일과 디렉토리를 작성하거나 수정할 수 있습니다.</li>
<li>Docker 는 네트워킹 옵션을 지정하지 않았기 때문에 container 를 기본 네트워크에 연결하는 네트워크 인터페이스를 만듭니다.
여기에는 container 에 IP 주소 할당이 포함됩니다.
기본적으로 container 는 호스트 시스템의 네트워크 연결을 사용하여 외부 네트워크에 연결할 수 있습니다.</li>
<li>Docker 는 container 를 시작하고 <code>/bin/bash</code> 를 실행합니다.
container 가 대화식으로 실행되고 (<code>-i</code> 및 <code>-t</code> 로 인해) 터미널에 연결되어 있기 때문에 키보드를 사용하여 입력을 제공하고 출력을 터미널에 기록할 수 있습니다.</li>
<li>
<code>exit</code> 를 입력하여 <code>/bin/bash</code> 명령을 종료하면 container 는 중지하지만 제거되지 않습니다.
다시 시작하거나 제거 할 수 있습니다.</li>
</ol>

<h4 id="services">
<a class="anchor" href="#services" aria-hidden="true"><span class="octicon octicon-link"></span></a>SERVICES</h4>

<p>Services 를 사용하면 여러 개의 Docker daemons 에서 containers 를 확장할 수 있습니다.
이 daemon 은 모두 여러 <em>mangers</em> 와 <em>workers</em> 가 있는 swarm 과 함께 작동합니다.
swarm 의 각 구성원은 Docker daemon 이며 Docker는 모두 Docker API를 사용하여 통신합니다.
service 를 사용하면 주어진 시간에 사용할 수 있어야 하는 서비스의 복제본 수와 같은 원하는 상태를 정의할 수 있습니다.
기본적으로 서비스는 모든 worker nodes 에서 load-balanced 조정됩니다.
소비자에게 Docker 서비스는 단일 애플리케이션으로 보입니다.
Docker Engine 은 Docker 1.12 이상에서 swarm-mode 를 지원합니다.</p>

<h2 id="the-underlying-technology">
<a class="anchor" href="#the-underlying-technology" aria-hidden="true"><span class="octicon octicon-link"></span></a>The underlying technology</h2>

<p>Docker는 <a href="https://golang.org/">Go</a>로 작성되었으며 Linux 커널의 여러 기능을 활용하여 기능을 제공합니다.</p>

<h3 id="namespaces">
<a class="anchor" href="#namespaces" aria-hidden="true"><span class="octicon octicon-link"></span></a>Namespaces</h3>

<p>Docker는 <code>namgespaces</code> 라는 기술을 사용하여 <em>container</em> 라는 격리된 작업 영역을 제공합니다.
container 를 실행할 때 Docker는 해당 container 에 대한 <em>namespaces</em> 집합을 만듭니다.</p>

<p>이러한 namespaces 는 격리 계층을 제공합니다.
container 의 각 측면은 별도의 namespaces 에서 실행되며 액세스는 해당 namespaces 로 제한됩니다.</p>

<p>Docker Engin 은 Linux 에 namespaces 처럼 사용한다:</p>

<ul>
<li>
<code>pid</code>: 프로세스 격리 (PID: Process ID).</li>
<li>
<code>net</code>: 네트워크 인터페이스 관리 (NET: Networking).</li>
<li>
<code>ipc</code>: IPC 리소스에 대한 액세스 관리 (IPC: 프로세스 간 통신).</li>
<li>
<code>mnt</code>: 파일 시스템 마운트 지점 관리 (MNT: Mount).</li>
<li>
<code>uts</code>: 커널 및 버전 식별자 분리. (UTS: Unix Timesharing System).</li>
</ul>

<h3 id="control-groups">
<a class="anchor" href="#control-groups" aria-hidden="true"><span class="octicon octicon-link"></span></a>Control groups</h3>

<p>Linux 의 Docker Engine은 제어 그룹 (<code>cgroup</code>)이라는 또 다른 기술을 사용합니다.
cgroup 은 응용 프로그램을 특정 자원 세트로 제한합니다.
Control groups 을 통해 Docker Engine은 사용 가능한 하드웨어 리소스를 container 에 공유하고 선택적으로 제한 및 제약 조건을 적용 할 수 있습니다.
예를 들어 특정 container 에서 사용 가능한 메모리를 제한할 수 있습니다.</p>

<h3 id="union-file-systems">
<a class="anchor" href="#union-file-systems" aria-hidden="true"><span class="octicon octicon-link"></span></a>Union file systems</h3>

<p>Union 파일 시스템 (UnionFS)은 레이어를 생성하여 작동하는 파일 시스템으로 매우 가볍고 빠릅니다.
Docker Engine은 UnionFS를 사용하여 container 에 대한 빌딩 블록을 제공합니다.
Docker Engine은 AUFS, btrfs, vfs 및 DeviceMapper를 비롯한 여러 UnionFS 변형을 사용할 수 있습니다.</p>

<h3 id="container-format">
<a class="anchor" href="#container-format" aria-hidden="true"><span class="octicon octicon-link"></span></a>Container format</h3>

<p>Docker Engine 은 네임 스페이스, 컨트롤 그룹 및 UnionFS를 컨테이너 형식이라는 래퍼에 결합합니다.
기본 컨테이너 형식은 <code>libcontainer</code> 입니다.
앞으로 Docker는 BSD Jails 또는 Solaris Zones와 같은 기술과 통합하여 다른 컨테이너 형식을 지원할 수 있습니다.</p>

<h2 id="reference">
<a class="anchor" href="#reference" aria-hidden="true"><span class="octicon octicon-link"></span></a>Reference</h2>

<p><a href="https://docs.docker.com/engine/docker-overview/">https://docs.docker.com/engine/docker-overview/</a></p>

  </div>

<div>
  <p>Docker는 응용 프로그램을 개발, 운송 및 실행하기위한 개방형 플랫폼입니다.
Docker를 사용하면 인프라에서 응용 프로그램을 분리하여 소프트웨어를 신속하게 제공 할 수 있습니다.
Docker를 사용하면 응용 프로그램을 관리하는 것과 동일한 방법으로 인프라를 관리 할 수 ​​있습니다.
코드를 신속하게 선적, 테스트 및 배포하는 Docker의 방법론을 활용하면 코드 작성과 프로덕션 환경에서의 실행 간의 지연을 크게 줄일 수 있습니다.</p>

<h2 id="the-docker-platform">The Docker platform</h2>

<p>Docker는 컨테이너라고하는 느슨한 환경에서 응용 프로그램을 패키지화하고 실행할 수있는 기능을 제공합니다.
격리 및 보안을 통해 주어진 호스트에서 여러 컨테이너를 동시에 실행할 수 있습니다.
컨테이너는 하이퍼 바이저의 추가로드가 필요 없기 때문에 경량이지만 호스트 시스템의 커널 내에서 직접 실행됩니다.
즉, 가상 시스템을 사용하는 경우보다 특정 하드웨어 조합에서 더 많은 컨테이너를 실행할 수 있습니다.
Docker 컨테이너는 실제로 가상 시스템 인 호스트 시스템 내에서 실행할 수도 있습니다!</p>

<p>Docker는 컨테이너의 수명주기를 관리하는 툴링 및 플랫폼을 제공합니다:</p>

<ul>
<li>컨테이너를 사용하여 애플리케이션 및 지원 구성 요소를 개발하십시오.</li>
<li>컨테이너는 응용 프로그램을 배포하고 테스트하는 단위가됩니다.</li>
<li>준비가되면 응용 프로그램을 컨테이너 또는 통합 서비스로 프로덕션 환경에 배포하십시오.
이는 프로덕션 환경이 로컬 데이터 센터, 클라우드 공급자 또는 이 둘의 하이브리드 여부에 관계없이 동일하게 작동합니다.</li>
</ul>

<h2 id="docker-engine">Docker Engine</h2>

<p>Docker Engine은 다음과 같은 주요 구성 요소가있는 클라이언트 - 서버 응용 프로그램입니다.</p>

<ul>
<li>데몬 프로세스 (<code>dockerd</code> command)라고 하는 long-running 프로그램 유형의 서버입니다.</li>
<li>인터페이스를 지정하는 REST API 는 프로그램이 데몬과 대화하고 무엇을 해야 하는지 지시하는 데 사용할 수 있습니다.</li>
<li>command line interface (CLI) 클라이언트 (<code>docker</code> command).</li>
</ul>

<p><img src="/Documents/Develop/CaaS(Containers_as_a_Service)/Docker/img/engine-components-flow.png" alt="engine-components-flow"></p>

<p>CLI는 Docker REST API를 사용하여 스크립팅 또는 직접 CLI 명령을 통해 Docker 데몬을 제어하거나 상호 작용합니다.
다른 많은 Docker 응용 프로그램은 기본 API 및 CLI를 사용합니다.</p>

<p>데몬은 images, containers, networks, volumes 과 같은 Docker 객체를 만들고 관리합니다.</p>

<blockquote>
<p><strong>Note:</strong> Docker는 오픈 소스 Apache 2.0 라이센스에 따라 라이센스가 부여됩니다.</p>
</blockquote>

<p>자세한 내용은 아래 <a href="https://docs.docker.com/engine/docker-overview/#docker-architecture" rel="nofollow" target="_blank">Docker Achitecture</a> 를 참조하십시오.</p>

<h2 id="what-can-i-use-docker-for">What can I use Docker for?</h2>

<p><strong>Fast, consistent delivery of your applications</strong></p>

<p>애플리케이션의 빠르고 일관된 전달</p>

<p>Docker는 개발자가 응용 프로그램 및 서비스를 제공하는 로컬 컨테이너를 사용하여 표준화 된 환경에서 작업 할 수 있도록하여 개발 수명주기를 간소화합니다.
컨테이너는 지속적인 통합 및 지속적인 개발 (CI/CD) 워크 플로우에 유용합니다.</p>

<p>다음 예제 시나리오를 고려하십시오:</p>

<ul>
<li>개발자는 코드를 로컬에서 작성하고 Docker 컨테이너를 사용하여 동료와 작업을 공유합니다.</li>
<li>Docker를 사용하여 응용 프로그램을 테스트 환경에 적용하고 자동화 된 수동 테스트를 실행합니다.</li>
<li>개발자가 버그를 발견하면 개발 환경에서 버그를 수정하고 테스트 및 검증을 위해 테스트 환경에 재배포 할 수 있습니다.</li>
<li>테스트가 완료되면 업데이트 된 이미지를 프로덕션 환경으로 푸는 것만 큼 간단합니다.</li>
</ul>

<p><strong>Responsive deployment and scaling</strong></p>

<p>응답성 있는 배포 및 확장</p>

<p>Docker의 container 기반 플랫폼은 이동성이 뛰어난 워크로드를 허용합니다.
Docker container 는 개발자의 로컬 랩톱, 데이터 센터의 실제 또는 가상 컴퓨터, 클라우드 공급자 또는 여러 환경에서 실행할 수 있습니다.</p>

<p>Docker의 이식성과 가벼운 특성으로 인해 워크로드를 동적으로 관리하고 비즈니스 요구 사항에 따라 응용 프로그램과 서비스를 거의 실시간으로 축소 또는 축소 할 수 있습니다.</p>

<p><strong>Running more workloads on the same hardware</strong></p>

<p>동일 하드웨어에서 더 많은 workloads 실행</p>

<p>Docker는 가볍고 빠릅니다.
Hypervisor 기반 가상 시스템 대신 실용적이고 비용 효율적인 대안을 제공하므로 더 많은 컴퓨팅 용량을 사용하여 비즈니스 목표를 달성 할 수 있습니다.
Docker는 고밀도 환경과 적은 리소스로 더 많은 작업을 수행해야하는 중소 규모 배포 환경에 이상적입니다.</p>

<h2 id="docker-architecture">Docker architecture</h2>

<p>Docker는 client-server architecture를 사용합니다.
Docker <em>client</em> 는 Docker <em>daemon</em> 과 대화를 합니다.
Docker <em>daemon</em> 은 Docker container 를 빌드, 실행 및 배포하는 작업을 많이 수행합니다.
docker client 와 daemon 은 동일한 시스템에서 실행되거나 docker 를 원격 docker 데몬에 연결할 수 있습니다.
docker client 와 daemon 은 UNIX socket 또는 네트워크 인터페이스를 통해 REST API를 사용하여 통신합니다.</p>

<p><img src="/Documents/Develop/CaaS(Containers_as_a_Service)/Docker/img/architecture.svg" alt="architecture"></p>

<h3 id="the-docker-daemon">The Docker daemon</h3>

<p>Docker daemon (<code>dockerd</code>)은 Docker API 요청을 수신하고 이미지, 컨테이너, 네트워크 및 볼륨과 같은 Docker 개체를 관리합니다.
daemon 은 Docker 서비스를 관리하기 위해 다른 데몬과 통신할 수도 있습니다.</p>

<h3 id="the-docker-client">The Docker client</h3>

<p>Docker client (<code>docker</code>)는 많은 Docker 사용자가 Docker와 상호 작용하는 주요 방법입니다.
<code>docker run</code>과 같은 명령을 사용하면 client 는 이 명령을 dockerd로 전송하여 이를 수행합니다.
<code>docker</code> command 은 Docker API를 사용합니다.
Docker client 는 둘 이상의 데몬과 통신 할 수 있습니다.</p>

<h3 id="docker-registries">Docker registries</h3>

<p>Docker <em>registry</em>는 Docker images를 저장합니다.
Docker Hub와 Docker Cloud는 누구나 사용할 수 있는 공용 레지스트리이며 Docker는 기본적으로 Docker Hub에서 이미지를 찾도록 구성되어 있습니다.
자신의 개인 레지스트리를 실행할 수도 있습니다.
Docker Datacenter(DDC)을 사용하는 경우 Docker Trusted Registry(DTR)이 포함됩니다.</p>

<p><code>docker pull</code> 또는 <code>docker run</code> 명령을 사용하면 구성된 레지스트리에서 필요한 이미지를 가져옵니다.
<code>docker push</code> 명령을 사용하면 image 가 구성된 레지스트리로 push 됩니다.</p>

<h3 id="docker-objects">Docker objects</h3>

<p>Docker를 사용하면 images, containers, networks, volumns, plugins 및 기타 개체를 만들고 사용하고 있는 것입니다.
이 섹션에서는 이러한 개체 중 일부에 대해 간단히 설명합니다.</p>

<h4 id="images">IMAGES</h4>

<p><em>image</em> 는 Docker container 를 생성하기 위한 지침이 포함된 읽기 전용 템플릿입니다.
종종 이미지는 다른 이미지를 <em>기반</em> 으로 하며 몇 가지 추가 사용자 정의가 있습니다.
예를 들어 <code>ubuntu</code> image 를 기반으로 이미지를 만들 수 있지만, 애플리케이션을 실행하는 데 필요한 구성 세부 사항은 물론 Apache 웹 서버와 애플리케이션을 설치합니다.</p>

<p>나만의 이미지를 만들거나 다른 사람들이 만들고 레지스트리에 게시한 이미지만 사용할 수 있습니다.
자신의 이미지를 만들려면 이미지를 만들고 실행하는 데 필요한 단계를 정의하기 위한 간단한 구문으로 <em>Dockerfile</em> 을 만듭니다.
Dockerfile 의 각 명령은 image 에 layer 를 만듭니다.
Dockerfile 을 변경하고 image 를 다시 작성하면 변경된 layer 만 재구성됩니다.
이는 다른 가상화 기술과 비교할 때 image 를 매우 가볍고 작고 빠르게 만드는 요소의 일부입니다.</p>

<h4 id="containers">CONTAINERS</h4>

<p>container 는 image 의 실행 가능한 인스턴스입니다.
Docker API 또는 CLI를 사용하여 컨테이너를 생성, 시작, 중지, 이동 또는 삭제할 수 있습니다.
Container 를 하나 이상의 네트워크에 연결하거나 여기에 저장소를 연결하거나 현재 상태를 기반으로 새 image 를 만들 수도 있습니다.</p>

<p>기본적으로 container 는 다른 container 와 host 시스템과 비교적 잘 격리되어 있습니다.
container 의 네트워크, 저장소 또는 다른 하위 시스템이 다른 container 나 host 시스템에서 분리된 상태를 제어할 수 있습니다.</p>

<p>container 는 이미지를 작성하거나 시작할 때 사용자가 제공하는 구성 옵션으로 정의됩니다.
container 를 제거하면 영구 저장소에 저장되지 않은 상태의 변경 사항이 사라집니다.</p>

<p><strong>Example <code>docker run</code> command</strong></p>

<p>다음 명령은 <code>ubuntu</code> container 를 실행하고 local command-line 세션에 대화식으로 연결하고 <code>/bin/bash</code> 를 실행합니다.</p>
<div class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nv">$ </span>docker run <span class="nt">-i</span> <span class="nt">-t</span> ubuntu /bin/bash
</code></pre></div>
<p>이 명령을 실행하면 다음이 수행됩니다 (기본 레지스트리 구성을 사용 중이라고 가정):</p>

<ol>
<li>
<code>ubuntu</code> image 가 로컬에 없으면 Docker 는 <code>docker pull ubuntu</code> 를 수동으로 실행 한 것처럼 구성된 레지스트리에서 해당 image 를 가져옵니다.</li>
<li>Docker 는 <code>docker create</code> 명령을 수동으로 실행한 것처럼 새 container 를 만듭니다.</li>
<li>Docker 는 read-write 파일 시스템을 최종 레이어로 컨테이너에 할당합니다.
이를 통해 실행중인 container 는 로컬 파일 시스템의 파일과 디렉토리를 작성하거나 수정할 수 있습니다.</li>
<li>Docker 는 네트워킹 옵션을 지정하지 않았기 때문에 container 를 기본 네트워크에 연결하는 네트워크 인터페이스를 만듭니다.
여기에는 container 에 IP 주소 할당이 포함됩니다.
기본적으로 container 는 호스트 시스템의 네트워크 연결을 사용하여 외부 네트워크에 연결할 수 있습니다.</li>
<li>Docker 는 container 를 시작하고 <code>/bin/bash</code> 를 실행합니다.
container 가 대화식으로 실행되고 (<code>-i</code> 및 <code>-t</code> 로 인해) 터미널에 연결되어 있기 때문에 키보드를 사용하여 입력을 제공하고 출력을 터미널에 기록할 수 있습니다.</li>
<li>
<code>exit</code> 를 입력하여 <code>/bin/bash</code> 명령을 종료하면 container 는 중지하지만 제거되지 않습니다.
다시 시작하거나 제거 할 수 있습니다.</li>
</ol>

<h4 id="services">SERVICES</h4>

<p>Services 를 사용하면 여러 개의 Docker daemons 에서 containers 를 확장할 수 있습니다.
이 daemon 은 모두 여러 <em>mangers</em> 와 <em>workers</em> 가 있는 swarm 과 함께 작동합니다.
swarm 의 각 구성원은 Docker daemon 이며 Docker는 모두 Docker API를 사용하여 통신합니다.
service 를 사용하면 주어진 시간에 사용할 수 있어야 하는 서비스의 복제본 수와 같은 원하는 상태를 정의할 수 있습니다.
기본적으로 서비스는 모든 worker nodes 에서 load-balanced 조정됩니다.
소비자에게 Docker 서비스는 단일 애플리케이션으로 보입니다.
Docker Engine 은 Docker 1.12 이상에서 swarm-mode 를 지원합니다.</p>

<h2 id="the-underlying-technology">The underlying technology</h2>

<p>Docker는 <a href="https://golang.org/" rel="nofollow" target="_blank">Go</a>로 작성되었으며 Linux 커널의 여러 기능을 활용하여 기능을 제공합니다.</p>

<h3 id="namespaces">Namespaces</h3>

<p>Docker는 <code>namgespaces</code> 라는 기술을 사용하여 <em>container</em> 라는 격리된 작업 영역을 제공합니다.
container 를 실행할 때 Docker는 해당 container 에 대한 <em>namespaces</em> 집합을 만듭니다.</p>

<p>이러한 namespaces 는 격리 계층을 제공합니다.
container 의 각 측면은 별도의 namespaces 에서 실행되며 액세스는 해당 namespaces 로 제한됩니다.</p>

<p>Docker Engin 은 Linux 에 namespaces 처럼 사용한다:</p>

<ul>
<li>
<code>pid</code>: 프로세스 격리 (PID: Process ID).</li>
<li>
<code>net</code>: 네트워크 인터페이스 관리 (NET: Networking).</li>
<li>
<code>ipc</code>: IPC 리소스에 대한 액세스 관리 (IPC: 프로세스 간 통신).</li>
<li>
<code>mnt</code>: 파일 시스템 마운트 지점 관리 (MNT: Mount).</li>
<li>
<code>uts</code>: 커널 및 버전 식별자 분리. (UTS: Unix Timesharing System).</li>
</ul>

<h3 id="control-groups">Control groups</h3>

<p>Linux 의 Docker Engine은 제어 그룹 (<code>cgroup</code>)이라는 또 다른 기술을 사용합니다.
cgroup 은 응용 프로그램을 특정 자원 세트로 제한합니다.
Control groups 을 통해 Docker Engine은 사용 가능한 하드웨어 리소스를 container 에 공유하고 선택적으로 제한 및 제약 조건을 적용 할 수 있습니다.
예를 들어 특정 container 에서 사용 가능한 메모리를 제한할 수 있습니다.</p>

<h3 id="union-file-systems">Union file systems</h3>

<p>Union 파일 시스템 (UnionFS)은 레이어를 생성하여 작동하는 파일 시스템으로 매우 가볍고 빠릅니다.
Docker Engine은 UnionFS를 사용하여 container 에 대한 빌딩 블록을 제공합니다.
Docker Engine은 AUFS, btrfs, vfs 및 DeviceMapper를 비롯한 여러 UnionFS 변형을 사용할 수 있습니다.</p>

<h3 id="container-format">Container format</h3>

<p>Docker Engine 은 네임 스페이스, 컨트롤 그룹 및 UnionFS를 컨테이너 형식이라는 래퍼에 결합합니다.
기본 컨테이너 형식은 <code>libcontainer</code> 입니다.
앞으로 Docker는 BSD Jails 또는 Solaris Zones와 같은 기술과 통합하여 다른 컨테이너 형식을 지원할 수 있습니다.</p>

<h2 id="reference">Reference</h2>

<p><a href="https://docs.docker.com/engine/docker-overview/" rel="nofollow" target="_blank">https://docs.docker.com/engine/docker-overview/</a></p>

</div>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/blog/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">Portal2312&#39;s blog</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">Portal2312&#39;s blog</li><li><a class="u-email" href="mailto:portal2312@gmail.com">portal2312@gmail.com</a></li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/portal2312"><svg class="svg-icon"><use xlink:href="/blog/assets/minima-social-icons.svg#github"></use></svg> <span class="username">portal2312</span></a></li><li><a href="https://www.twitter.com/portal2312"><svg class="svg-icon"><use xlink:href="/blog/assets/minima-social-icons.svg#twitter"></use></svg> <span class="username">portal2312</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>Welcome to my blog.</p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
