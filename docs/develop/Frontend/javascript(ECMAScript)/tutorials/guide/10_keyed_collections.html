<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.6.1 -->
<title>Keyed collections(키기반의 컬렉션) | Portal2312&#39;s blog</title>
<meta name="generator" content="Jekyll v3.8.6" />
<meta property="og:title" content="Keyed collections(키기반의 컬렉션)" />
<meta name="author" content="mkkim" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="이번 장에서는 입력된 키값을 기준으로 정렬되는 데이터의 집합(자료 구조)에 대해 소개 할 것이다. Map과 Set은 입력된 순서대로 반복적으로 접근 가능한 요소들을 포함하고 있다." />
<meta property="og:description" content="이번 장에서는 입력된 키값을 기준으로 정렬되는 데이터의 집합(자료 구조)에 대해 소개 할 것이다. Map과 Set은 입력된 순서대로 반복적으로 접근 가능한 요소들을 포함하고 있다." />
<link rel="canonical" href="http://localhost:4000/blog/docs/develop/Frontend/javascript(ECMAScript)/tutorials/guide/10_keyed_collections.html" />
<meta property="og:url" content="http://localhost:4000/blog/docs/develop/Frontend/javascript(ECMAScript)/tutorials/guide/10_keyed_collections.html" />
<meta property="og:site_name" content="Portal2312&#39;s blog" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2019-11-06T09:31:12+09:00" />
<script type="application/ld+json">
{"description":"이번 장에서는 입력된 키값을 기준으로 정렬되는 데이터의 집합(자료 구조)에 대해 소개 할 것이다. Map과 Set은 입력된 순서대로 반복적으로 접근 가능한 요소들을 포함하고 있다.","headline":"Keyed collections(키기반의 컬렉션)","dateModified":"2019-11-06T09:31:12+09:00","datePublished":"2019-11-06T09:31:12+09:00","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/blog/docs/develop/Frontend/javascript(ECMAScript)/tutorials/guide/10_keyed_collections.html"},"url":"http://localhost:4000/blog/docs/develop/Frontend/javascript(ECMAScript)/tutorials/guide/10_keyed_collections.html","author":{"@type":"Person","name":"mkkim"},"@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href='/blog/assets/main.css'><link type="application/atom+xml" rel="alternate" href="http://localhost:4000/blog/feed.xml" title="Portal2312's blog" /><script src='/blog/dist/js/common.bundle.js'></script>
</head>
<body><header class="site-header" role="banner">
  <div class="wrapper">
    <a class="site-title" rel="author" href="/blog/">Portal2312&#39;s blog</a>
    <nav class="site-nav">
    <input type="checkbox" id="nav-trigger" class="nav-trigger" />
    <label for="nav-trigger">
      <span class="menu-icon">
        <svg viewBox="0 0 18 15" width="18px" height="15px">
          <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
        </svg>
      </span>
    </label>

    <div class="trigger"><a class="page-link" href="/blog/about.html">
            About
          </a><a class="page-link" href="/blog/posts.html">
            Posts
          </a><a class="page-link" href="/blog/history.html">
            History
          </a><a class="page-link" href="/blog/docs/index.html">
            Docs
          </a></div>
  </nav>
  </div>
  <div class="scroll-indicator-container">
  <div class="scroll-indicator-bar" id="scrollIndicatorBar"></div>
</div>

</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <h1>Keyed collections(키기반의 컬렉션)</h1>

  <div>
    <h2>Table of contents</h2>
    <ul class="section-nav">
<li class="toc-entry toc-h2"><a href="#maps">Maps</a>
<ul>
<li class="toc-entry toc-h3"><a href="#map-object">Map Object</a></li>
<li class="toc-entry toc-h3"><a href="#object-map">Object와 Map 비교</a></li>
<li class="toc-entry toc-h3"><a href="#weakmap-object">WeakMap object</a></li>
</ul>
</li>
<li class="toc-entry toc-h2"><a href="#sets">Sets</a>
<ul>
<li class="toc-entry toc-h3"><a href="#set-object">set object</a></li>
<li class="toc-entry toc-h3"><a href="#set">배열과 Set의 상호 변환</a></li>
<li class="toc-entry toc-h3"><a href="#array-set">Array 와 Set 비교</a></li>
<li class="toc-entry toc-h3"><a href="#weakset">WeakSet 객체</a></li>
</ul>
</li>
<li class="toc-entry toc-h2"><a href="#map-set">Map과 Set의 키와 값의 동치성</a></li>
<li class="toc-entry toc-h2"><a href="#reference">Reference</a></li>
</ul><p>이번 장에서는 입력된 키값을 기준으로 정렬되는 데이터의 집합(자료 구조)에 대해 소개 할 것이다. Map과 Set은 입력된 순서대로 반복적으로 접근 가능한 요소들을 포함하고 있다.</p>

<hr>

<h2 id="maps">
<a class="anchor" href="#maps" aria-hidden="true"><span class="octicon octicon-link"></span></a>Maps</h2>

<h3 id="map-object">
<a class="anchor" href="#map-object" aria-hidden="true"><span class="octicon octicon-link"></span></a>Map Object</h3>

<p>자세한 내용은 <a href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Map">Map</a> 참조하기.</p>

<p>Map객체에 저장되어 있는 각 요소들을 [키, 값] 형태의 배열로 반복적으로 반환해주는 for...of 를 사용할 수 있다.</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="kd">var</span> <span class="nx">sayings</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Map</span><span class="p">();</span>
<span class="nx">sayings</span><span class="p">.</span><span class="kd">set</span><span class="p">(</span><span class="dl">"</span><span class="s2">dog</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">woof</span><span class="dl">"</span><span class="p">);</span>
<span class="nx">sayings</span><span class="p">.</span><span class="kd">set</span><span class="p">(</span><span class="dl">"</span><span class="s2">cat</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">meow</span><span class="dl">"</span><span class="p">);</span>
<span class="nx">sayings</span><span class="p">.</span><span class="kd">set</span><span class="p">(</span><span class="dl">"</span><span class="s2">elephant</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">toot</span><span class="dl">"</span><span class="p">);</span>
<span class="nx">sayings</span><span class="p">.</span><span class="nx">size</span><span class="p">;</span> <span class="c1">// 3</span>
<span class="nx">sayings</span><span class="p">.</span><span class="kd">get</span><span class="p">(</span><span class="dl">"</span><span class="s2">fox</span><span class="dl">"</span><span class="p">);</span> <span class="c1">// undefined</span>
<span class="nx">sayings</span><span class="p">.</span><span class="nx">has</span><span class="p">(</span><span class="dl">"</span><span class="s2">bird</span><span class="dl">"</span><span class="p">);</span> <span class="c1">// false</span>
<span class="nx">sayings</span><span class="p">.</span><span class="k">delete</span><span class="p">(</span><span class="dl">"</span><span class="s2">dog</span><span class="dl">"</span><span class="p">);</span>

<span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="p">[</span><span class="nx">key</span><span class="p">,</span> <span class="nx">value</span><span class="p">]</span> <span class="k">of</span> <span class="nx">sayings</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">key</span> <span class="o">+</span> <span class="dl">"</span><span class="s2"> goes </span><span class="dl">"</span> <span class="o">+</span> <span class="nx">value</span><span class="p">);</span>
<span class="p">}</span>
<span class="c1">// "cat goes meow"</span>
<span class="c1">// "elephant goes toot"</span>
</code></pre></div>
<h3 id="object-map">
<a class="anchor" href="#object-map" aria-hidden="true"><span class="octicon octicon-link"></span></a>Object와 Map 비교</h3>

<p>전통적으로 objects 는 문자열을 값에 매핑하는 데 사용되었다.
Object는 키를 값으로 설정하고, 값을 검색하고, 키를 삭제하고,
키에 저장된 내용을 검색 할 수 있게 만들어준다.
그러나 Map 객체는 더 나은 맵이 되도록 하는 몇 가지 장점을 가지고 있다.</p>

<ul>
<li>Object의 키는 Strings이며, Map의 모든 값을 가질 수 있다.</li>
<li>Object는 크기를 수동으로 추적해야하지만, Map은 크기를 쉽게 얻을 수 있다.
Map은 삽입된 순서대로 반복된다.</li>
<li>객체(Object)에는 prototype이 있어 Map에 기본 키들이 있다. (이것은 map = Object.create(null) 를 사용하여 우회할 수 있다. )</li>
</ul>

<p>Object 혹은 Map중에 어느 것을 사용할지를 결정하는데 도움을 줄 두가지 팁이 있다:</p>

<ul>
<li>실행 시까지 key를 알 수 없고, 모든 키가 동일한 type이며 모든 값들이 동일한 type일 경우에는 objects를 대신해서 map을 사용해라.</li>
<li>각 개별 요소에 대해 적용해야 하는 로직이 있을 경우에는 objects를 사용해라.</li>
</ul>

<h3 id="weakmap-object">
<a class="anchor" href="#weakmap-object" aria-hidden="true"><span class="octicon octicon-link"></span></a><code>WeakMap</code> object</h3>

<p><code>WeakMap</code> 객체는 object만을 key로 허용하고 값은 임의의 값을 허용하는 키/값 형태의 요소의 집합이다.</p>

<p>key가 가지고 있는 객체에 대한 참조는 객체에 대한 참조가 더이상 존재하지 않을 경우 garbage collection(GC)의 수거 대상이 되는 약한 참조를 의미한다.</p>

<p>WeakMap API는 Map API와 동일하다.</p>

<p>WeakMap에 대한 더 많은 정보와 예제 코드 그리고 "왜 WeakMap을 사용하지?"를 보고 싶다면 <a href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/WeakMap">WeakMap</a> 페이지를 참고하면 된다.</p>

<p><code>WeakMap를 사용하는 한가지 경우는 객체의 사적인 정보를 저장하기 위해서 이거나 상세 구현 내용을 숨기기 위한 것이다.</code></p>

<p>다음의 예제는 Nick Fitzgerald의 블로그 글- "Hiding Implementation Details with ECMAScript 6 WeakMaps"-에서 가져온 것이다. 객체가 가지고 있는 그렇지만 외부에 공개되지 않는(private) 데이터와 메서드들은 WeakMap객체인 privates에 저장이 된다. 인스턴스를 통해 접근 가능한 모든 것들과 prototype은 public이고 다른 것들은 외부에서는 접근이 불가하다 그 이유는 privates는 모듈로부터 내보내기(export)가 되지 않기 때문이다.</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="kd">const</span> <span class="nx">privates</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">WeakMap</span><span class="p">();</span>

<span class="kd">function</span> <span class="nx">Public</span><span class="p">()</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">me</span> <span class="o">=</span> <span class="p">{</span>
    <span class="c1">// Private data goes here</span>
  <span class="p">};</span>
  <span class="nx">privates</span><span class="p">.</span><span class="kd">set</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="nx">me</span><span class="p">);</span>
<span class="p">}</span>

<span class="nx">Public</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">method</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">me</span> <span class="o">=</span> <span class="nx">privates</span><span class="p">.</span><span class="kd">get</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
  <span class="c1">// Do stuff with private data in `me`...</span>
<span class="p">};</span>

<span class="nx">module</span><span class="p">.</span><span class="nx">exports</span> <span class="o">=</span> <span class="nx">Public</span><span class="p">;</span>
</code></pre></div>
<hr>

<h2 id="sets">
<a class="anchor" href="#sets" aria-hidden="true"><span class="octicon octicon-link"></span></a>Sets</h2>

<h3 id="set-object">
<a class="anchor" href="#set-object" aria-hidden="true"><span class="octicon octicon-link"></span></a><code>set</code> object</h3>

<p>Set객체는 값들의 집합이다. 입력된 순서에따라 저장된 요소를 반복처리할 수 있다. Set은 중복된 값을 허용하지 않는다. 따라서 특정 값은 Set내에서 하나만 존재 하게 된다.</p>

<p>아래의 코드는 Set의 기본적인 동작들을 보여 준다. 더 많은 예제와 모든 API는 <code>Set</code> 참조 페이지를 보면 된다.</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="kd">var</span> <span class="nx">mySet</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Set</span><span class="p">();</span>
<span class="nx">mySet</span><span class="p">.</span><span class="nx">add</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="nx">mySet</span><span class="p">.</span><span class="nx">add</span><span class="p">(</span><span class="dl">"</span><span class="s2">some text</span><span class="dl">"</span><span class="p">);</span>
<span class="nx">mySet</span><span class="p">.</span><span class="nx">add</span><span class="p">(</span><span class="dl">"</span><span class="s2">foo</span><span class="dl">"</span><span class="p">);</span>

<span class="nx">mySet</span><span class="p">.</span><span class="nx">has</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span> <span class="c1">// true</span>
<span class="nx">mySet</span><span class="p">.</span><span class="k">delete</span><span class="p">(</span><span class="dl">"</span><span class="s2">foo</span><span class="dl">"</span><span class="p">);</span>
<span class="nx">mySet</span><span class="p">.</span><span class="nx">size</span><span class="p">;</span> <span class="c1">// 2</span>

<span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">item</span> <span class="k">of</span> <span class="nx">mySet</span><span class="p">)</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">item</span><span class="p">);</span>
<span class="c1">// 1</span>
<span class="c1">// "some text"</span>
</code></pre></div>
<h3 id="set">
<a class="anchor" href="#set" aria-hidden="true"><span class="octicon octicon-link"></span></a>배열과 Set의 상호 변환</h3>

<p>Array.from 혹은 spread operator를 통해 Set객체를 가지고 Array을 생성할 수 있다. 또한 Set 생성자는 배열을 인자로 받을 수 있고 해당 배열을 Set객체의 요소로 저장한다. 한번 더 상기시키면 Set객체는 중복된 값을 저장하지 않기때문에 주어진 배열내의 중복된 요소들을 제거되어 Set으로 변환된다.</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="nb">Array</span><span class="p">.</span><span class="k">from</span><span class="p">(</span><span class="nx">mySet</span><span class="p">);</span>
<span class="p">[...</span><span class="nx">mySet2</span><span class="p">];</span>

<span class="nx">mySet2</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Set</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]);</span>
</code></pre></div>
<h3 id="array-set">
<a class="anchor" href="#array-set" aria-hidden="true"><span class="octicon octicon-link"></span></a>Array 와 Set 비교</h3>

<p>일반적으로 Javascript에선 Array에 특정 요소의 집합을 저장한다. 하지만 Set객체는 몇가지 이점을 제공한다.</p>

<ul>
<li>
<code>indexOf</code> 메서드를 사용하여 배열내에 특정 요소가 존재하는지 확인하는 것은 느리다.</li>
<li>배열에선 해당 요소를 배열에서 잘라내야 하는 반면 Set객체는 요소의 값으로 해당 요소를 삭제하는 기능 제공한다.</li>
<li>NaN은 배열에서 indexOf메서드로 찾을 수 없다.</li>
<li>Set객체는 값의 유일성을 보장하기 때문에 직접 요소의 중복성을 확인할 필요가 없다.</li>
</ul>

<h3 id="weakset">
<a class="anchor" href="#weakset" aria-hidden="true"><span class="octicon octicon-link"></span></a>WeakSet 객체</h3>

<p>WeakSet객체는 객체를 저장하는 일종의 집합이다.</p>

<p>WeakSet내의 중복된 객체는 없으며 WeakSet내의 요소를 열거할 수는 없다.</p>

<p>Set과 가장 큰 차이점은 다음과 같다.</p>

<ul>
<li><p>Set과는 다르게 WeakSet은 객체의 집합이며 객체만 저장할 수 있다. 특정 type의 값을 저장할 수는 없다.</p></li>
<li><p>WeakSet은 약한 참조를 가진다.
WeakSet내의 객체에 대한 참조는 약하게 연결이 되어 있다.
WeakSet내에 저장되어 있는 객체에 대한 참조가 없게되면 garbage collection 대상이되어 수거 된다.
따라서 현재 저장되어 있는 객체에 대한 목록은 없으며 WeakSet은 열거형이 아니다.</p></li>
</ul>

<p>WeakSet객체의 사용 사례는 제한되어 있다.</p>

<p>메모리 누수가 발생되지 않기때문에 안전하게 DOM요소를 키로 저장할 수 있고 예를 들면 추적을 위해 DOM요소들을 WeakSet에 저장할 수 있다.</p>

<hr>

<h2 id="map-set">
<a class="anchor" href="#map-set" aria-hidden="true"><span class="octicon octicon-link"></span></a>Map과 Set의 키와 값의 동치성</h2>

<p>Map객체의 key에 대한 동치성 비교와 Set객체의 값에 대한 동치성 비교 모두 "same-value-zero algorithm"에 근거한다.</p>

<ul>
<li>동치성 비교는 === 비교 연산과 같이 작동한다.</li>
<li>-0과 +0은 같다고 간주한다.</li>
<li>NaN는 자기 자신하고 같다고 간주한다. (===와는 반대로)</li>
</ul>

<hr>

<h2 id="reference">
<a class="anchor" href="#reference" aria-hidden="true"><span class="octicon octicon-link"></span></a>Reference</h2>

<p><a href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Guide/Keyed_collections">https://developer.mozilla.org/ko/docs/Web/JavaScript/Guide/Keyed_collections</a></p>

  </div>

<div>
  <p>이번 장에서는 입력된 키값을 기준으로 정렬되는 데이터의 집합(자료 구조)에 대해 소개 할 것이다. Map과 Set은 입력된 순서대로 반복적으로 접근 가능한 요소들을 포함하고 있다.</p>

<hr>

<h2 id="maps">Maps</h2>

<h3 id="map-object">Map Object</h3>

<p>자세한 내용은 <a href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Map" rel="nofollow" target="_blank">Map</a> 참조하기.</p>

<p>Map객체에 저장되어 있는 각 요소들을 [키, 값] 형태의 배열로 반복적으로 반환해주는 for...of 를 사용할 수 있다.</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="kd">var</span> <span class="nx">sayings</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Map</span><span class="p">();</span>
<span class="nx">sayings</span><span class="p">.</span><span class="kd">set</span><span class="p">(</span><span class="dl">"</span><span class="s2">dog</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">woof</span><span class="dl">"</span><span class="p">);</span>
<span class="nx">sayings</span><span class="p">.</span><span class="kd">set</span><span class="p">(</span><span class="dl">"</span><span class="s2">cat</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">meow</span><span class="dl">"</span><span class="p">);</span>
<span class="nx">sayings</span><span class="p">.</span><span class="kd">set</span><span class="p">(</span><span class="dl">"</span><span class="s2">elephant</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">toot</span><span class="dl">"</span><span class="p">);</span>
<span class="nx">sayings</span><span class="p">.</span><span class="nx">size</span><span class="p">;</span> <span class="c1">// 3</span>
<span class="nx">sayings</span><span class="p">.</span><span class="kd">get</span><span class="p">(</span><span class="dl">"</span><span class="s2">fox</span><span class="dl">"</span><span class="p">);</span> <span class="c1">// undefined</span>
<span class="nx">sayings</span><span class="p">.</span><span class="nx">has</span><span class="p">(</span><span class="dl">"</span><span class="s2">bird</span><span class="dl">"</span><span class="p">);</span> <span class="c1">// false</span>
<span class="nx">sayings</span><span class="p">.</span><span class="k">delete</span><span class="p">(</span><span class="dl">"</span><span class="s2">dog</span><span class="dl">"</span><span class="p">);</span>

<span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="p">[</span><span class="nx">key</span><span class="p">,</span> <span class="nx">value</span><span class="p">]</span> <span class="k">of</span> <span class="nx">sayings</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">key</span> <span class="o">+</span> <span class="dl">"</span><span class="s2"> goes </span><span class="dl">"</span> <span class="o">+</span> <span class="nx">value</span><span class="p">);</span>
<span class="p">}</span>
<span class="c1">// "cat goes meow"</span>
<span class="c1">// "elephant goes toot"</span>
</code></pre></div>
<h3 id="object-map">Object와 Map 비교</h3>

<p>전통적으로 objects 는 문자열을 값에 매핑하는 데 사용되었다.
Object는 키를 값으로 설정하고, 값을 검색하고, 키를 삭제하고,
키에 저장된 내용을 검색 할 수 있게 만들어준다.
그러나 Map 객체는 더 나은 맵이 되도록 하는 몇 가지 장점을 가지고 있다.</p>

<ul>
<li>Object의 키는 Strings이며, Map의 모든 값을 가질 수 있다.</li>
<li>Object는 크기를 수동으로 추적해야하지만, Map은 크기를 쉽게 얻을 수 있다.
Map은 삽입된 순서대로 반복된다.</li>
<li>객체(Object)에는 prototype이 있어 Map에 기본 키들이 있다. (이것은 map = Object.create(null) 를 사용하여 우회할 수 있다. )</li>
</ul>

<p>Object 혹은 Map중에 어느 것을 사용할지를 결정하는데 도움을 줄 두가지 팁이 있다:</p>

<ul>
<li>실행 시까지 key를 알 수 없고, 모든 키가 동일한 type이며 모든 값들이 동일한 type일 경우에는 objects를 대신해서 map을 사용해라.</li>
<li>각 개별 요소에 대해 적용해야 하는 로직이 있을 경우에는 objects를 사용해라.</li>
</ul>

<h3 id="weakmap-object">
<code>WeakMap</code> object</h3>

<p><code>WeakMap</code> 객체는 object만을 key로 허용하고 값은 임의의 값을 허용하는 키/값 형태의 요소의 집합이다.</p>

<p>key가 가지고 있는 객체에 대한 참조는 객체에 대한 참조가 더이상 존재하지 않을 경우 garbage collection(GC)의 수거 대상이 되는 약한 참조를 의미한다.</p>

<p>WeakMap API는 Map API와 동일하다.</p>

<p>WeakMap에 대한 더 많은 정보와 예제 코드 그리고 "왜 WeakMap을 사용하지?"를 보고 싶다면 <a href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/WeakMap" rel="nofollow" target="_blank">WeakMap</a> 페이지를 참고하면 된다.</p>

<p><code>WeakMap를 사용하는 한가지 경우는 객체의 사적인 정보를 저장하기 위해서 이거나 상세 구현 내용을 숨기기 위한 것이다.</code></p>

<p>다음의 예제는 Nick Fitzgerald의 블로그 글- "Hiding Implementation Details with ECMAScript 6 WeakMaps"-에서 가져온 것이다. 객체가 가지고 있는 그렇지만 외부에 공개되지 않는(private) 데이터와 메서드들은 WeakMap객체인 privates에 저장이 된다. 인스턴스를 통해 접근 가능한 모든 것들과 prototype은 public이고 다른 것들은 외부에서는 접근이 불가하다 그 이유는 privates는 모듈로부터 내보내기(export)가 되지 않기 때문이다.</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="kd">const</span> <span class="nx">privates</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">WeakMap</span><span class="p">();</span>

<span class="kd">function</span> <span class="nx">Public</span><span class="p">()</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">me</span> <span class="o">=</span> <span class="p">{</span>
    <span class="c1">// Private data goes here</span>
  <span class="p">};</span>
  <span class="nx">privates</span><span class="p">.</span><span class="kd">set</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="nx">me</span><span class="p">);</span>
<span class="p">}</span>

<span class="nx">Public</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">method</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">me</span> <span class="o">=</span> <span class="nx">privates</span><span class="p">.</span><span class="kd">get</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
  <span class="c1">// Do stuff with private data in `me`...</span>
<span class="p">};</span>

<span class="nx">module</span><span class="p">.</span><span class="nx">exports</span> <span class="o">=</span> <span class="nx">Public</span><span class="p">;</span>
</code></pre></div>
<hr>

<h2 id="sets">Sets</h2>

<h3 id="set-object">
<code>set</code> object</h3>

<p>Set객체는 값들의 집합이다. 입력된 순서에따라 저장된 요소를 반복처리할 수 있다. Set은 중복된 값을 허용하지 않는다. 따라서 특정 값은 Set내에서 하나만 존재 하게 된다.</p>

<p>아래의 코드는 Set의 기본적인 동작들을 보여 준다. 더 많은 예제와 모든 API는 <code>Set</code> 참조 페이지를 보면 된다.</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="kd">var</span> <span class="nx">mySet</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Set</span><span class="p">();</span>
<span class="nx">mySet</span><span class="p">.</span><span class="nx">add</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="nx">mySet</span><span class="p">.</span><span class="nx">add</span><span class="p">(</span><span class="dl">"</span><span class="s2">some text</span><span class="dl">"</span><span class="p">);</span>
<span class="nx">mySet</span><span class="p">.</span><span class="nx">add</span><span class="p">(</span><span class="dl">"</span><span class="s2">foo</span><span class="dl">"</span><span class="p">);</span>

<span class="nx">mySet</span><span class="p">.</span><span class="nx">has</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span> <span class="c1">// true</span>
<span class="nx">mySet</span><span class="p">.</span><span class="k">delete</span><span class="p">(</span><span class="dl">"</span><span class="s2">foo</span><span class="dl">"</span><span class="p">);</span>
<span class="nx">mySet</span><span class="p">.</span><span class="nx">size</span><span class="p">;</span> <span class="c1">// 2</span>

<span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">item</span> <span class="k">of</span> <span class="nx">mySet</span><span class="p">)</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">item</span><span class="p">);</span>
<span class="c1">// 1</span>
<span class="c1">// "some text"</span>
</code></pre></div>
<h3 id="set">배열과 Set의 상호 변환</h3>

<p>Array.from 혹은 spread operator를 통해 Set객체를 가지고 Array을 생성할 수 있다. 또한 Set 생성자는 배열을 인자로 받을 수 있고 해당 배열을 Set객체의 요소로 저장한다. 한번 더 상기시키면 Set객체는 중복된 값을 저장하지 않기때문에 주어진 배열내의 중복된 요소들을 제거되어 Set으로 변환된다.</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="nb">Array</span><span class="p">.</span><span class="k">from</span><span class="p">(</span><span class="nx">mySet</span><span class="p">);</span>
<span class="p">[...</span><span class="nx">mySet2</span><span class="p">];</span>

<span class="nx">mySet2</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Set</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]);</span>
</code></pre></div>
<h3 id="array-set">Array 와 Set 비교</h3>

<p>일반적으로 Javascript에선 Array에 특정 요소의 집합을 저장한다. 하지만 Set객체는 몇가지 이점을 제공한다.</p>

<ul>
<li>
<code>indexOf</code> 메서드를 사용하여 배열내에 특정 요소가 존재하는지 확인하는 것은 느리다.</li>
<li>배열에선 해당 요소를 배열에서 잘라내야 하는 반면 Set객체는 요소의 값으로 해당 요소를 삭제하는 기능 제공한다.</li>
<li>NaN은 배열에서 indexOf메서드로 찾을 수 없다.</li>
<li>Set객체는 값의 유일성을 보장하기 때문에 직접 요소의 중복성을 확인할 필요가 없다.</li>
</ul>

<h3 id="weakset">WeakSet 객체</h3>

<p>WeakSet객체는 객체를 저장하는 일종의 집합이다.</p>

<p>WeakSet내의 중복된 객체는 없으며 WeakSet내의 요소를 열거할 수는 없다.</p>

<p>Set과 가장 큰 차이점은 다음과 같다.</p>

<ul>
<li><p>Set과는 다르게 WeakSet은 객체의 집합이며 객체만 저장할 수 있다. 특정 type의 값을 저장할 수는 없다.</p></li>
<li><p>WeakSet은 약한 참조를 가진다.
WeakSet내의 객체에 대한 참조는 약하게 연결이 되어 있다.
WeakSet내에 저장되어 있는 객체에 대한 참조가 없게되면 garbage collection 대상이되어 수거 된다.
따라서 현재 저장되어 있는 객체에 대한 목록은 없으며 WeakSet은 열거형이 아니다.</p></li>
</ul>

<p>WeakSet객체의 사용 사례는 제한되어 있다.</p>

<p>메모리 누수가 발생되지 않기때문에 안전하게 DOM요소를 키로 저장할 수 있고 예를 들면 추적을 위해 DOM요소들을 WeakSet에 저장할 수 있다.</p>

<hr>

<h2 id="map-set">Map과 Set의 키와 값의 동치성</h2>

<p>Map객체의 key에 대한 동치성 비교와 Set객체의 값에 대한 동치성 비교 모두 "same-value-zero algorithm"에 근거한다.</p>

<ul>
<li>동치성 비교는 === 비교 연산과 같이 작동한다.</li>
<li>-0과 +0은 같다고 간주한다.</li>
<li>NaN는 자기 자신하고 같다고 간주한다. (===와는 반대로)</li>
</ul>

<hr>

<h2 id="reference">Reference</h2>

<p><a href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Guide/Keyed_collections" rel="nofollow" target="_blank">https://developer.mozilla.org/ko/docs/Web/JavaScript/Guide/Keyed_collections</a></p>

</div>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/blog/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">Portal2312&#39;s blog</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">Portal2312&#39;s blog</li><li><a class="u-email" href="mailto:portal2312@gmail.com">portal2312@gmail.com</a></li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/portal2312"><svg class="svg-icon"><use xlink:href="/blog/assets/minima-social-icons.svg#github"></use></svg> <span class="username">portal2312</span></a></li><li><a href="https://www.twitter.com/portal2312"><svg class="svg-icon"><use xlink:href="/blog/assets/minima-social-icons.svg#twitter"></use></svg> <span class="username">portal2312</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>Welcome to my blog.</p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
