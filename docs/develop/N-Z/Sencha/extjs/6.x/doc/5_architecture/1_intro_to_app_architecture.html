<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.6.1 -->
<title>Introduction to Application Architecture | Portal2312&#39;s blog</title>
<meta name="generator" content="Jekyll v3.8.6" />
<meta property="og:title" content="Introduction to Application Architecture" />
<meta name="author" content="mkkim" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="MVC MVVM 둘다 지원" />
<meta property="og:description" content="MVC MVVM 둘다 지원" />
<link rel="canonical" href="/blog/docs/develop/N-Z/Sencha/extjs/6.x/doc/5_architecture/1_intro_to_app_architecture.html" />
<meta property="og:url" content="/blog/docs/develop/N-Z/Sencha/extjs/6.x/doc/5_architecture/1_intro_to_app_architecture.html" />
<meta property="og:site_name" content="Portal2312&#39;s blog" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2019-12-02T16:38:51+09:00" />
<script type="application/ld+json">
{"description":"MVC MVVM 둘다 지원","headline":"Introduction to Application Architecture","dateModified":"2019-12-02T16:38:51+09:00","datePublished":"2019-12-02T16:38:51+09:00","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"/blog/docs/develop/N-Z/Sencha/extjs/6.x/doc/5_architecture/1_intro_to_app_architecture.html"},"url":"/blog/docs/develop/N-Z/Sencha/extjs/6.x/doc/5_architecture/1_intro_to_app_architecture.html","author":{"@type":"Person","name":"mkkim"},"@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href='/blog/assets/main.css'><link type="application/atom+xml" rel="alternate" href="/blog/feed.xml" title="Portal2312's blog" /><script>
if(!(window.doNotTrack === "1" || navigator.doNotTrack === "1" || navigator.doNotTrack === "yes" || navigator.msDoNotTrack === "1")) {
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-113063601-1', 'auto');
  ga('send', 'pageview');
}
</script>
  
<script src='/blog/dist/js/common.bundle.js'></script>
</head>
<body><header class="site-header" role="banner">
  <div class="wrapper">
    <a class="site-title" rel="author" href="/blog/">Portal2312&#39;s blog</a>
    <nav class="site-nav">
    <input type="checkbox" id="nav-trigger" class="nav-trigger" />
    <label for="nav-trigger">
      <span class="menu-icon">
        <svg viewBox="0 0 18 15" width="18px" height="15px">
          <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
        </svg>
      </span>
    </label>

    <div class="trigger"><a class="page-link" href="/blog/about.html">
            About
          </a><a class="page-link" href="/blog/posts.html">
            Posts
          </a><a class="page-link" href="/blog/history.html">
            History
          </a><a class="page-link" href="/blog/docs/index.html">
            Docs
          </a></div>
  </nav>
  </div>
  <div class="scroll-indicator-container">
  <div class="scroll-indicator-bar" id="scrollIndicatorBar"></div>
</div>

</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <h1>Introduction to Application Architecture</h1>

  <div>
    <h2>Table of contents</h2>
    <ul class="section-nav">
<li class="toc-entry toc-h2"><a href="#what-is-mvc">What is MVC?</a></li>
<li class="toc-entry toc-h2"><a href="#what-is-mvvm">What is MVVM?</a></li>
<li class="toc-entry toc-h2"><a href="#returning-users">Returning Users</a></li>
<li class="toc-entry toc-h2"><a href="#mvc-and-mvvm">MVC and MVVM</a></li>
<li class="toc-entry toc-h2"><a href="#building-a-sample-app">Building a Sample App</a></li>
<li class="toc-entry toc-h2"><a href="#application-overview">Application Overview</a>
<ul>
<li class="toc-entry toc-h3"><a href="#file-structure">File Structure</a></li>
<li class="toc-entry toc-h3"><a href="#namespace">Namespace</a></li>
</ul>
</li>
<li class="toc-entry toc-h2"><a href="#application">Application</a>
<ul>
<li class="toc-entry toc-h3"><a href="#app-js">app.js</a></li>
<li class="toc-entry toc-h3"><a href="#application-js">Application.js</a></li>
</ul>
</li>
<li class="toc-entry toc-h2"><a href="#views">Views</a>
<ul>
<li class="toc-entry toc-h3"><a href="#controller-config">Controller Config</a></li>
<li class="toc-entry toc-h3"><a href="#viewmodel-config">ViewModel Config</a></li>
</ul>
</li>
<li class="toc-entry toc-h2"><a href="#controllers">Controllers</a></li>
<li class="toc-entry toc-h2"><a href="#viewmodels">ViewModels</a></li>
<li class="toc-entry toc-h2"><a href="#models-and-stores">Models and Stores</a>
<ul>
<li class="toc-entry toc-h3"><a href="#model">Model</a>
<ul>
<li class="toc-entry toc-h4"><a href="#fields">fields</a></li>
</ul>
</li>
<li class="toc-entry toc-h3"><a href="#stores">Stores</a></li>
</ul>
</li>
<li class="toc-entry toc-h1"><a href="#reference">Reference</a>
<ul>
<li class="toc-entry toc-h2"><a href="#url">URL</a></li>
</ul>
</li>
</ul><p>MVC MVVM 둘다 지원</p>

<h2 id="what-is-mvc">
<a class="anchor" href="#what-is-mvc" aria-hidden="true"><span class="octicon octicon-link"></span></a>What is MVC?</h2>

<p>MVC 아키텍처 대부분의 클래스: 모델(Model), 뷰(View) 컨트롤러(Controller)</p>

<p>사용자는 모델에 의해 수집되거나 처리된 데이터를</p>

<p>화면에 그려주는 뷰를 통해 어플리케이션과 상호작용을 수행하게 된다</p>

<p>뷰와 사용자와의 상호작용은 컨트롤러에 의해 감시되고, 필요하다면 뷰와 모델을 업데이트 한다.</p>

<p>뷰와 모델은 컨트롤러가 중간에 개입하여 업데이트를 중재하기 때문에 직접 서로 간섭하는 일이 드물다.</p>

<p>일반적으로 controller는 MVC 어플리케이션에서 대부분의 어플리케이션 로직을 담고 있다.</p>

<p>이상적인 경우 <code>View</code>: 비즈니스 로직을 거의 갖고 있지 않아야 한다.</p>

<p><code>Model</code>은 데이터와 인터페이스가 주요 역할로서 데이터의 변경에 대한 비즈니스 로직을 담당.</p>

<p>MVC의 목적: 어플리케이션에서 각 클래스의 역할을 간결하고 명확하게 정의.</p>

<p>모든 클래스의 역할이 명확하게 정의되어 있을 경우 대형 어플리케이션 개발 환경에서 클래스가 이리저리 꼬이는 모호함을 최소화.</p>

<p>이것은 결국 어플리케이션 시험과 유지보수를 쉽게 하고 코드의 재사용성을 높이는 결과를 기대할 수 있게 한다.</p>

<hr>

<h2 id="what-is-mvvm">
<a class="anchor" href="#what-is-mvvm" aria-hidden="true"><span class="octicon octicon-link"></span></a>What is MVVM?</h2>

<p>MVC와 MVVM의 가장 핵심적인 차이점 MVVM에서 <code>ViewModel</code>(뷰의 추상화)를 지원한다는 점.</p>

<p><code>ViewModel</code>: "데이터 바인딩(data binding)"이라는 기술을 사용해서 모델의 데이터와 뷰가 그리는 화면상의 데이터 변경을 조율.</p>

<p>Model과 Framework는 최대한의 업무를 수행중 View에 의해 조작되는 어플리케이션 로직을 최소화 하거나 없도록 할 수 있게 됨.</p>

<hr>

<h2 id="returning-users">
<a class="anchor" href="#returning-users" aria-hidden="true"><span class="octicon octicon-link"></span></a>Returning Users</h2>

<p>MVVM 권고.</p>

<h2 id="mvc-and-mvvm">
<a class="anchor" href="#mvc-and-mvvm" aria-hidden="true"><span class="octicon octicon-link"></span></a>MVC and MVVM</h2>

<p>정의:</p>

<ul>
<li>
<p>(M) Model</p>

<ul>
<li>어플리케이션에서 사용되는 데이터를 담당.</li>
<li>"Models"라고 불리는 데이터 집합으로 필드와 데이터로 정의.</li>
<li>예로 User Model은 user-name과 password 필드를 갖는다. Model은 데이터 패키지를 통해 데이터에 대한 추적을 유지하고 결합(associations)을 통해 다른 Model들과 연결됨.</li>
<li>일반적으로 그리드 또는 다른 컴포넌트에 데이터를 제공하기 위한 스토어(Store)와 결합하여 사용되며, 또한 validation, conversion 기타 등등 데이터를 취급하다보면 필요할 수 있는 모든 데이터 로직의 이상적인 장소라고 할 수 있다.</li>
</ul>
</li>
<li>
<p>(V) View</p>

<ul>
<li>화면에 그려지는 비주얼에 관련된 모든 컴포넌트. (Grid, Tree, Panel 등)</li>
</ul>
</li>
<li>
<p>(\C) Controller</p>

<ul>
<li>어플리케이션이 작동하기 위해 필요한 View 로직을 관리.</li>
<li>이에 따라 View를 랜더링 하고, 라우팅하거나 Model 인스턴스를 생성하거나 또는 다른 어플리케이션 로직 일부를 수행토록 함.</li>
</ul>
</li>
<li>
<p>(VM) ViewModel</p>

<ul>
<li> View로 제공되는 데이터를 특정하여 관리하기 위한 클래스로서 컴포넌트가 바인딩을 처리하거나 데이터 변경에 따라 업데이트 되도록 하는 역할을 담당.</li>
</ul>
</li>
</ul>

<p>이러한 어플리케이션 아키텍처는 코드의 구조화 및 일관성을 부여. 이점:</p>

<ul>
<li><p>모든 어플리케이션은 같은 방식으로 동작. 따라서 한번만 배워도 된다.</p></li>
<li><p>어플리케이션 사이에 코드 공유 쉬움.</p></li>
<li><p>어플리케이션의 최적화된 production 버전 생성을 위해 Sencha Cmd를 사용 가능.</p></li>
</ul>

<hr>

<h2 id="building-a-sample-app">
<a class="anchor" href="#building-a-sample-app" aria-hidden="true"><span class="octicon octicon-link"></span></a>Building a Sample App</h2>
<div class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nv">$ </span>sencha <span class="nt">-sdk</span> <span class="nb">local</span>/path/to/ExtJS generate app MyApp MyApp
<span class="nv">$ </span><span class="nb">cd </span>app
<span class="nv">$ </span>sencha app watch
</code></pre></div>
<hr>

<h2 id="application-overview">
<a class="anchor" href="#application-overview" aria-hidden="true"><span class="octicon octicon-link"></span></a>Application Overview</h2>

<p>생성된 application 구조 보기.</p>

<h3 id="file-structure">
<a class="anchor" href="#file-structure" aria-hidden="true"><span class="octicon octicon-link"></span></a>File Structure</h3>

<p>Ext JS 어플리케이션은 모두 단일화 된 폴더 구조를 따른다.
권장하는 배치구조는 모든 스토어, 모델, 뷰 모델, 뷰 컨트롤러 클래스들을 app 폴더에 (모델은 app 폴더 하위인 model 서브 폴더, 스토어는 store에, 뷰 모델/뷰 컨트롤러는 view 서브폴더에) 저장하는 것이다.
최적화된 폴더 구조는 뷰 컨트롤러와 뷰 모델을 논리적으로 묶어서 app/view/의 서브폴더에 사용할 뷰 이름 구조와 유사하게 폴더를 구조화 하는 것.
(아래 그림에서 "app/view/main"과 "classic/src/view/main/" 폴더를 참고)</p>
<div class="highlight"><pre><code class="language-bash" data-lang="bash">app/
    model/
        Readme.md
    store/
        Readme.md
    view/
        main/
            Main.js
            MainController.js
            MainModel.js
    Application.js
    Readme.md
build/
ext/
overrides/
packages/
resources/
sass/

app.js
app.json
bootstrap.css
bootstrap.js
bootstrap.json
build.xml
index.html
Readme.md
</code></pre></div>
<h3 id="namespace">
<a class="anchor" href="#namespace" aria-hidden="true"><span class="octicon octicon-link"></span></a>Namespace</h3>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="c1">//*.js</span>

<span class="o">**</span><span class="p">(</span><span class="nx">AppName</span><span class="p">).(</span><span class="nx">foldername</span><span class="p">).(</span><span class="nx">ClassAndFileName</span><span class="p">)</span><span class="o">**</span>
</code></pre></div>
<p>샘플 어플리케이션에서 "MyApp"은 AppName에, "view"는 foldername에, "main"은 서브폴더 이름으로 "Main"이 클래스와 파일 이름에 대응한다. 이러한 정보에 기반하여 프레임워크는 Main.js를 다음 위치에서 찾게 된다.</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="c1">//Classic</span>
<span class="nx">classic</span><span class="o">/</span><span class="nx">src</span><span class="o">/</span><span class="nx">view</span><span class="o">/</span><span class="nx">main</span><span class="o">/</span><span class="nx">Main</span><span class="p">.</span><span class="nx">js</span>

<span class="c1">//Modern</span>
<span class="nx">modern</span><span class="o">/</span><span class="nx">src</span><span class="o">/</span><span class="nx">view</span><span class="o">/</span><span class="nx">main</span><span class="o">/</span><span class="nx">Main</span><span class="p">.</span><span class="nx">js</span>

<span class="c1">//Core</span>
<span class="c1">//"MyApp.view.main.MainController"는 툴 킷 간에 공유되며, 위치는 아래와 같다.</span>
<span class="nx">app</span><span class="o">/</span><span class="nx">view</span><span class="o">/</span><span class="nx">main</span><span class="o">/</span><span class="nx">MainController</span><span class="p">.</span><span class="nx">js</span>
</code></pre></div>
<hr>

<h2 id="application">
<a class="anchor" href="#application" aria-hidden="true"><span class="octicon octicon-link"></span></a>Application</h2>

<p>./myapp/index.html:</p>
<div class="highlight"><pre><code class="language-html" data-lang="html"><span class="cp">&lt;!DOCTYPE HTML&gt;</span>
<span class="nt">&lt;html</span> <span class="na">manifest=</span><span class="s">""</span><span class="nt">&gt;</span>
<span class="nt">&lt;head&gt;</span>
    <span class="nt">&lt;meta</span> <span class="na">http-equiv=</span><span class="s">"X-UA-Compatible"</span> <span class="na">content=</span><span class="s">"IE=edge"</span><span class="nt">&gt;</span>    
    <span class="nt">&lt;meta</span> <span class="na">charset=</span><span class="s">"UTF-8"</span><span class="nt">&gt;</span>

    <span class="nt">&lt;title&gt;</span>MyApp<span class="nt">&lt;/title&gt;</span>

    <span class="nt">&lt;script </span><span class="na">type=</span><span class="s">"text/javascript"</span><span class="nt">&gt;</span>
        <span class="kd">var</span> <span class="nx">Ext</span> <span class="o">=</span> <span class="nx">Ext</span> <span class="o">||</span> <span class="p">{};</span> <span class="c1">// Ext namespace가 아직 define되지 않음</span>

        <span class="c1">//이 함수는 기본적인 장치 감지가 완료된 후 Microloader에 의해 호출된다.</span>
        <span class="c1">//결과는 "tags" 객체로 제공되며, 사용자가 이 tags를 사용하거나 사용자 tags를 추가할 수도 있다.</span>
        <span class="c1">//tags는 어플리케이션에서 manifest의 platform 필터 또는 platformConfig 표현식에 의해 사용 된다.</span>
        <span class="c1">//</span>
        <span class="nx">Ext</span><span class="p">.</span><span class="nx">beforeLoad</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">tags</span><span class="p">)</span> <span class="p">{</span>
            <span class="kd">var</span> <span class="nx">s</span> <span class="o">=</span> <span class="nx">location</span><span class="p">.</span><span class="nx">search</span><span class="p">,</span>         <span class="c1">// query string (예 "?foo=1&amp;bar")</span>
                <span class="nx">profile</span><span class="p">;</span>

            <span class="c1">//장치 감지 결과를 무시하고 classic 또는 modern look을 시험하려면</span>
            <span class="c1">//"?classic" 또는 "?modern"을 URL에 사용</span>

            <span class="k">if</span> <span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">match</span><span class="p">(</span><span class="sr">/</span><span class="se">\b</span><span class="sr">classic</span><span class="se">\b</span><span class="sr">/</span><span class="p">))</span> <span class="p">{</span>
                <span class="nx">profile</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">classic</span><span class="dl">'</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">match</span><span class="p">(</span><span class="sr">/</span><span class="se">\b</span><span class="sr">modern</span><span class="se">\b</span><span class="sr">/</span><span class="p">))</span> <span class="p">{</span>
                <span class="nx">profile</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">modern</span><span class="dl">'</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="k">else</span> <span class="p">{</span>
                <span class="nx">profile</span> <span class="o">=</span> <span class="nx">tags</span><span class="p">.</span><span class="nx">desktop</span> <span class="p">?</span> <span class="dl">'</span><span class="s1">classic</span><span class="dl">'</span> <span class="p">:</span> <span class="dl">'</span><span class="s1">modern</span><span class="dl">'</span><span class="p">;</span>
                <span class="c1">//profile = tags.phone ? 'modern' : 'classic';</span>
            <span class="p">}</span>

            <span class="nx">Ext</span><span class="p">.</span><span class="nx">manifest</span> <span class="o">=</span> <span class="nx">profile</span><span class="p">;</span> <span class="c1">// build profile name과 반드시 일치해야 한다</span>

            <span class="c1">//This funtion is called once the manifest is available but before</span>
            <span class="c1">//any data is pulled from it.</span>
            <span class="c1">//</span>
            <span class="c1">//return funtion(manifest) {</span>
                <span class="c1">//peek at /modify the manifest object</span>
            <span class="c1">//};</span>
        <span class="p">};</span>
    <span class="nt">&lt;/script&gt;</span>

    <span class="c">&lt;!--The line below must be kept intact for Sencha Cmd to build your application --&gt;</span>

    <span class="nt">&lt;script </span><span class="na">id=</span><span class="s">"microloader"</span> <span class="na">type=</span><span class="s">"text/javascript"</span> <span class="na">src=</span><span class="s">"bootstrap.js"</span><span class="nt">&gt;&lt;/script&gt;</span>

<span class="nt">&lt;/head&gt;</span>
<span class="nt">&lt;body&gt;&lt;/body&gt;</span>
<span class="nt">&lt;/html&gt;</span>
</code></pre></div>
<p>app.json</p>

<ul>
<li>한 곳에 모든 어플리케이션의 메타 데이터가 기록.</li>
</ul>

<p>정의된 어플리케이션 리소스 로딩을 위해 Ext JS는 마이크로 로더(Microloader)를 사용.</p>

<p>이를 통해 모든 리소스가 하나씩 <code>index.html</code>에 명시되어야 할 필요가 없게되는 것.</p>

<ul>
<li><p><code>Sencha Cmd</code>: app.json 포함된 정보를 통해 간편하고 효과적인 방법으로 어플리케이션을 컴파일 함.</p></li>
<li><p>상세한 주석이 포함고, 정확한 방법으로 설정하기 위해 필요한 정보의 다양한 리소스를 제공.</p></li>
</ul>

<p>beforeLoad와 틀랫폼 특정적인 빌드의 참조: <a href="http://docs.sencha.com/extjs/6.2.1/guides/application_architecture/developing_for_multiple_screens_and_environments.html">Multiple Screens</a></p>

<h3 id="app-js">
<a class="anchor" href="#app-js" aria-hidden="true"><span class="octicon octicon-link"></span></a>app.js</h3>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="cm">/*
 * This file is generated and updated by Sencha Cmd. You can edit this file as
 * needed for your application, but these edits will have to be merged by
 * Sencha Cmd when upgrading.
 */</span>
<span class="nx">Ext</span><span class="p">.</span><span class="nx">application</span><span class="p">({</span>
    <span class="na">name</span><span class="p">:</span> <span class="dl">'</span><span class="s1">MyApp</span><span class="dl">'</span><span class="p">,</span>

    <span class="na">extend</span><span class="p">:</span> <span class="dl">'</span><span class="s1">MyApp.Application</span><span class="dl">'</span><span class="p">,</span>

    <span class="na">requires</span><span class="p">:</span> <span class="p">[</span>
        <span class="dl">'</span><span class="s1">MyApp.view.main.Main</span><span class="dl">'</span>
    <span class="p">],</span>

    <span class="c1">// 처음 생성될 뷰 이름. 클래식 툴 킷에서 이 클래스는</span>
    <span class="c1">// Ext.Viewport를 확장하지 않았다면 "viewport" 플러그인을 갖게 된다.</span>
    <span class="c1">// 모던 툴 킷에서 main view는 Viewport에 추가될 것이다.</span>
    <span class="c1">//</span>
    <span class="na">mainView</span> <span class="p">:</span> <span class="dl">'</span><span class="s1">MyApp.view.main.Main</span><span class="dl">'</span>

    <span class="c1">//-------------------------------------------------------------------------</span>
    <span class="c1">// Most customizations should be made to MyApp.Application. If you need to</span>
    <span class="c1">// customize this file, doing so below this section reduces the likelihood</span>
    <span class="c1">// of merge conflicts when upgrading to new versions of Sencha Cmd.</span>
    <span class="c1">//-------------------------------------------------------------------------</span>
<span class="p">});</span>
</code></pre></div>
<p><code>mainView</code>:</p>

<ul>
<li>컨테이너 클래스를 지정함으로써,</li>
</ul>

<p>Viewport(=MyApp.view.main.Main(TabPanel 클래스))로 어떤 class든 사용 가능 됨.</p>

<ul>
<li><p>어플리케이션에게 지정된 view를 생성, Viewport 플러그인을 붙이도록 지시.</p></li>
<li><p>이러한 동작은 뷰를 document body에 연결함.</p></li>
</ul>

<h3 id="application-js">
<a class="anchor" href="#application-js" aria-hidden="true"><span class="octicon octicon-link"></span></a>Application.js</h3>

<p>모든 Ext JS 어플리케이션은 <code>Application</code> class의 인스턴스로부터 시작.</p>

<p>이 class는 <code>app.js</code>에 의해 인스턴스화 가능한지 시험되며 실행 가능 상태가 됨.</p>

<p>아래 Application.js의 내용은 Sencha Cmd가 자동으로 생성한 것:</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="nx">Ext</span><span class="p">.</span><span class="nx">define</span><span class="p">(</span><span class="dl">'</span><span class="s1">MyApp.Application</span><span class="dl">'</span><span class="p">,</span> <span class="p">{</span>
    <span class="na">extend</span><span class="p">:</span> <span class="dl">'</span><span class="s1">Ext.app.Application</span><span class="dl">'</span><span class="p">,</span>

    <span class="na">name</span><span class="p">:</span> <span class="dl">'</span><span class="s1">MyApp</span><span class="dl">'</span><span class="p">,</span>

    <span class="na">stores</span><span class="p">:</span> <span class="p">[</span>
        <span class="c1">// TODO: add global/shared stores here</span>
    <span class="p">],</span>

    <span class="na">launch</span><span class="p">:</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
        <span class="c1">// TODO - Launch the application</span>
    <span class="p">},</span>

    <span class="na">onAppUpdate</span> <span class="p">:</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
        <span class="nx">Ext</span><span class="p">.</span><span class="nx">Msg</span><span class="p">.</span><span class="nx">confirm</span><span class="p">(</span><span class="dl">'</span><span class="s1">Applicaton Update</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">This application has an update, reload?</span><span class="dl">'</span><span class="p">,</span>
            <span class="kd">function</span><span class="p">(</span><span class="nx">choice</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">if</span><span class="p">(</span><span class="nx">choice</span> <span class="o">===</span> <span class="dl">'</span><span class="s1">yes</span><span class="dl">'</span><span class="p">)</span> <span class="p">{</span>
                    <span class="nb">window</span><span class="p">.</span><span class="nx">location</span><span class="p">.</span><span class="nx">reload</span><span class="p">();</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">);</span>
    <span class="p">}</span>
<span class="p">});</span>
</code></pre></div>
<p><code>Application</code> 클래스:</p>

<ul>
<li>어플리케이션의 Global 설정. (namespace, 공유 store 등을 포함)</li>
</ul>

<hr>

<h2 id="views">
<a class="anchor" href="#views" aria-hidden="true"><span class="octicon octicon-link"></span></a>Views</h2>

<p>Ext.Component의 서브 클래스인 컴포넌트 그 이상도 그 이하도 아니라고 할 수 있음.</p>

<p>어플리케이션의 모든 비주얼적 측면을 포함.</p>

<p>만약 이 초기형태의 어플리케이션이 갖는 "classic/src/view/main/Main.js" 파일을 열어 본다면 다음과 같을 것:</p>

<ul>
<li><p>어플리케이션 로직이 포함되어 있지 않은 점에 주목.</p></li>
<li><p>뷰에 관련한 모든 로직은 뷰 컨트롤러에 포함되어야 하며, 다음 섹션에서 상세.</p></li>
<li><p>이 뷰에서 주목해야할 두가지는 controller와 viewModel 설정.</p></li>
</ul>

<p>그 다음으로 주목할 뷰는 "List" 뷰로서 classic/src/main/view/List에서 찾을 수 있다.</p>

<h3 id="controller-config">
<a class="anchor" href="#controller-config" aria-hidden="true"><span class="octicon octicon-link"></span></a>Controller Config</h3>

<p>뷰에 대한 ViewController를 지정할 수 있도록 한다.</p>

<p>ViewController가 뷰에 대해 지정되면 event handler러와 reference를 위한 컨테이너로 변화하게 되는데, 이러한 사실은 결국 ViewController와 View에서 이벤트를 발생시키는 컴포넌트가 1:1 관계를 갖는다는 뜻.</p>

<h3 id="viewmodel-config">
<a class="anchor" href="#viewmodel-config" aria-hidden="true"><span class="octicon octicon-link"></span></a>ViewModel Config</h3>

<p>View에 대한 ViewModel을 지정하는 것.</p>

<p>ViewModel은 컴포넌트와 하위 View에 대한 데이터를 제공하는 역할을 담당.</p>

<p>ViewModel에 담긴 데이터는 컴포넌트와 바인딩 설정에 따라 화면에 전시되거나 편집될 목적으로 사용되는 것이 일반적.</p>

<hr>

<h2 id="controllers">
<a class="anchor" href="#controllers" aria-hidden="true"><span class="octicon octicon-link"></span></a>Controllers</h2>

<p>MainController.js:</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="nx">Ext</span><span class="p">.</span><span class="nx">define</span><span class="p">(</span><span class="dl">'</span><span class="s1">MyApp.view.main.MainController</span><span class="dl">'</span><span class="p">,</span> <span class="p">{</span>
    <span class="na">extend</span><span class="p">:</span><span class="dl">'</span><span class="s1">Ext.app.ViewController</span><span class="dl">'</span><span class="p">,</span>

    <span class="na">alias</span><span class="p">:</span> <span class="dl">'</span><span class="s1">controller.main</span><span class="dl">'</span><span class="p">,</span>

    <span class="na">onItemSelected</span><span class="p">:</span> <span class="kd">function</span><span class="p">(</span><span class="nx">sender</span><span class="p">,</span> <span class="nx">record</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">Ext</span><span class="p">.</span><span class="nx">Msg</span><span class="p">.</span><span class="nx">confirm</span><span class="p">(</span><span class="dl">'</span><span class="s1">Confirm</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">Are you sure?</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">onConfirm</span><span class="dl">'</span><span class="p">,</span> <span class="k">this</span><span class="p">);</span>
    <span class="p">},</span>

    <span class="na">onConfirm</span><span class="p">:</span> <span class="kd">function</span><span class="p">(</span><span class="nx">choice</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">choice</span> <span class="o">===</span> <span class="dl">'</span><span class="s1">yes</span><span class="dl">'</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">//do something</span>
        <span class="p">}</span><span class="nx">tk</span>
    <span class="p">}</span>
<span class="p">});</span>
</code></pre></div>
<ul>
<li>Controller는 별다른 특별한 설정이 없이 이벤트를 처리할 준비됨.</li>
</ul>

<p>이런 점은 어플리케이션에 매우 쉽게 로직을 추가 가능.</p>

<ul>
<li>onItemSelected 함수에 필요한 모든 것은 여기에 구현하면 되는데,</li>
</ul>

<p>바로 컨트롤러가 뷰와 1-대-1의 관계로 대응하기 때문이다.</p>

<p>ViewController 목적:</p>

<ul>
<li><p>"listeners"와 "reference" 설정을 이용한 View와 연결.</p></li>
<li><p>연결된 ViewController를 자동으로 관리함으로서 View의 생명주기를 연장.</p></li>
<li><p>인스턴스 생성부터 소멸에 이르기까지 Ext.app.ViewController는 컴포넌트와 이를 참조하는 ViewController를 묶어주는데 같은 View 클래스의 두번째 인스턴스는 자신만의 ViewController 인스턴스를 갖게 됨.</p></li>
<li><p>이러한 View가 소멸될 때, 연결된 ViewController 인스턴스 역시 같이 소멸됨.</p></li>
<li><p>중첩된 View의 직관성을 위한 추상화 제공.</p></li>
</ul>

<hr>

<h2 id="viewmodels">
<a class="anchor" href="#viewmodels" aria-hidden="true"><span class="octicon octicon-link"></span></a>ViewModels</h2>

<p>app/view/main/MainModel.js:</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="nx">Ext</span><span class="p">.</span><span class="nx">define</span><span class="p">(</span><span class="dl">'</span><span class="s1">MyApp.view.main.MainModel</span><span class="dl">'</span><span class="p">,</span> <span class="p">{</span>
    <span class="na">extend</span><span class="p">:</span> <span class="dl">'</span><span class="s1">Ext.app.ViewModel</span><span class="dl">'</span><span class="p">,</span>

    <span class="na">alias</span> <span class="p">:</span> <span class="dl">'</span><span class="s1">viewmodel.main</span><span class="dl">'</span><span class="p">,</span>

    <span class="na">data</span><span class="p">:{</span>
        <span class="na">name</span><span class="p">:</span><span class="dl">'</span><span class="s1">MyApp</span><span class="dl">'</span><span class="p">,</span>
        <span class="na">loremIpsum</span> <span class="p">:</span> <span class="dl">'</span><span class="s1">생략</span><span class="dl">'</span>
    <span class="p">}</span>
    <span class="c1">//TODO - add data, formulas and/or method to support your view</span>
<span class="p">});</span>
</code></pre></div>
<p>데이터 객체를 관리하는 클래스.</p>

<p>View가 사용할 데이터를 바인딩하고 데이터가 수정되었을 때 알리는 역할을 수행.</p>

<p>레퍼런스를 이용해서 View에 연결.</p>

<p>자식 View는 간단하게 부모 ViewModel의 데이터를 "상속" 가능.</p>

<ul>
<li>ViewModel이 View와 연결되어 있기 때문에 컴포넌트 계층구조의 조상 컴포넌트에 의해 소유된 상위 부모 ViewModel과 연결되는 것 역시 가능.</li>
</ul>

<p>Main.js의 <code>viewModel</code> 설정을 이용해서 View와 ViewModel의 연결을 생성했었다.</p>

<p>이 연결은 viewModel 로부터 View로 선언적인 형태로서 데이터를 자동으로 설정하기 위한 Setter와 설정을 바인딩할 수 있도록 함.</p>

<p>MainModel.js에서 인라인 코딩 되어 있는 데이터를 참고하라. 이 예는 데이터는 어느 곳이나 있을 수 있고 어디에서라도 올 수 있다는 것을 의미한다. 데이터는 AJAX, REST 등등 다양한 종류의 프록시로부터 제공될 수 있을 것.</p>

<hr>

<h2 id="models-and-stores">
<a class="anchor" href="#models-and-stores" aria-hidden="true"><span class="octicon octicon-link"></span></a>Models and Stores</h2>

<p>모델과 스토어는 어플리케이션에서 정보의 게이트웨이 역할을 담당.</p>

<p>대부분의 데이터는 두 class에 의해 "모델화"되거나, 조직화 되거나 또는 보내고 받게 됨.</p>

<h3 id="model">
<a class="anchor" href="#model" aria-hidden="true"><span class="octicon octicon-link"></span></a>Model</h3>

<p>Ext.data.Model은 어플리케이션에서 지속 가능한 모든 형태의 데이터를 대표.
각 Model은 어플리케이션에 대해 "모델" 데이터를 제공하기 위한 필드와 함수를 갖음.
Model은 가장 일반적으로 스토어와 결합하여 사용, 스토어는 그리드, 트리 및 차트와 같이 데이터와 함께 사용되는 컴포넌트에 의해 사용.</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="c1">// myapp/app/model/User.js</span>

<span class="nx">Ext</span><span class="p">.</span><span class="nx">define</span><span class="p">(</span><span class="dl">'</span><span class="s1">MyApp.model.User</span><span class="dl">'</span><span class="p">,</span> <span class="p">{</span>
    <span class="na">extend</span><span class="p">:</span><span class="dl">'</span><span class="s1">Ext.data.Model</span><span class="dl">'</span><span class="p">,</span>
    <span class="na">fields</span><span class="p">:</span> <span class="p">[</span>
        <span class="p">{</span><span class="na">name</span><span class="p">:</span><span class="dl">'</span><span class="s1">name</span><span class="dl">'</span><span class="p">,</span> <span class="na">type</span><span class="p">:</span><span class="dl">'</span><span class="s1">string</span><span class="dl">'</span><span class="p">},</span>
        <span class="p">{</span><span class="na">name</span><span class="p">:</span><span class="dl">'</span><span class="s1">age</span><span class="dl">'</span><span class="p">,</span> <span class="na">type</span><span class="p">:</span><span class="dl">'</span><span class="s1">int</span><span class="dl">'</span><span class="p">}</span>
    <span class="p">]</span>
<span class="p">});</span>
</code></pre></div>
<p>namespace 고려해서 myapp/app/model/User.js 파일로 저장되어야 함.</p>

<h4 id="fields">
<a class="anchor" href="#fields" aria-hidden="true"><span class="octicon octicon-link"></span></a>fields</h4>

<p>Ext.data.Model은 담고 있는 값을 의미하는 레코드 또는 "fields"라고 불리는 속성을 기술한다. 모델 클래스는 이러한 필드를 "fields" 설정을 이용해서 정의.</p>

<p>비선언 경우: 자동 데이터 인식 후 선언</p>

<p>선언 경우:</p>

<ul>
<li><p>Validation</p></li>
<li><p>기본 값</p></li>
<li><p>변환 함수</p></li>
</ul>

<h3 id="stores">
<a class="anchor" href="#stores" aria-hidden="true"><span class="octicon octicon-link"></span></a>Stores</h3>

<p>클라이언트 측면에서 레코드(모델 클래스의 인스턴스)의 캐시.</p>

<p>담고 있는 데이터에 대한 정렬(Sorting), 필터링 및 질의(Querying)기능을 제공.</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="c1">// myapp/app/store/User.js:</span>

<span class="nx">Ext</span><span class="p">.</span><span class="nx">define</span><span class="p">(</span><span class="dl">'</span><span class="s1">MyApp.store.Users</span><span class="dl">'</span><span class="p">,</span> <span class="p">{</span>
    <span class="na">extend</span><span class="p">:</span> <span class="dl">'</span><span class="s1">Ext.data.Store</span><span class="dl">'</span><span class="p">,</span>
    <span class="na">alias</span> <span class="p">:</span> <span class="dl">'</span><span class="s1">store.users</span><span class="dl">'</span><span class="p">,</span>
    <span class="na">model</span><span class="p">:</span><span class="dl">'</span><span class="s1">MyApp.model.User</span><span class="dl">'</span><span class="p">,</span>
    <span class="na">data</span><span class="p">:[</span>
        <span class="p">{</span><span class="na">firstName</span><span class="p">:</span><span class="dl">'</span><span class="s1">Sech</span><span class="dl">'</span><span class="p">,</span> <span class="na">age</span><span class="p">:</span><span class="dl">'</span><span class="s1">34</span><span class="dl">'</span><span class="p">},</span>
        <span class="p">{</span><span class="na">firstName</span><span class="p">:</span><span class="dl">'</span><span class="s1">Scott</span><span class="dl">'</span><span class="p">,</span> <span class="na">age</span><span class="p">:</span><span class="dl">'</span><span class="s1">72</span><span class="dl">'</span><span class="p">},</span>
        <span class="p">{</span><span class="na">firstName</span><span class="p">:</span><span class="dl">'</span><span class="s1">Gary</span><span class="dl">'</span><span class="p">,</span> <span class="na">age</span><span class="p">:</span><span class="dl">'</span><span class="s1">19</span><span class="dl">'</span><span class="p">},</span>
        <span class="p">{</span><span class="na">firstName</span><span class="p">:</span><span class="dl">'</span><span class="s1">Capybara</span><span class="dl">'</span><span class="p">,</span><span class="na">age</span><span class="p">:</span><span class="dl">'</span><span class="s1">208</span><span class="dl">'</span><span class="p">}</span>
    <span class="p">]</span>
<span class="p">});</span>
</code></pre></div>
<p>Application.js의 <code>stores</code> 설정을 통해 store(=Users)를 글로벌 인스턴스로 설정:</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="c1">// Application.js:</span>

<span class="nx">stores</span><span class="p">:</span> <span class="p">[</span>
    <span class="dl">'</span><span class="s1">Users</span><span class="dl">'</span>
<span class="p">],</span>
</code></pre></div>
<p>데이터는 대부분의 실제 어플리케이션을 구현할 때는 모델 또는 스토어에서 프록시를 이용해 데이터를 획득.
프록시는 데이터 제공자와 어플리케이션간에 데이터 전송을 수행.</p>

<p>모델, 스토어 및 데이터 제공자 참조: [Data Guide]</p>

<h1 id="reference">
<a class="anchor" href="#reference" aria-hidden="true"><span class="octicon octicon-link"></span></a><em>Reference</em>
</h1>

<h2 id="url">
<a class="anchor" href="#url" aria-hidden="true"><span class="octicon octicon-link"></span></a>URL</h2>

<ul>
<li><a href="http://docs.sencha.com/extjs/6.2.1/guides/application_architecture/developing_for_multiple_screens_and_environments.html">http://docs.sencha.com/extjs/6.2.1/guides/application_architecture/developing_for_multiple_screens_and_environments.html</a></li>
</ul>

  </div>

<div>
  <p>MVC MVVM 둘다 지원</p>

<h2 id="what-is-mvc">What is MVC?</h2>

<p>MVC 아키텍처 대부분의 클래스: 모델(Model), 뷰(View) 컨트롤러(Controller)</p>

<p>사용자는 모델에 의해 수집되거나 처리된 데이터를</p>

<p>화면에 그려주는 뷰를 통해 어플리케이션과 상호작용을 수행하게 된다</p>

<p>뷰와 사용자와의 상호작용은 컨트롤러에 의해 감시되고, 필요하다면 뷰와 모델을 업데이트 한다.</p>

<p>뷰와 모델은 컨트롤러가 중간에 개입하여 업데이트를 중재하기 때문에 직접 서로 간섭하는 일이 드물다.</p>

<p>일반적으로 controller는 MVC 어플리케이션에서 대부분의 어플리케이션 로직을 담고 있다.</p>

<p>이상적인 경우 <code>View</code>: 비즈니스 로직을 거의 갖고 있지 않아야 한다.</p>

<p><code>Model</code>은 데이터와 인터페이스가 주요 역할로서 데이터의 변경에 대한 비즈니스 로직을 담당.</p>

<p>MVC의 목적: 어플리케이션에서 각 클래스의 역할을 간결하고 명확하게 정의.</p>

<p>모든 클래스의 역할이 명확하게 정의되어 있을 경우 대형 어플리케이션 개발 환경에서 클래스가 이리저리 꼬이는 모호함을 최소화.</p>

<p>이것은 결국 어플리케이션 시험과 유지보수를 쉽게 하고 코드의 재사용성을 높이는 결과를 기대할 수 있게 한다.</p>

<hr>

<h2 id="what-is-mvvm">What is MVVM?</h2>

<p>MVC와 MVVM의 가장 핵심적인 차이점 MVVM에서 <code>ViewModel</code>(뷰의 추상화)를 지원한다는 점.</p>

<p><code>ViewModel</code>: "데이터 바인딩(data binding)"이라는 기술을 사용해서 모델의 데이터와 뷰가 그리는 화면상의 데이터 변경을 조율.</p>

<p>Model과 Framework는 최대한의 업무를 수행중 View에 의해 조작되는 어플리케이션 로직을 최소화 하거나 없도록 할 수 있게 됨.</p>

<hr>

<h2 id="returning-users">Returning Users</h2>

<p>MVVM 권고.</p>

<h2 id="mvc-and-mvvm">MVC and MVVM</h2>

<p>정의:</p>

<ul>
<li>
<p>(M) Model</p>

<ul>
<li>어플리케이션에서 사용되는 데이터를 담당.</li>
<li>"Models"라고 불리는 데이터 집합으로 필드와 데이터로 정의.</li>
<li>예로 User Model은 user-name과 password 필드를 갖는다. Model은 데이터 패키지를 통해 데이터에 대한 추적을 유지하고 결합(associations)을 통해 다른 Model들과 연결됨.</li>
<li>일반적으로 그리드 또는 다른 컴포넌트에 데이터를 제공하기 위한 스토어(Store)와 결합하여 사용되며, 또한 validation, conversion 기타 등등 데이터를 취급하다보면 필요할 수 있는 모든 데이터 로직의 이상적인 장소라고 할 수 있다.</li>
</ul>
</li>
<li>
<p>(V) View</p>

<ul>
<li>화면에 그려지는 비주얼에 관련된 모든 컴포넌트. (Grid, Tree, Panel 등)</li>
</ul>
</li>
<li>
<p>(\C) Controller</p>

<ul>
<li>어플리케이션이 작동하기 위해 필요한 View 로직을 관리.</li>
<li>이에 따라 View를 랜더링 하고, 라우팅하거나 Model 인스턴스를 생성하거나 또는 다른 어플리케이션 로직 일부를 수행토록 함.</li>
</ul>
</li>
<li>
<p>(VM) ViewModel</p>

<ul>
<li> View로 제공되는 데이터를 특정하여 관리하기 위한 클래스로서 컴포넌트가 바인딩을 처리하거나 데이터 변경에 따라 업데이트 되도록 하는 역할을 담당.</li>
</ul>
</li>
</ul>

<p>이러한 어플리케이션 아키텍처는 코드의 구조화 및 일관성을 부여. 이점:</p>

<ul>
<li><p>모든 어플리케이션은 같은 방식으로 동작. 따라서 한번만 배워도 된다.</p></li>
<li><p>어플리케이션 사이에 코드 공유 쉬움.</p></li>
<li><p>어플리케이션의 최적화된 production 버전 생성을 위해 Sencha Cmd를 사용 가능.</p></li>
</ul>

<hr>

<h2 id="building-a-sample-app">Building a Sample App</h2>
<div class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nv">$ </span>sencha <span class="nt">-sdk</span> <span class="nb">local</span>/path/to/ExtJS generate app MyApp MyApp
<span class="nv">$ </span><span class="nb">cd </span>app
<span class="nv">$ </span>sencha app watch
</code></pre></div>
<hr>

<h2 id="application-overview">Application Overview</h2>

<p>생성된 application 구조 보기.</p>

<h3 id="file-structure">File Structure</h3>

<p>Ext JS 어플리케이션은 모두 단일화 된 폴더 구조를 따른다.
권장하는 배치구조는 모든 스토어, 모델, 뷰 모델, 뷰 컨트롤러 클래스들을 app 폴더에 (모델은 app 폴더 하위인 model 서브 폴더, 스토어는 store에, 뷰 모델/뷰 컨트롤러는 view 서브폴더에) 저장하는 것이다.
최적화된 폴더 구조는 뷰 컨트롤러와 뷰 모델을 논리적으로 묶어서 app/view/의 서브폴더에 사용할 뷰 이름 구조와 유사하게 폴더를 구조화 하는 것.
(아래 그림에서 "app/view/main"과 "classic/src/view/main/" 폴더를 참고)</p>
<div class="highlight"><pre><code class="language-bash" data-lang="bash">app/
    model/
        Readme.md
    store/
        Readme.md
    view/
        main/
            Main.js
            MainController.js
            MainModel.js
    Application.js
    Readme.md
build/
ext/
overrides/
packages/
resources/
sass/

app.js
app.json
bootstrap.css
bootstrap.js
bootstrap.json
build.xml
index.html
Readme.md
</code></pre></div>
<h3 id="namespace">Namespace</h3>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="c1">//*.js</span>

<span class="o">**</span><span class="p">(</span><span class="nx">AppName</span><span class="p">).(</span><span class="nx">foldername</span><span class="p">).(</span><span class="nx">ClassAndFileName</span><span class="p">)</span><span class="o">**</span>
</code></pre></div>
<p>샘플 어플리케이션에서 "MyApp"은 AppName에, "view"는 foldername에, "main"은 서브폴더 이름으로 "Main"이 클래스와 파일 이름에 대응한다. 이러한 정보에 기반하여 프레임워크는 Main.js를 다음 위치에서 찾게 된다.</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="c1">//Classic</span>
<span class="nx">classic</span><span class="o">/</span><span class="nx">src</span><span class="o">/</span><span class="nx">view</span><span class="o">/</span><span class="nx">main</span><span class="o">/</span><span class="nx">Main</span><span class="p">.</span><span class="nx">js</span>

<span class="c1">//Modern</span>
<span class="nx">modern</span><span class="o">/</span><span class="nx">src</span><span class="o">/</span><span class="nx">view</span><span class="o">/</span><span class="nx">main</span><span class="o">/</span><span class="nx">Main</span><span class="p">.</span><span class="nx">js</span>

<span class="c1">//Core</span>
<span class="c1">//"MyApp.view.main.MainController"는 툴 킷 간에 공유되며, 위치는 아래와 같다.</span>
<span class="nx">app</span><span class="o">/</span><span class="nx">view</span><span class="o">/</span><span class="nx">main</span><span class="o">/</span><span class="nx">MainController</span><span class="p">.</span><span class="nx">js</span>
</code></pre></div>
<hr>

<h2 id="application">Application</h2>

<p>./myapp/index.html:</p>
<div class="highlight"><pre><code class="language-html" data-lang="html"><span class="cp">&lt;!DOCTYPE HTML&gt;</span>
<span class="nt">&lt;html</span> <span class="na">manifest=</span><span class="s">""</span><span class="nt">&gt;</span>
<span class="nt">&lt;head&gt;</span>
    <span class="nt">&lt;meta</span> <span class="na">http-equiv=</span><span class="s">"X-UA-Compatible"</span> <span class="na">content=</span><span class="s">"IE=edge"</span><span class="nt">&gt;</span>    
    <span class="nt">&lt;meta</span> <span class="na">charset=</span><span class="s">"UTF-8"</span><span class="nt">&gt;</span>

    <span class="nt">&lt;title&gt;</span>MyApp<span class="nt">&lt;/title&gt;</span>

    <span class="nt">&lt;script </span><span class="na">type=</span><span class="s">"text/javascript"</span><span class="nt">&gt;</span>
        <span class="kd">var</span> <span class="nx">Ext</span> <span class="o">=</span> <span class="nx">Ext</span> <span class="o">||</span> <span class="p">{};</span> <span class="c1">// Ext namespace가 아직 define되지 않음</span>

        <span class="c1">//이 함수는 기본적인 장치 감지가 완료된 후 Microloader에 의해 호출된다.</span>
        <span class="c1">//결과는 "tags" 객체로 제공되며, 사용자가 이 tags를 사용하거나 사용자 tags를 추가할 수도 있다.</span>
        <span class="c1">//tags는 어플리케이션에서 manifest의 platform 필터 또는 platformConfig 표현식에 의해 사용 된다.</span>
        <span class="c1">//</span>
        <span class="nx">Ext</span><span class="p">.</span><span class="nx">beforeLoad</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">tags</span><span class="p">)</span> <span class="p">{</span>
            <span class="kd">var</span> <span class="nx">s</span> <span class="o">=</span> <span class="nx">location</span><span class="p">.</span><span class="nx">search</span><span class="p">,</span>         <span class="c1">// query string (예 "?foo=1&amp;bar")</span>
                <span class="nx">profile</span><span class="p">;</span>

            <span class="c1">//장치 감지 결과를 무시하고 classic 또는 modern look을 시험하려면</span>
            <span class="c1">//"?classic" 또는 "?modern"을 URL에 사용</span>

            <span class="k">if</span> <span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">match</span><span class="p">(</span><span class="sr">/</span><span class="se">\b</span><span class="sr">classic</span><span class="se">\b</span><span class="sr">/</span><span class="p">))</span> <span class="p">{</span>
                <span class="nx">profile</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">classic</span><span class="dl">'</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">match</span><span class="p">(</span><span class="sr">/</span><span class="se">\b</span><span class="sr">modern</span><span class="se">\b</span><span class="sr">/</span><span class="p">))</span> <span class="p">{</span>
                <span class="nx">profile</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">modern</span><span class="dl">'</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="k">else</span> <span class="p">{</span>
                <span class="nx">profile</span> <span class="o">=</span> <span class="nx">tags</span><span class="p">.</span><span class="nx">desktop</span> <span class="p">?</span> <span class="dl">'</span><span class="s1">classic</span><span class="dl">'</span> <span class="p">:</span> <span class="dl">'</span><span class="s1">modern</span><span class="dl">'</span><span class="p">;</span>
                <span class="c1">//profile = tags.phone ? 'modern' : 'classic';</span>
            <span class="p">}</span>

            <span class="nx">Ext</span><span class="p">.</span><span class="nx">manifest</span> <span class="o">=</span> <span class="nx">profile</span><span class="p">;</span> <span class="c1">// build profile name과 반드시 일치해야 한다</span>

            <span class="c1">//This funtion is called once the manifest is available but before</span>
            <span class="c1">//any data is pulled from it.</span>
            <span class="c1">//</span>
            <span class="c1">//return funtion(manifest) {</span>
                <span class="c1">//peek at /modify the manifest object</span>
            <span class="c1">//};</span>
        <span class="p">};</span>
    <span class="nt">&lt;/script&gt;</span>

    <span class="c">&lt;!--The line below must be kept intact for Sencha Cmd to build your application --&gt;</span>

    <span class="nt">&lt;script </span><span class="na">id=</span><span class="s">"microloader"</span> <span class="na">type=</span><span class="s">"text/javascript"</span> <span class="na">src=</span><span class="s">"bootstrap.js"</span><span class="nt">&gt;&lt;/script&gt;</span>

<span class="nt">&lt;/head&gt;</span>
<span class="nt">&lt;body&gt;&lt;/body&gt;</span>
<span class="nt">&lt;/html&gt;</span>
</code></pre></div>
<p>app.json</p>

<ul>
<li>한 곳에 모든 어플리케이션의 메타 데이터가 기록.</li>
</ul>

<p>정의된 어플리케이션 리소스 로딩을 위해 Ext JS는 마이크로 로더(Microloader)를 사용.</p>

<p>이를 통해 모든 리소스가 하나씩 <code>index.html</code>에 명시되어야 할 필요가 없게되는 것.</p>

<ul>
<li><p><code>Sencha Cmd</code>: app.json 포함된 정보를 통해 간편하고 효과적인 방법으로 어플리케이션을 컴파일 함.</p></li>
<li><p>상세한 주석이 포함고, 정확한 방법으로 설정하기 위해 필요한 정보의 다양한 리소스를 제공.</p></li>
</ul>

<p>beforeLoad와 틀랫폼 특정적인 빌드의 참조: <a href="http://docs.sencha.com/extjs/6.2.1/guides/application_architecture/developing_for_multiple_screens_and_environments.html" rel="nofollow" target="_blank">Multiple Screens</a></p>

<h3 id="app-js">app.js</h3>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="cm">/*
 * This file is generated and updated by Sencha Cmd. You can edit this file as
 * needed for your application, but these edits will have to be merged by
 * Sencha Cmd when upgrading.
 */</span>
<span class="nx">Ext</span><span class="p">.</span><span class="nx">application</span><span class="p">({</span>
    <span class="na">name</span><span class="p">:</span> <span class="dl">'</span><span class="s1">MyApp</span><span class="dl">'</span><span class="p">,</span>

    <span class="na">extend</span><span class="p">:</span> <span class="dl">'</span><span class="s1">MyApp.Application</span><span class="dl">'</span><span class="p">,</span>

    <span class="na">requires</span><span class="p">:</span> <span class="p">[</span>
        <span class="dl">'</span><span class="s1">MyApp.view.main.Main</span><span class="dl">'</span>
    <span class="p">],</span>

    <span class="c1">// 처음 생성될 뷰 이름. 클래식 툴 킷에서 이 클래스는</span>
    <span class="c1">// Ext.Viewport를 확장하지 않았다면 "viewport" 플러그인을 갖게 된다.</span>
    <span class="c1">// 모던 툴 킷에서 main view는 Viewport에 추가될 것이다.</span>
    <span class="c1">//</span>
    <span class="na">mainView</span> <span class="p">:</span> <span class="dl">'</span><span class="s1">MyApp.view.main.Main</span><span class="dl">'</span>

    <span class="c1">//-------------------------------------------------------------------------</span>
    <span class="c1">// Most customizations should be made to MyApp.Application. If you need to</span>
    <span class="c1">// customize this file, doing so below this section reduces the likelihood</span>
    <span class="c1">// of merge conflicts when upgrading to new versions of Sencha Cmd.</span>
    <span class="c1">//-------------------------------------------------------------------------</span>
<span class="p">});</span>
</code></pre></div>
<p><code>mainView</code>:</p>

<ul>
<li>컨테이너 클래스를 지정함으로써,</li>
</ul>

<p>Viewport(=MyApp.view.main.Main(TabPanel 클래스))로 어떤 class든 사용 가능 됨.</p>

<ul>
<li><p>어플리케이션에게 지정된 view를 생성, Viewport 플러그인을 붙이도록 지시.</p></li>
<li><p>이러한 동작은 뷰를 document body에 연결함.</p></li>
</ul>

<h3 id="application-js">Application.js</h3>

<p>모든 Ext JS 어플리케이션은 <code>Application</code> class의 인스턴스로부터 시작.</p>

<p>이 class는 <code>app.js</code>에 의해 인스턴스화 가능한지 시험되며 실행 가능 상태가 됨.</p>

<p>아래 Application.js의 내용은 Sencha Cmd가 자동으로 생성한 것:</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="nx">Ext</span><span class="p">.</span><span class="nx">define</span><span class="p">(</span><span class="dl">'</span><span class="s1">MyApp.Application</span><span class="dl">'</span><span class="p">,</span> <span class="p">{</span>
    <span class="na">extend</span><span class="p">:</span> <span class="dl">'</span><span class="s1">Ext.app.Application</span><span class="dl">'</span><span class="p">,</span>

    <span class="na">name</span><span class="p">:</span> <span class="dl">'</span><span class="s1">MyApp</span><span class="dl">'</span><span class="p">,</span>

    <span class="na">stores</span><span class="p">:</span> <span class="p">[</span>
        <span class="c1">// TODO: add global/shared stores here</span>
    <span class="p">],</span>

    <span class="na">launch</span><span class="p">:</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
        <span class="c1">// TODO - Launch the application</span>
    <span class="p">},</span>

    <span class="na">onAppUpdate</span> <span class="p">:</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
        <span class="nx">Ext</span><span class="p">.</span><span class="nx">Msg</span><span class="p">.</span><span class="nx">confirm</span><span class="p">(</span><span class="dl">'</span><span class="s1">Applicaton Update</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">This application has an update, reload?</span><span class="dl">'</span><span class="p">,</span>
            <span class="kd">function</span><span class="p">(</span><span class="nx">choice</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">if</span><span class="p">(</span><span class="nx">choice</span> <span class="o">===</span> <span class="dl">'</span><span class="s1">yes</span><span class="dl">'</span><span class="p">)</span> <span class="p">{</span>
                    <span class="nb">window</span><span class="p">.</span><span class="nx">location</span><span class="p">.</span><span class="nx">reload</span><span class="p">();</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">);</span>
    <span class="p">}</span>
<span class="p">});</span>
</code></pre></div>
<p><code>Application</code> 클래스:</p>

<ul>
<li>어플리케이션의 Global 설정. (namespace, 공유 store 등을 포함)</li>
</ul>

<hr>

<h2 id="views">Views</h2>

<p>Ext.Component의 서브 클래스인 컴포넌트 그 이상도 그 이하도 아니라고 할 수 있음.</p>

<p>어플리케이션의 모든 비주얼적 측면을 포함.</p>

<p>만약 이 초기형태의 어플리케이션이 갖는 "classic/src/view/main/Main.js" 파일을 열어 본다면 다음과 같을 것:</p>

<ul>
<li><p>어플리케이션 로직이 포함되어 있지 않은 점에 주목.</p></li>
<li><p>뷰에 관련한 모든 로직은 뷰 컨트롤러에 포함되어야 하며, 다음 섹션에서 상세.</p></li>
<li><p>이 뷰에서 주목해야할 두가지는 controller와 viewModel 설정.</p></li>
</ul>

<p>그 다음으로 주목할 뷰는 "List" 뷰로서 classic/src/main/view/List에서 찾을 수 있다.</p>

<h3 id="controller-config">Controller Config</h3>

<p>뷰에 대한 ViewController를 지정할 수 있도록 한다.</p>

<p>ViewController가 뷰에 대해 지정되면 event handler러와 reference를 위한 컨테이너로 변화하게 되는데, 이러한 사실은 결국 ViewController와 View에서 이벤트를 발생시키는 컴포넌트가 1:1 관계를 갖는다는 뜻.</p>

<h3 id="viewmodel-config">ViewModel Config</h3>

<p>View에 대한 ViewModel을 지정하는 것.</p>

<p>ViewModel은 컴포넌트와 하위 View에 대한 데이터를 제공하는 역할을 담당.</p>

<p>ViewModel에 담긴 데이터는 컴포넌트와 바인딩 설정에 따라 화면에 전시되거나 편집될 목적으로 사용되는 것이 일반적.</p>

<hr>

<h2 id="controllers">Controllers</h2>

<p>MainController.js:</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="nx">Ext</span><span class="p">.</span><span class="nx">define</span><span class="p">(</span><span class="dl">'</span><span class="s1">MyApp.view.main.MainController</span><span class="dl">'</span><span class="p">,</span> <span class="p">{</span>
    <span class="na">extend</span><span class="p">:</span><span class="dl">'</span><span class="s1">Ext.app.ViewController</span><span class="dl">'</span><span class="p">,</span>

    <span class="na">alias</span><span class="p">:</span> <span class="dl">'</span><span class="s1">controller.main</span><span class="dl">'</span><span class="p">,</span>

    <span class="na">onItemSelected</span><span class="p">:</span> <span class="kd">function</span><span class="p">(</span><span class="nx">sender</span><span class="p">,</span> <span class="nx">record</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">Ext</span><span class="p">.</span><span class="nx">Msg</span><span class="p">.</span><span class="nx">confirm</span><span class="p">(</span><span class="dl">'</span><span class="s1">Confirm</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">Are you sure?</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">onConfirm</span><span class="dl">'</span><span class="p">,</span> <span class="k">this</span><span class="p">);</span>
    <span class="p">},</span>

    <span class="na">onConfirm</span><span class="p">:</span> <span class="kd">function</span><span class="p">(</span><span class="nx">choice</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">choice</span> <span class="o">===</span> <span class="dl">'</span><span class="s1">yes</span><span class="dl">'</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">//do something</span>
        <span class="p">}</span><span class="nx">tk</span>
    <span class="p">}</span>
<span class="p">});</span>
</code></pre></div>
<ul>
<li>Controller는 별다른 특별한 설정이 없이 이벤트를 처리할 준비됨.</li>
</ul>

<p>이런 점은 어플리케이션에 매우 쉽게 로직을 추가 가능.</p>

<ul>
<li>onItemSelected 함수에 필요한 모든 것은 여기에 구현하면 되는데,</li>
</ul>

<p>바로 컨트롤러가 뷰와 1-대-1의 관계로 대응하기 때문이다.</p>

<p>ViewController 목적:</p>

<ul>
<li><p>"listeners"와 "reference" 설정을 이용한 View와 연결.</p></li>
<li><p>연결된 ViewController를 자동으로 관리함으로서 View의 생명주기를 연장.</p></li>
<li><p>인스턴스 생성부터 소멸에 이르기까지 Ext.app.ViewController는 컴포넌트와 이를 참조하는 ViewController를 묶어주는데 같은 View 클래스의 두번째 인스턴스는 자신만의 ViewController 인스턴스를 갖게 됨.</p></li>
<li><p>이러한 View가 소멸될 때, 연결된 ViewController 인스턴스 역시 같이 소멸됨.</p></li>
<li><p>중첩된 View의 직관성을 위한 추상화 제공.</p></li>
</ul>

<hr>

<h2 id="viewmodels">ViewModels</h2>

<p>app/view/main/MainModel.js:</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="nx">Ext</span><span class="p">.</span><span class="nx">define</span><span class="p">(</span><span class="dl">'</span><span class="s1">MyApp.view.main.MainModel</span><span class="dl">'</span><span class="p">,</span> <span class="p">{</span>
    <span class="na">extend</span><span class="p">:</span> <span class="dl">'</span><span class="s1">Ext.app.ViewModel</span><span class="dl">'</span><span class="p">,</span>

    <span class="na">alias</span> <span class="p">:</span> <span class="dl">'</span><span class="s1">viewmodel.main</span><span class="dl">'</span><span class="p">,</span>

    <span class="na">data</span><span class="p">:{</span>
        <span class="na">name</span><span class="p">:</span><span class="dl">'</span><span class="s1">MyApp</span><span class="dl">'</span><span class="p">,</span>
        <span class="na">loremIpsum</span> <span class="p">:</span> <span class="dl">'</span><span class="s1">생략</span><span class="dl">'</span>
    <span class="p">}</span>
    <span class="c1">//TODO - add data, formulas and/or method to support your view</span>
<span class="p">});</span>
</code></pre></div>
<p>데이터 객체를 관리하는 클래스.</p>

<p>View가 사용할 데이터를 바인딩하고 데이터가 수정되었을 때 알리는 역할을 수행.</p>

<p>레퍼런스를 이용해서 View에 연결.</p>

<p>자식 View는 간단하게 부모 ViewModel의 데이터를 "상속" 가능.</p>

<ul>
<li>ViewModel이 View와 연결되어 있기 때문에 컴포넌트 계층구조의 조상 컴포넌트에 의해 소유된 상위 부모 ViewModel과 연결되는 것 역시 가능.</li>
</ul>

<p>Main.js의 <code>viewModel</code> 설정을 이용해서 View와 ViewModel의 연결을 생성했었다.</p>

<p>이 연결은 viewModel 로부터 View로 선언적인 형태로서 데이터를 자동으로 설정하기 위한 Setter와 설정을 바인딩할 수 있도록 함.</p>

<p>MainModel.js에서 인라인 코딩 되어 있는 데이터를 참고하라. 이 예는 데이터는 어느 곳이나 있을 수 있고 어디에서라도 올 수 있다는 것을 의미한다. 데이터는 AJAX, REST 등등 다양한 종류의 프록시로부터 제공될 수 있을 것.</p>

<hr>

<h2 id="models-and-stores">Models and Stores</h2>

<p>모델과 스토어는 어플리케이션에서 정보의 게이트웨이 역할을 담당.</p>

<p>대부분의 데이터는 두 class에 의해 "모델화"되거나, 조직화 되거나 또는 보내고 받게 됨.</p>

<h3 id="model">Model</h3>

<p>Ext.data.Model은 어플리케이션에서 지속 가능한 모든 형태의 데이터를 대표.
각 Model은 어플리케이션에 대해 "모델" 데이터를 제공하기 위한 필드와 함수를 갖음.
Model은 가장 일반적으로 스토어와 결합하여 사용, 스토어는 그리드, 트리 및 차트와 같이 데이터와 함께 사용되는 컴포넌트에 의해 사용.</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="c1">// myapp/app/model/User.js</span>

<span class="nx">Ext</span><span class="p">.</span><span class="nx">define</span><span class="p">(</span><span class="dl">'</span><span class="s1">MyApp.model.User</span><span class="dl">'</span><span class="p">,</span> <span class="p">{</span>
    <span class="na">extend</span><span class="p">:</span><span class="dl">'</span><span class="s1">Ext.data.Model</span><span class="dl">'</span><span class="p">,</span>
    <span class="na">fields</span><span class="p">:</span> <span class="p">[</span>
        <span class="p">{</span><span class="na">name</span><span class="p">:</span><span class="dl">'</span><span class="s1">name</span><span class="dl">'</span><span class="p">,</span> <span class="na">type</span><span class="p">:</span><span class="dl">'</span><span class="s1">string</span><span class="dl">'</span><span class="p">},</span>
        <span class="p">{</span><span class="na">name</span><span class="p">:</span><span class="dl">'</span><span class="s1">age</span><span class="dl">'</span><span class="p">,</span> <span class="na">type</span><span class="p">:</span><span class="dl">'</span><span class="s1">int</span><span class="dl">'</span><span class="p">}</span>
    <span class="p">]</span>
<span class="p">});</span>
</code></pre></div>
<p>namespace 고려해서 myapp/app/model/User.js 파일로 저장되어야 함.</p>

<h4 id="fields">fields</h4>

<p>Ext.data.Model은 담고 있는 값을 의미하는 레코드 또는 "fields"라고 불리는 속성을 기술한다. 모델 클래스는 이러한 필드를 "fields" 설정을 이용해서 정의.</p>

<p>비선언 경우: 자동 데이터 인식 후 선언</p>

<p>선언 경우:</p>

<ul>
<li><p>Validation</p></li>
<li><p>기본 값</p></li>
<li><p>변환 함수</p></li>
</ul>

<h3 id="stores">Stores</h3>

<p>클라이언트 측면에서 레코드(모델 클래스의 인스턴스)의 캐시.</p>

<p>담고 있는 데이터에 대한 정렬(Sorting), 필터링 및 질의(Querying)기능을 제공.</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="c1">// myapp/app/store/User.js:</span>

<span class="nx">Ext</span><span class="p">.</span><span class="nx">define</span><span class="p">(</span><span class="dl">'</span><span class="s1">MyApp.store.Users</span><span class="dl">'</span><span class="p">,</span> <span class="p">{</span>
    <span class="na">extend</span><span class="p">:</span> <span class="dl">'</span><span class="s1">Ext.data.Store</span><span class="dl">'</span><span class="p">,</span>
    <span class="na">alias</span> <span class="p">:</span> <span class="dl">'</span><span class="s1">store.users</span><span class="dl">'</span><span class="p">,</span>
    <span class="na">model</span><span class="p">:</span><span class="dl">'</span><span class="s1">MyApp.model.User</span><span class="dl">'</span><span class="p">,</span>
    <span class="na">data</span><span class="p">:[</span>
        <span class="p">{</span><span class="na">firstName</span><span class="p">:</span><span class="dl">'</span><span class="s1">Sech</span><span class="dl">'</span><span class="p">,</span> <span class="na">age</span><span class="p">:</span><span class="dl">'</span><span class="s1">34</span><span class="dl">'</span><span class="p">},</span>
        <span class="p">{</span><span class="na">firstName</span><span class="p">:</span><span class="dl">'</span><span class="s1">Scott</span><span class="dl">'</span><span class="p">,</span> <span class="na">age</span><span class="p">:</span><span class="dl">'</span><span class="s1">72</span><span class="dl">'</span><span class="p">},</span>
        <span class="p">{</span><span class="na">firstName</span><span class="p">:</span><span class="dl">'</span><span class="s1">Gary</span><span class="dl">'</span><span class="p">,</span> <span class="na">age</span><span class="p">:</span><span class="dl">'</span><span class="s1">19</span><span class="dl">'</span><span class="p">},</span>
        <span class="p">{</span><span class="na">firstName</span><span class="p">:</span><span class="dl">'</span><span class="s1">Capybara</span><span class="dl">'</span><span class="p">,</span><span class="na">age</span><span class="p">:</span><span class="dl">'</span><span class="s1">208</span><span class="dl">'</span><span class="p">}</span>
    <span class="p">]</span>
<span class="p">});</span>
</code></pre></div>
<p>Application.js의 <code>stores</code> 설정을 통해 store(=Users)를 글로벌 인스턴스로 설정:</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="c1">// Application.js:</span>

<span class="nx">stores</span><span class="p">:</span> <span class="p">[</span>
    <span class="dl">'</span><span class="s1">Users</span><span class="dl">'</span>
<span class="p">],</span>
</code></pre></div>
<p>데이터는 대부분의 실제 어플리케이션을 구현할 때는 모델 또는 스토어에서 프록시를 이용해 데이터를 획득.
프록시는 데이터 제공자와 어플리케이션간에 데이터 전송을 수행.</p>

<p>모델, 스토어 및 데이터 제공자 참조: [Data Guide]</p>

<h1 id="reference"><em>Reference</em></h1>

<h2 id="url">URL</h2>

<ul>
<li><a href="http://docs.sencha.com/extjs/6.2.1/guides/application_architecture/developing_for_multiple_screens_and_environments.html" rel="nofollow" target="_blank">http://docs.sencha.com/extjs/6.2.1/guides/application_architecture/developing_for_multiple_screens_and_environments.html</a></li>
</ul>

</div>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/blog/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">Portal2312&#39;s blog</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">Portal2312&#39;s blog</li><li><a class="u-email" href="mailto:portal2312@gmail.com">portal2312@gmail.com</a></li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/portal2312"><svg class="svg-icon"><use xlink:href="/blog/assets/minima-social-icons.svg#github"></use></svg> <span class="username">portal2312</span></a></li><li><a href="https://www.twitter.com/portal2312"><svg class="svg-icon"><use xlink:href="/blog/assets/minima-social-icons.svg#twitter"></use></svg> <span class="username">portal2312</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>Welcome to my blog.</p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
