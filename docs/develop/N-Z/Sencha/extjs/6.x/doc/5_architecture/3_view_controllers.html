<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.6.1 -->
<title>ViewControlers in ExtJS | Portal2312&#39;s blog</title>
<meta name="generator" content="Jekyll v3.8.6" />
<meta property="og:title" content="ViewControlers in ExtJS" />
<meta name="author" content="mkkim" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="MVC 어플리케이션 개선을 위한 ViewController 뿐만 아니라 ViewModels와 MVVM을 지원." />
<meta property="og:description" content="MVC 어플리케이션 개선을 위한 ViewController 뿐만 아니라 ViewModels와 MVVM을 지원." />
<link rel="canonical" href="/blog/docs/develop/N-Z/Sencha/extjs/6.x/doc/5_architecture/3_view_controllers.html" />
<meta property="og:url" content="/blog/docs/develop/N-Z/Sencha/extjs/6.x/doc/5_architecture/3_view_controllers.html" />
<meta property="og:site_name" content="Portal2312&#39;s blog" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2019-12-02T16:38:51+09:00" />
<script type="application/ld+json">
{"description":"MVC 어플리케이션 개선을 위한 ViewController 뿐만 아니라 ViewModels와 MVVM을 지원.","headline":"ViewControlers in ExtJS","dateModified":"2019-12-02T16:38:51+09:00","datePublished":"2019-12-02T16:38:51+09:00","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"/blog/docs/develop/N-Z/Sencha/extjs/6.x/doc/5_architecture/3_view_controllers.html"},"url":"/blog/docs/develop/N-Z/Sencha/extjs/6.x/doc/5_architecture/3_view_controllers.html","author":{"@type":"Person","name":"mkkim"},"@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href='/blog/assets/main.css'><link type="application/atom+xml" rel="alternate" href="/blog/feed.xml" title="Portal2312's blog" /><script>
if(!(window.doNotTrack === "1" || navigator.doNotTrack === "1" || navigator.doNotTrack === "yes" || navigator.msDoNotTrack === "1")) {
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-113063601-1', 'auto');
  ga('send', 'pageview');
}
</script>
  
<script src='/blog/dist/js/common.bundle.js'></script>
</head>
<body><header class="site-header" role="banner">
  <div class="wrapper">
    <a class="site-title" rel="author" href="/blog/">Portal2312&#39;s blog</a>
    <nav class="site-nav">
    <input type="checkbox" id="nav-trigger" class="nav-trigger" />
    <label for="nav-trigger">
      <span class="menu-icon">
        <svg viewBox="0 0 18 15" width="18px" height="15px">
          <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
        </svg>
      </span>
    </label>

    <div class="trigger"><a class="page-link" href="/blog/about.html">
            About
          </a><a class="page-link" href="/blog/posts.html">
            Posts
          </a><a class="page-link" href="/blog/history.html">
            History
          </a><a class="page-link" href="/blog/docs/index.html">
            Docs
          </a></div>
  </nav>
  </div>
  <div class="scroll-indicator-container">
  <div class="scroll-indicator-bar" id="scrollIndicatorBar"></div>
</div>

</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <h1>ViewControlers in ExtJS</h1>

  <div>
    <h2>Table of contents</h2>
    <ul class="section-nav">
<li class="toc-entry toc-h2"><a href="#application-level-controllers">Application-level Controllers</a>
<ul>
<li class="toc-entry toc-h3"><a href="#challenges">Challenges</a></li>
</ul>
</li>
<li class="toc-entry toc-h2"><a href="#viewcontrollers">ViewControllers</a>
<ul>
<li class="toc-entry toc-h3"><a href="#listeners">Listeners</a></li>
<li class="toc-entry toc-h3"><a href="#reference">Reference</a></li>
<li class="toc-entry toc-h3"><a href="#encapsulatio">Encapsulatio (추상화)</a></li>
<li class="toc-entry toc-h3"><a href="#listeners-and-event-domains">Listeners and Event Domains</a></li>
<li class="toc-entry toc-h3"><a href="#life-cycle">Life cycle</a></li>
</ul>
</li>
</ul><p>MVC 어플리케이션 개선을 위한 ViewController 뿐만 아니라 ViewModels와 MVVM을 지원.</p>

<p>이러한 발전에서 가장 괄목할 만한 점은 이러한 아키텍처의 선택이 상호 배타적이지 않기 때문에 각각 차례대로 사용하거나 혹은 혼합해서 사용할 수도 있다는 점이다.</p>

<h2 id="application-level-controllers">
<a class="anchor" href="#application-level-controllers" aria-hidden="true"><span class="octicon octicon-link"></span></a>Application-level Controllers</h2>

<p>Controller</p>

<p>Ext.app.Controller를 파생한 클래스로 CSS와 유사한 선택자.</p>

<p>즉, 컴포넌트 쿼리를 사용하여 컴포넌트를 찾고 해당 컴포넌트의 이벤트를 처리.</p>

<p>또한 컴포넌트 인스턴스를 선택하거나 넘겨받기 위해 "refs"를 사용.</p>

<p>어플리케이션 실행시 생성되어 어플리케이션이 실행되는 동안 유지.</p>

<p>Controller의 생명주기 동안 View에서 발생하는 이벤트들이 컨트롤러를 통해 제어.</p>

<p>관리하는 뷰는 다중 인스턴스가 될 수 있음.</p>

<h3 id="challenges">
<a class="anchor" href="#challenges" aria-hidden="true"><span class="octicon octicon-link"></span></a>Challenges</h3>

<p>대형 어플리케이션에서 위와 같은 기술들은 당면한 몇가지 문제:</p>

<ul>
<li><p>뷰와 컨트롤러는 각각의 다른 개발부서에서 코딩하고 향후 어플리케이션 수준에서 통합할 가능성이 높음.</p></li>
<li><p>해당하는 View 만 반응하도록 코딩하기는 어플리케이션의 크기가 커질 수록 어려워 질것.</p></li>
<li><p>나아가 개발자들은 어플리케이션 시작 시 한정된 수의 컨트롤러만 생성하도록 제한 원함.</p></li>
<li><p>조금만 노력하면 지연된 컨트롤러 생성(lazily creating controller)이 가능하지만, 이들은 destory 될 수 없어서 더 이상 필요없는 상황이 되어도 소멸 되지 않고 남아있게 됨.</p></li>
</ul>

<hr>

<h2 id="viewcontrollers">
<a class="anchor" href="#viewcontrollers" aria-hidden="true"><span class="octicon octicon-link"></span></a>ViewControllers</h2>

<p><code>Ext.app.ViewController</code> 위 문제를 해결하기 위한 방안의 새로운 controller.</p>

<p>사용:</p>

<ul>
<li><p><code>listener</code>와 <code>reference</code> 설정을 사용하여 뷰와 연결을 간소화 함</p></li>
<li><p>연결된 뷰 컨트롤러의 자동관리를 통한 효율적 View의 생명주기 관리</p></li>
<li><p>관리하는 View와 1-대-1 관계로 연결된 뷰 컨트롤러를 통해 복잡성 제거</p></li>
<li><p>중첩된 View의 신뢰성 제고를 위한 캡슐화 지원</p></li>
<li><p>컴포넌트 선택 및 연결된 View의 계층에 상관없는 이벤트 리스닝 유지</p></li>
</ul>

<h3 id="listeners">
<a class="anchor" href="#listeners" aria-hidden="true"><span class="octicon octicon-link"></span></a>Listeners</h3>

<p>예:</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="nx">Ext</span><span class="p">.</span><span class="nx">define</span><span class="p">(</span><span class="dl">'</span><span class="s1">MyApp.view.foo.Foo</span><span class="dl">'</span><span class="p">,</span> <span class="p">{</span>
    <span class="na">extend</span><span class="p">:</span> <span class="dl">'</span><span class="s1">Ext.panel.Panel</span><span class="dl">'</span><span class="p">,</span>
    <span class="na">xtype</span><span class="p">:</span> <span class="dl">'</span><span class="s1">foo</span><span class="dl">'</span><span class="p">,</span>
    <span class="na">controller</span><span class="p">:</span> <span class="dl">'</span><span class="s1">foo</span><span class="dl">'</span><span class="p">,</span>

    <span class="na">items</span><span class="p">:[{</span>
        <span class="na">xtype</span><span class="p">:</span> <span class="dl">'</span><span class="s1">textfield</span><span class="dl">'</span><span class="p">,</span>
        <span class="na">fieldLabel</span><span class="p">:</span> <span class="dl">'</span><span class="s1">Bar</span><span class="dl">'</span><span class="p">,</span>
        <span class="na">listeners</span><span class="p">:</span> <span class="p">{</span>
            <span class="na">change</span><span class="p">:</span> <span class="dl">'</span><span class="s1">onBarChange</span><span class="dl">'</span> <span class="c1">//no scope given here</span>
        <span class="p">}</span>
    <span class="p">}]</span>
<span class="p">});</span>

<span class="nx">Ext</span><span class="p">.</span><span class="nx">define</span><span class="p">(</span><span class="dl">'</span><span class="s1">MyApp.view.foo.FooController</span><span class="dl">'</span><span class="p">,{</span>
    <span class="na">extend</span><span class="p">:</span> <span class="dl">'</span><span class="s1">Ext.app.ViewController</span><span class="dl">'</span><span class="p">,</span>
    <span class="na">alias</span><span class="p">:</span> <span class="dl">'</span><span class="s1">controller.foo</span><span class="dl">'</span><span class="p">,</span>

    <span class="na">onBarChange</span><span class="p">:</span> <span class="kd">function</span><span class="p">(</span><span class="nx">barTextField</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">//called by 'change' event</span>
    <span class="p">}</span>
<span class="p">});</span>
</code></pre></div>
<p><code>listeners</code></p>

<ul>
<li><p>"scope"를 특정하지 않는 "onBarChange"라는 이름의 이벤트 핸들러를 보여줌.</p></li>
<li><p>내부적으로 이벤트 시스템은 Bar textfield의 기본범위(scope)를 해당 뷰 컨트롤러 자체로 해석.</p></li>
</ul>

<p>예전부터 <code>listener</code> 설정은 컴포넌트 생성자에 의해 사용되는 것으로 예약되어 있었기 때문에,
어떻게 해서 View가 자체적인 이벤트를 리스닝할 수 있는지
또는 자체적인 base 클래스에 의한 이벤트를 알아챌 수 있는지 궁금 함.</p>

<p>해답은 바로 명시적 범위를 사용하는 것.</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="nx">Ext</span><span class="p">.</span><span class="nx">define</span><span class="p">(</span><span class="dl">'</span><span class="s1">MyApp.view.foo.Foo</span><span class="dl">'</span><span class="p">,</span> <span class="p">{</span>
    <span class="na">extend</span><span class="p">:</span> <span class="dl">'</span><span class="s1">Ext.panel.Panel</span><span class="dl">'</span><span class="p">,</span>
    <span class="na">xtype</span><span class="p">:</span> <span class="dl">'</span><span class="s1">foo</span><span class="dl">'</span><span class="p">,</span>
    <span class="na">controller</span><span class="p">:</span> <span class="dl">'</span><span class="s1">foo</span><span class="dl">'</span><span class="p">,</span>

    <span class="na">listeners</span><span class="p">:</span> <span class="p">{</span>
        <span class="na">collapse</span><span class="p">:</span> <span class="dl">'</span><span class="s1">onCollapse</span><span class="dl">'</span><span class="p">,</span>
        <span class="na">scope</span><span class="p">:</span> <span class="dl">'</span><span class="s1">controller</span><span class="dl">'</span>
    <span class="p">},</span>

    <span class="na">items</span><span class="p">:</span> <span class="p">[{</span>
        <span class="p">...</span>
    <span class="p">}]</span>
<span class="p">});</span>
</code></pre></div>
<p>위 예제는 Ext JS의 두가지 새로운 기능을 활용, <code>named scope</code>와 <code>declarative listener</code>(선언적 리스너) 이다.</p>

<p>named scope에 적절한 두 값: <code>this</code>, <code>controller</code></p>

<p>MVC 어플리케이션 코드를 작성할 때, 항상 View의 뷰 컨트롤러를 뜻하는 <code>controller</code> 사용.</p>

<p>(인스턴스 생성된 View의 뷰 컨트롤러가 아님)</p>

<p>View가 Ext.Component의 한 종류이기 때문에 이 View를 "xtype"으로 지정,
위 예제의 View가 내부 아이템으로 textfield를 생성하는 것과 같은 방식으로 다른 View가 지금 사용하는 뷰의 인스턴스를 생성할 수 있게 허용. 예:</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="nx">Ext</span><span class="p">.</span><span class="nx">define</span><span class="p">(</span><span class="dl">'</span><span class="s1">MyApp.view.bar.Bar</span><span class="dl">'</span><span class="p">,</span> <span class="p">{</span>
    <span class="na">extend</span><span class="p">:</span><span class="dl">'</span><span class="s1">Ext.panel.Panel</span><span class="dl">'</span><span class="p">,</span>
    <span class="na">xtype</span><span class="p">:</span><span class="dl">'</span><span class="s1">bar</span><span class="dl">'</span><span class="p">,</span>
    <span class="na">controller</span><span class="p">:</span><span class="dl">'</span><span class="s1">bar</span><span class="dl">'</span><span class="p">,</span>

    <span class="na">items</span><span class="p">:[{</span>
        <span class="na">xtype</span><span class="p">:</span><span class="dl">'</span><span class="s1">foo</span><span class="dl">'</span><span class="p">,</span>
        <span class="na">listeners</span><span class="p">:{</span>
            <span class="na">collapse</span><span class="p">:</span><span class="dl">'</span><span class="s1">onCollapse</span><span class="dl">'</span>
        <span class="p">}</span>
    <span class="p">}]</span>
<span class="p">});</span>
</code></pre></div>
<p>위에서는 Bar View는 Foo의 인스턴스를 자신의 한 아이템으로 생성.
나아가 Foo 뷰에서 그랬던 것처럼 collapse 이벤트 리스닝을 하고 있다.
Foo 뷰에 의해 선언된 리스너는 Foo의 뷰 컨트롤러에서 처리할 것이고,
Bar 뷰에서 발생한 이벤트는 Bar의 뷰 컨트롤러에서 담당하게 될 것이다.</p>

<h3 id="reference">
<a class="anchor" href="#reference" aria-hidden="true"><span class="octicon octicon-link"></span></a>Reference</h3>

<p>Controller 로직을 작성할 때 보통 가장 애매한 것 중에 하나가 특정 처리를 완료하기
위해 필요한 컴포넌트를 찾아내는 것.</p>

<p>예:</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="nx">Ext</span><span class="p">.</span><span class="nx">define</span><span class="p">(</span><span class="dl">'</span><span class="s1">MyApp.view.foo.Foo</span><span class="dl">'</span><span class="p">,</span> <span class="p">{</span>
    <span class="na">extend</span><span class="p">:</span> <span class="dl">'</span><span class="s1">Ext.panel.Panel</span><span class="dl">'</span><span class="p">,</span>
    <span class="na">xtype</span><span class="p">:</span> <span class="dl">'</span><span class="s1">foo</span><span class="dl">'</span><span class="p">,</span>
    <span class="na">controller</span><span class="p">:</span> <span class="dl">'</span><span class="s1">foo</span><span class="dl">'</span><span class="p">,</span>

    <span class="na">tbar</span><span class="p">:</span> <span class="p">[{</span>
        <span class="na">xtype</span><span class="p">:</span> <span class="dl">'</span><span class="s1">button</span><span class="dl">'</span><span class="p">,</span>
        <span class="na">text</span><span class="p">:</span> <span class="dl">'</span><span class="s1">Add</span><span class="dl">'</span><span class="p">,</span>
        <span class="na">handler</span><span class="p">:</span> <span class="dl">'</span><span class="s1">onAdd</span><span class="dl">'</span>
    <span class="p">}],</span>

    <span class="na">items</span><span class="p">:</span> <span class="p">[{</span>
        <span class="na">xtype</span><span class="p">:</span> <span class="dl">'</span><span class="s1">grid</span><span class="dl">'</span><span class="p">,</span>
        <span class="p">...</span>
    <span class="p">}]</span>
<span class="p">});</span>

<span class="nx">Ext</span><span class="p">.</span><span class="nx">define</span><span class="p">(</span><span class="dl">'</span><span class="s1">MyApp.view.foo.FooController</span><span class="dl">'</span><span class="p">,</span> <span class="p">{</span>
    <span class="na">extend</span><span class="p">:</span> <span class="dl">'</span><span class="s1">Ext.app.ViewController</span><span class="dl">'</span><span class="p">,</span>
    <span class="na">alias</span><span class="p">:</span> <span class="dl">'</span><span class="s1">controller.foo</span><span class="dl">'</span><span class="p">,</span>

    <span class="na">onAdd</span><span class="p">:</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
        <span class="c1">// ... get the grid and add a record ...</span>
    <span class="p">}</span>
<span class="p">});</span>
</code></pre></div>
<p>Grid 컴포넌트 가져오기:</p>

<p>어떤 방법이든 Grid 컴포넌트를 고유하게 식별 가능, 인식 가능한 어떤 속성을 부여하도록 요구.</p>

<p>예전의 기법:</p>

<ul>
<li>
<p>"id" 설정.</p>

<ul>
<li>장점: 빠른 탐색이 가능.</li>
<li>단점: 전체 어플리케이션과 DOM에서 유일한 식별자만 됨(제약), 종종 실현 안됨.</li>
</ul>
</li>
<li><p>Ext.getCmp를 이용.</p></li>
<li><p>"itemId" 설정과 "refs" 도는 다른 컴포넌트 쿼리 메서드를 이용.</p></li>
<li><p>"itemId" 사용하고 컴포넌트 쿼리를 활용하는 방법은 좀더 유연하지만 원하는 컴포넌트를 위한 탐색이 필요.</p></li>
</ul>

<p>Grid에 "reference" 설정을 추가하고 필요할 때 "lookupReference" 메서드 사용.</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="nx">Ext</span><span class="p">.</span><span class="nx">define</span><span class="p">(</span><span class="dl">'</span><span class="s1">MyApp.view.foo.Foo</span><span class="dl">'</span><span class="p">,</span> <span class="p">{</span>
    <span class="na">extend</span><span class="p">:</span> <span class="dl">'</span><span class="s1">Ext.panel.Panel</span><span class="dl">'</span><span class="p">,</span>
    <span class="na">xtype</span><span class="p">:</span> <span class="dl">'</span><span class="s1">foo</span><span class="dl">'</span><span class="p">,</span>
    <span class="na">controller</span><span class="p">:</span> <span class="dl">'</span><span class="s1">foo</span><span class="dl">'</span><span class="p">,</span>

    <span class="na">tbar</span><span class="p">:</span> <span class="p">[{</span>
        <span class="na">xtype</span><span class="p">:</span> <span class="dl">'</span><span class="s1">button</span><span class="dl">'</span><span class="p">,</span>
        <span class="na">text</span><span class="p">:</span> <span class="dl">'</span><span class="s1">Add</span><span class="dl">'</span><span class="p">,</span>
        <span class="na">handler</span><span class="p">:</span> <span class="dl">'</span><span class="s1">onAdd</span><span class="dl">'</span>
    <span class="p">}],</span>

    <span class="na">items</span><span class="p">:</span> <span class="p">[{</span>
        <span class="na">xtype</span><span class="p">:</span> <span class="dl">'</span><span class="s1">grid</span><span class="dl">'</span><span class="p">,</span>
        <span class="na">reference</span><span class="p">:</span> <span class="dl">'</span><span class="s1">fooGrid</span><span class="dl">'</span>  <span class="c1">// XXX: reference 선언</span>
        <span class="p">...</span>
    <span class="p">}]</span>
<span class="p">});</span>

<span class="nx">Ext</span><span class="p">.</span><span class="nx">define</span><span class="p">(</span><span class="dl">'</span><span class="s1">MyApp.view.foo.FooController</span><span class="dl">'</span><span class="p">,</span> <span class="p">{</span>
    <span class="na">extend</span><span class="p">:</span> <span class="dl">'</span><span class="s1">Ext.app.ViewController</span><span class="dl">'</span><span class="p">,</span>
    <span class="na">alias</span><span class="p">:</span> <span class="dl">'</span><span class="s1">controller.foo</span><span class="dl">'</span><span class="p">,</span>

    <span class="na">onAdd</span><span class="p">:</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
        <span class="kd">var</span> <span class="nx">grid</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">lookupReference</span><span class="p">(</span><span class="dl">'</span><span class="s1">fooGrid</span><span class="dl">'</span><span class="p">);</span>  <span class="c1">// XXX: reference 찾기</span>
    <span class="p">}</span>
<span class="p">});</span>
</code></pre></div>
<p>이것은 "fooGrid"의 itemId를 할당하고 난후 "this.down('#fooGrid')"를 수행하는 것과 유사.</p>

<p>차이점은 잘드러나지 않지만, 분명히 매우 다르다.</p>

<p>첫번째로 <code>reference</code> 설정은 컴포넌트와 이를 소유하는 View를 스스로 등록하도록 인도.
(예제에서는 뷰 컨트롤러의 존재로 식별 됨)</p>

<p>두번째, <code>lookupReference</code> 메서드는 레퍼런스의 갱신이 필요한지 알기 위해 캐시를 찾아본다.
만약 모든 것이 좋다면, 이 메서드는 캐시로부터 레퍼런스를 리턴한다.</p>

<p>이 과정을 설명하기 위한 pseudo 코드:</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="nx">lookupReference</span><span class="p">:</span> <span class="p">(</span><span class="nx">reference</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">cache</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">references</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">cache</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">Ext</span><span class="p">.</span><span class="nx">fixReferences</span><span class="p">();</span> <span class="c1">// fix all references</span>
        <span class="nx">cache</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">references</span><span class="p">;</span> <span class="c1">// now the cache is valid</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">cache</span><span class="p">[</span><span class="nx">reference</span><span class="p">];</span>
<span class="p">}</span>
</code></pre></div>
<p>다른 말로 표현하면, 컨테이너에 아이템을 추가 또는 제거에 따른 링크 손상이 없고, 탐색이 필요 없다는 것.</p>

<h3 id="encapsulatio">
<a class="anchor" href="#encapsulatio" aria-hidden="true"><span class="octicon octicon-link"></span></a>Encapsulatio (추상화)</h3>

<p>controller refs 설정을 이용한 선택자 사용은 매우 유연하지만 동시에 명백한 위험도 존재.</p>

<p>선택자의 실상은 컴포넌트 계층구조의 모든 레벨에 걸쳐 모든 것을 다 검사하다는 것으로 매우 강력하면서도 실수하기 쉽다는 것이다.</p>

<p>예: 컨트롤러는 분리된 환경에서는 100% 독립적으로 주어진 일을 처리하지만 새로운 뷰가 존재할 경우 원하지 않는 일치가 발생할 수 있다.</p>

<p>이러한 문제는 확실한 연습을 통해 관리 가능하지만, <strong>listeners</strong> 와 <strong>reference</strong> 를
<strong>View Controller</strong> 와 함께 사용하게 되면 문제는 간단히 풀리기 어렵게 된다.</p>

<p>왜냐하면 <strong>listener</strong> 와 <strong>reference</strong> 설정은
오직 자체적인 <strong>View Controller</strong> 에 의해 소유되어 연결되기 때문.</p>

<p><strong>View</strong> 는 고유한 레퍼런스 값을 자유롭게 선택할 수 있으며,
그러한 이름들은 <strong>View</strong> 생성자에게 노출되지 않음.</p>

<p>유사하게, <strong>listener</strong> 는 그들을 소유한 <strong>View Controller</strong> 에 의해 처리되고,
잘못된 선택자에 의한 다른 <strong>Controller</strong> 에서 처리될 수 없도록 되어 있음.</p>

<p><strong>listener</strong> 가 적합한 선택자에게 공개되어 있는 것은 선택자 기반의 접근에
요구되는 두 메커니즘이 서로 잘 작동하기 때문이라고 할 수 있음.</p>

<p><strong>Model</strong> 의 완성을 위해 <strong>View</strong> 는 이벤트를 생성해야 함.
생성된 이벤트는 <strong>View</strong> 가 소유한 <strong>View Controller</strong> 에 의해 처리될 것.</p>

<p>아래는 <strong>View Controller</strong> 의 Helper 메서드인 <code>fireViewEvent</code>:</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="nx">Ext</span><span class="p">.</span><span class="nx">define</span><span class="p">(</span><span class="dl">'</span><span class="s1">MyApp.view.foo.FooControlller</span><span class="dl">'</span><span class="p">,</span> <span class="p">{</span>
    <span class="na">extend</span><span class="p">:</span><span class="dl">'</span><span class="s1">Ext.app.ViewController</span><span class="dl">'</span><span class="p">,</span>
    <span class="na">alias</span><span class="p">:</span><span class="dl">'</span><span class="s1">controller.foo</span><span class="dl">'</span><span class="p">,</span>

    <span class="na">onAdd</span><span class="p">:</span><span class="kd">function</span><span class="p">(){</span>
        <span class="kd">var</span> <span class="nx">record</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">MyApp</span><span class="p">.</span><span class="nx">model</span><span class="p">.</span><span class="nx">Thing</span><span class="p">();</span>
        <span class="kd">var</span> <span class="nx">grid</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">lookupReference</span><span class="p">(</span><span class="dl">'</span><span class="s1">fooGrid</span><span class="dl">'</span><span class="p">);</span>
        <span class="nx">grid</span><span class="p">.</span><span class="nx">store</span><span class="p">.</span><span class="nx">add</span><span class="p">(</span><span class="nx">record</span><span class="p">);</span>

        <span class="k">this</span><span class="p">.</span><span class="nx">fireViewEvent</span><span class="p">(</span><span class="dl">'</span><span class="s1">addrecord</span><span class="dl">'</span><span class="p">,</span><span class="k">this</span><span class="p">,</span><span class="nx">record</span><span class="p">);</span>  <span class="c1">// XXX: 추가</span>
    <span class="p">}</span>
<span class="p">});</span>
</code></pre></div>
<p><strong>View</strong> 에 <strong>listener</strong> 추가:</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="nx">Ext</span><span class="p">.</span><span class="nx">define</span><span class="p">(</span><span class="dl">'</span><span class="s1">MyApp.view.bar.Bar</span><span class="dl">'</span><span class="p">,</span> <span class="p">{</span>
    <span class="na">extend</span><span class="p">:</span> <span class="dl">'</span><span class="s1">Ext.panel.Panel</span><span class="dl">'</span><span class="p">,</span>
    <span class="na">xtype</span><span class="p">:</span> <span class="dl">'</span><span class="s1">bar</span><span class="dl">'</span><span class="p">,</span>
    <span class="na">controller</span><span class="p">:</span> <span class="dl">'</span><span class="s1">bar</span><span class="dl">'</span><span class="p">,</span>

    <span class="na">items</span><span class="p">:</span> <span class="p">[{</span>
        <span class="na">xtype</span><span class="p">:</span> <span class="dl">'</span><span class="s1">foo</span><span class="dl">'</span><span class="p">,</span>
        <span class="na">listeners</span><span class="p">:</span> <span class="p">{</span>
            <span class="na">collapse</span><span class="p">:</span> <span class="dl">'</span><span class="s1">onCollapse</span><span class="dl">'</span><span class="p">,</span>
            <span class="na">addrecord</span><span class="p">:</span> <span class="dl">'</span><span class="s1">onAddRecord</span><span class="dl">'</span>  <span class="c1">// XXX: 추가</span>
        <span class="p">}</span>
    <span class="p">}]</span>
<span class="p">});</span>
</code></pre></div>
<h3 id="listeners-and-event-domains">
<a class="anchor" href="#listeners-and-event-domains" aria-hidden="true"><span class="octicon octicon-link"></span></a>Listeners and Event Domains</h3>

<p>Ext JS 4.2</p>

<ul>
<li><p>MVC 이벤트 디스패처는 <strong>Event Domains</strong> 의 도입과 함께 사용됨.</p></li>
<li><p><strong>Event Domains</strong> 이벤트가 발사되면 이를 가로채서 선택자 매칭에 의해 제어되는</p></li>
</ul>

<p><strong>Controller</strong> 에게 이벤트를 배포.</p>

<ul>
<li>"component" <strong>Event Domains</strong> 은 다른 도메인이 제한된 선택자를 갖기 때문에</li>
</ul>

<p>전체 컴포넌트 쿼리 선택자를 갖음.</p>

<p>Ext JS 5+</p>

<ul>
<li><p>view <strong>Event Domains</strong></p></li>
<li><p>각각의 <strong>View Controller</strong> 은 view <strong>Event Domains</strong> 라</p></li>
</ul>

<p>불리는 새로운 타입의 <strong>Event Domains</strong> 의 인스턴스를 생성.</p>

<ul>
<li>
<strong>View Controller</strong> 가 속한 <strong>View</strong> 에 명시적으로 범위를 한정하여 표준으로</li>
</ul>

<p><code>listen</code>과 <code>control</code> 메서드를 사용할 수 있도록 허용.</p>

<ul>
<li>또한 자체적으로 <strong>View</strong> 를 매칭하기 위한 특별한 선택자를 추가.</li>
</ul>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="nx">Ext</span><span class="p">.</span><span class="nx">define</span><span class="p">(</span><span class="dl">'</span><span class="s1">MyApp.view.foo.FooController</span><span class="dl">'</span><span class="p">,</span> <span class="p">{</span>
    <span class="na">extend</span><span class="p">:</span> <span class="dl">'</span><span class="s1">Ext.app.ViewController</span><span class="dl">'</span><span class="p">,</span>
    <span class="na">alias</span><span class="p">:</span> <span class="dl">'</span><span class="s1">controller.foo</span><span class="dl">'</span><span class="p">,</span>

    <span class="na">control</span><span class="p">:</span> <span class="p">{</span>
        <span class="dl">'</span><span class="s1">#</span><span class="dl">'</span><span class="p">:</span> <span class="p">{</span>  <span class="c1">// matches the view itself</span>
            <span class="na">collapse</span><span class="p">:</span> <span class="dl">'</span><span class="s1">onCollapse</span><span class="dl">'</span>
        <span class="p">},</span>
        <span class="na">button</span><span class="p">:</span> <span class="p">{</span>
            <span class="na">click</span><span class="p">:</span> <span class="dl">'</span><span class="s1">onAnyButtonClick</span><span class="dl">'</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">});</span>
</code></pre></div>
<p>위 코드에서 리스너와 선택자의 중요한 차이점을 볼 수 있다.</p>

<p>"button" 선택자</p>

<ul>
<li><p>지금의 뷰 혹은 지금 뷰를 상속하는 자식 뷰에 속한 아무 버튼을 찾을 것.</p></li>
<li><p>버튼 선택자의 탐색은 상속 계층에 상관하지 않고 심지어 버튼이 4번째 상속된 View에 있을 경우라도 해당.</p></li>
</ul>

<p>다른 표현으로 하자면, 선택자 기반의 핸들러는 추상화 범위를 상관하지 않는 다는 것이다.</p>

<p>이러한 속성은 Ext.app.Controller 속성과 함께 일관되며, 제한된 상황에서 때론 유용하게 사용될 수 있다.</p>

<p><strong>Event Domain</strong></p>

<ul>
<li><p>중첩적으로 구성되며 View 계층에서 발생시키는 이벤트에 대해 효과적으로 대응.</p></li>
<li><p>이벤트가 발생 시</p></li>
</ul>

<ol>
<li><p>모든 표준 listener에게 전달</p></li>
<li><p>소유하고 있는 View Controller에게 전달</p></li>
<li><p>계층구조에 따라 부모 뷰컨트롤러에게 순차적으로 전달</p></li>
<li><p>Ext.app.Controller를 파생한 컨트롤러에 의해 처리되는 표준 "component" 이벤트 도메인으로 전달</p></li>
</ol>

<h3 id="life-cycle">
<a class="anchor" href="#life-cycle" aria-hidden="true"><span class="octicon octicon-link"></span></a>Life cycle</h3>

<p>대형 어플리케이션 개발 시</p>

<p>일반적인 기법</p>

<p>처음으로 컨트롤러가 필요할 때 동적으로 생성하는 것이다.</p>

<p>이러한 동적 생성기법은 어플리케이션 로딩 시간을 줄여주고, 필요한 모든 컨트롤러를 활성화 하지 않음으로서 실행 시의 성능을 개선하는 효과가 있다.</p>

<p>이전 버전에서는 한번 컨트롤러가 생성되면 생성된 컨트롤러는 어플리케이션 종료 시까지 계속 살아있게 되는 단점이 있었다. 생성된 컨트롤러를 소멸 시키는 것이 불가능 했기 때문에 점유하고 있는 리소스 회수도 불가능 했다. 또한 이전 버전의 컨트롤러는 비현실적으로 연결된 뷰를 아예 갖지 않거나 제한 없는 수로 연결이 가능하기도 했었다.</p>

<p>그러나 View Controller는 컴포넌트 생명주기의 가장 처음에 생성되고, 뷰의 전체 생명주기에 대해 연동된다.
View 소멸시, View Controller 함께 소멸. 이 의미는 뷰 컨트롤러에 대해 연결된 뷰가 전혀 없는지, 혹은 아주 많은지 강제로 그 상태를 관리할 필요가 없다는 것을 뜻함.</p>

<p>이러한 1-대-1 관계는 레퍼런스 추적이 간소화 되었으며, 소멸된 컴포넌트에 의한 누수가 이제 더 이상 없다는 것을 의미.</p>

<p>View Controller 생명주기 동안 메서드 구현 시 참고할 중요사항:</p>

<ul>
<li>
<p>beforeInit</p>

<ul>
<li>View의 <code>initComponent</code> 메서드가 호출되기 전,</li>
</ul>

<p>View 조작을 수행하기 원할 때 오버라이드할 수 있음.
- 이 메서드는 컴포넌트 생성자가 <code>initConfig</code> 메서드 호출을 수행하는 동안</p>

<p>Controller가 생성되면 즉시 호출 됨.</p>
</li>
<li>
<p>init</p>

<ul>
<li>
<code>initComponent</code> 가 View에서 호출되면 조금 있다가 실행 됨.</li>
<li>시점 상 View가 초기화 된 후 컨트롤러 초기화를 수행하는 단계에 해당 됨.</li>
</ul>
</li>
<li><p>initViewModel - View의 ViewModel이 정의 되어 있을 경우, ViewModel이 생성되면 호출 됨.</p></li>
<li><p>destroy - <code>callParnet</code> 호출을 통해 인스턴스를 제거하고 리소스를 반환 함.</p></li>
</ul>

  </div>

<div>
  <p>MVC 어플리케이션 개선을 위한 ViewController 뿐만 아니라 ViewModels와 MVVM을 지원.</p>

<p>이러한 발전에서 가장 괄목할 만한 점은 이러한 아키텍처의 선택이 상호 배타적이지 않기 때문에 각각 차례대로 사용하거나 혹은 혼합해서 사용할 수도 있다는 점이다.</p>

<h2 id="application-level-controllers">Application-level Controllers</h2>

<p>Controller</p>

<p>Ext.app.Controller를 파생한 클래스로 CSS와 유사한 선택자.</p>

<p>즉, 컴포넌트 쿼리를 사용하여 컴포넌트를 찾고 해당 컴포넌트의 이벤트를 처리.</p>

<p>또한 컴포넌트 인스턴스를 선택하거나 넘겨받기 위해 "refs"를 사용.</p>

<p>어플리케이션 실행시 생성되어 어플리케이션이 실행되는 동안 유지.</p>

<p>Controller의 생명주기 동안 View에서 발생하는 이벤트들이 컨트롤러를 통해 제어.</p>

<p>관리하는 뷰는 다중 인스턴스가 될 수 있음.</p>

<h3 id="challenges">Challenges</h3>

<p>대형 어플리케이션에서 위와 같은 기술들은 당면한 몇가지 문제:</p>

<ul>
<li><p>뷰와 컨트롤러는 각각의 다른 개발부서에서 코딩하고 향후 어플리케이션 수준에서 통합할 가능성이 높음.</p></li>
<li><p>해당하는 View 만 반응하도록 코딩하기는 어플리케이션의 크기가 커질 수록 어려워 질것.</p></li>
<li><p>나아가 개발자들은 어플리케이션 시작 시 한정된 수의 컨트롤러만 생성하도록 제한 원함.</p></li>
<li><p>조금만 노력하면 지연된 컨트롤러 생성(lazily creating controller)이 가능하지만, 이들은 destory 될 수 없어서 더 이상 필요없는 상황이 되어도 소멸 되지 않고 남아있게 됨.</p></li>
</ul>

<hr>

<h2 id="viewcontrollers">ViewControllers</h2>

<p><code>Ext.app.ViewController</code> 위 문제를 해결하기 위한 방안의 새로운 controller.</p>

<p>사용:</p>

<ul>
<li><p><code>listener</code>와 <code>reference</code> 설정을 사용하여 뷰와 연결을 간소화 함</p></li>
<li><p>연결된 뷰 컨트롤러의 자동관리를 통한 효율적 View의 생명주기 관리</p></li>
<li><p>관리하는 View와 1-대-1 관계로 연결된 뷰 컨트롤러를 통해 복잡성 제거</p></li>
<li><p>중첩된 View의 신뢰성 제고를 위한 캡슐화 지원</p></li>
<li><p>컴포넌트 선택 및 연결된 View의 계층에 상관없는 이벤트 리스닝 유지</p></li>
</ul>

<h3 id="listeners">Listeners</h3>

<p>예:</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="nx">Ext</span><span class="p">.</span><span class="nx">define</span><span class="p">(</span><span class="dl">'</span><span class="s1">MyApp.view.foo.Foo</span><span class="dl">'</span><span class="p">,</span> <span class="p">{</span>
    <span class="na">extend</span><span class="p">:</span> <span class="dl">'</span><span class="s1">Ext.panel.Panel</span><span class="dl">'</span><span class="p">,</span>
    <span class="na">xtype</span><span class="p">:</span> <span class="dl">'</span><span class="s1">foo</span><span class="dl">'</span><span class="p">,</span>
    <span class="na">controller</span><span class="p">:</span> <span class="dl">'</span><span class="s1">foo</span><span class="dl">'</span><span class="p">,</span>

    <span class="na">items</span><span class="p">:[{</span>
        <span class="na">xtype</span><span class="p">:</span> <span class="dl">'</span><span class="s1">textfield</span><span class="dl">'</span><span class="p">,</span>
        <span class="na">fieldLabel</span><span class="p">:</span> <span class="dl">'</span><span class="s1">Bar</span><span class="dl">'</span><span class="p">,</span>
        <span class="na">listeners</span><span class="p">:</span> <span class="p">{</span>
            <span class="na">change</span><span class="p">:</span> <span class="dl">'</span><span class="s1">onBarChange</span><span class="dl">'</span> <span class="c1">//no scope given here</span>
        <span class="p">}</span>
    <span class="p">}]</span>
<span class="p">});</span>

<span class="nx">Ext</span><span class="p">.</span><span class="nx">define</span><span class="p">(</span><span class="dl">'</span><span class="s1">MyApp.view.foo.FooController</span><span class="dl">'</span><span class="p">,{</span>
    <span class="na">extend</span><span class="p">:</span> <span class="dl">'</span><span class="s1">Ext.app.ViewController</span><span class="dl">'</span><span class="p">,</span>
    <span class="na">alias</span><span class="p">:</span> <span class="dl">'</span><span class="s1">controller.foo</span><span class="dl">'</span><span class="p">,</span>

    <span class="na">onBarChange</span><span class="p">:</span> <span class="kd">function</span><span class="p">(</span><span class="nx">barTextField</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">//called by 'change' event</span>
    <span class="p">}</span>
<span class="p">});</span>
</code></pre></div>
<p><code>listeners</code></p>

<ul>
<li><p>"scope"를 특정하지 않는 "onBarChange"라는 이름의 이벤트 핸들러를 보여줌.</p></li>
<li><p>내부적으로 이벤트 시스템은 Bar textfield의 기본범위(scope)를 해당 뷰 컨트롤러 자체로 해석.</p></li>
</ul>

<p>예전부터 <code>listener</code> 설정은 컴포넌트 생성자에 의해 사용되는 것으로 예약되어 있었기 때문에,
어떻게 해서 View가 자체적인 이벤트를 리스닝할 수 있는지
또는 자체적인 base 클래스에 의한 이벤트를 알아챌 수 있는지 궁금 함.</p>

<p>해답은 바로 명시적 범위를 사용하는 것.</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="nx">Ext</span><span class="p">.</span><span class="nx">define</span><span class="p">(</span><span class="dl">'</span><span class="s1">MyApp.view.foo.Foo</span><span class="dl">'</span><span class="p">,</span> <span class="p">{</span>
    <span class="na">extend</span><span class="p">:</span> <span class="dl">'</span><span class="s1">Ext.panel.Panel</span><span class="dl">'</span><span class="p">,</span>
    <span class="na">xtype</span><span class="p">:</span> <span class="dl">'</span><span class="s1">foo</span><span class="dl">'</span><span class="p">,</span>
    <span class="na">controller</span><span class="p">:</span> <span class="dl">'</span><span class="s1">foo</span><span class="dl">'</span><span class="p">,</span>

    <span class="na">listeners</span><span class="p">:</span> <span class="p">{</span>
        <span class="na">collapse</span><span class="p">:</span> <span class="dl">'</span><span class="s1">onCollapse</span><span class="dl">'</span><span class="p">,</span>
        <span class="na">scope</span><span class="p">:</span> <span class="dl">'</span><span class="s1">controller</span><span class="dl">'</span>
    <span class="p">},</span>

    <span class="na">items</span><span class="p">:</span> <span class="p">[{</span>
        <span class="p">...</span>
    <span class="p">}]</span>
<span class="p">});</span>
</code></pre></div>
<p>위 예제는 Ext JS의 두가지 새로운 기능을 활용, <code>named scope</code>와 <code>declarative listener</code>(선언적 리스너) 이다.</p>

<p>named scope에 적절한 두 값: <code>this</code>, <code>controller</code></p>

<p>MVC 어플리케이션 코드를 작성할 때, 항상 View의 뷰 컨트롤러를 뜻하는 <code>controller</code> 사용.</p>

<p>(인스턴스 생성된 View의 뷰 컨트롤러가 아님)</p>

<p>View가 Ext.Component의 한 종류이기 때문에 이 View를 "xtype"으로 지정,
위 예제의 View가 내부 아이템으로 textfield를 생성하는 것과 같은 방식으로 다른 View가 지금 사용하는 뷰의 인스턴스를 생성할 수 있게 허용. 예:</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="nx">Ext</span><span class="p">.</span><span class="nx">define</span><span class="p">(</span><span class="dl">'</span><span class="s1">MyApp.view.bar.Bar</span><span class="dl">'</span><span class="p">,</span> <span class="p">{</span>
    <span class="na">extend</span><span class="p">:</span><span class="dl">'</span><span class="s1">Ext.panel.Panel</span><span class="dl">'</span><span class="p">,</span>
    <span class="na">xtype</span><span class="p">:</span><span class="dl">'</span><span class="s1">bar</span><span class="dl">'</span><span class="p">,</span>
    <span class="na">controller</span><span class="p">:</span><span class="dl">'</span><span class="s1">bar</span><span class="dl">'</span><span class="p">,</span>

    <span class="na">items</span><span class="p">:[{</span>
        <span class="na">xtype</span><span class="p">:</span><span class="dl">'</span><span class="s1">foo</span><span class="dl">'</span><span class="p">,</span>
        <span class="na">listeners</span><span class="p">:{</span>
            <span class="na">collapse</span><span class="p">:</span><span class="dl">'</span><span class="s1">onCollapse</span><span class="dl">'</span>
        <span class="p">}</span>
    <span class="p">}]</span>
<span class="p">});</span>
</code></pre></div>
<p>위에서는 Bar View는 Foo의 인스턴스를 자신의 한 아이템으로 생성.
나아가 Foo 뷰에서 그랬던 것처럼 collapse 이벤트 리스닝을 하고 있다.
Foo 뷰에 의해 선언된 리스너는 Foo의 뷰 컨트롤러에서 처리할 것이고,
Bar 뷰에서 발생한 이벤트는 Bar의 뷰 컨트롤러에서 담당하게 될 것이다.</p>

<h3 id="reference">Reference</h3>

<p>Controller 로직을 작성할 때 보통 가장 애매한 것 중에 하나가 특정 처리를 완료하기
위해 필요한 컴포넌트를 찾아내는 것.</p>

<p>예:</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="nx">Ext</span><span class="p">.</span><span class="nx">define</span><span class="p">(</span><span class="dl">'</span><span class="s1">MyApp.view.foo.Foo</span><span class="dl">'</span><span class="p">,</span> <span class="p">{</span>
    <span class="na">extend</span><span class="p">:</span> <span class="dl">'</span><span class="s1">Ext.panel.Panel</span><span class="dl">'</span><span class="p">,</span>
    <span class="na">xtype</span><span class="p">:</span> <span class="dl">'</span><span class="s1">foo</span><span class="dl">'</span><span class="p">,</span>
    <span class="na">controller</span><span class="p">:</span> <span class="dl">'</span><span class="s1">foo</span><span class="dl">'</span><span class="p">,</span>

    <span class="na">tbar</span><span class="p">:</span> <span class="p">[{</span>
        <span class="na">xtype</span><span class="p">:</span> <span class="dl">'</span><span class="s1">button</span><span class="dl">'</span><span class="p">,</span>
        <span class="na">text</span><span class="p">:</span> <span class="dl">'</span><span class="s1">Add</span><span class="dl">'</span><span class="p">,</span>
        <span class="na">handler</span><span class="p">:</span> <span class="dl">'</span><span class="s1">onAdd</span><span class="dl">'</span>
    <span class="p">}],</span>

    <span class="na">items</span><span class="p">:</span> <span class="p">[{</span>
        <span class="na">xtype</span><span class="p">:</span> <span class="dl">'</span><span class="s1">grid</span><span class="dl">'</span><span class="p">,</span>
        <span class="p">...</span>
    <span class="p">}]</span>
<span class="p">});</span>

<span class="nx">Ext</span><span class="p">.</span><span class="nx">define</span><span class="p">(</span><span class="dl">'</span><span class="s1">MyApp.view.foo.FooController</span><span class="dl">'</span><span class="p">,</span> <span class="p">{</span>
    <span class="na">extend</span><span class="p">:</span> <span class="dl">'</span><span class="s1">Ext.app.ViewController</span><span class="dl">'</span><span class="p">,</span>
    <span class="na">alias</span><span class="p">:</span> <span class="dl">'</span><span class="s1">controller.foo</span><span class="dl">'</span><span class="p">,</span>

    <span class="na">onAdd</span><span class="p">:</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
        <span class="c1">// ... get the grid and add a record ...</span>
    <span class="p">}</span>
<span class="p">});</span>
</code></pre></div>
<p>Grid 컴포넌트 가져오기:</p>

<p>어떤 방법이든 Grid 컴포넌트를 고유하게 식별 가능, 인식 가능한 어떤 속성을 부여하도록 요구.</p>

<p>예전의 기법:</p>

<ul>
<li>
<p>"id" 설정.</p>

<ul>
<li>장점: 빠른 탐색이 가능.</li>
<li>단점: 전체 어플리케이션과 DOM에서 유일한 식별자만 됨(제약), 종종 실현 안됨.</li>
</ul>
</li>
<li><p>Ext.getCmp를 이용.</p></li>
<li><p>"itemId" 설정과 "refs" 도는 다른 컴포넌트 쿼리 메서드를 이용.</p></li>
<li><p>"itemId" 사용하고 컴포넌트 쿼리를 활용하는 방법은 좀더 유연하지만 원하는 컴포넌트를 위한 탐색이 필요.</p></li>
</ul>

<p>Grid에 "reference" 설정을 추가하고 필요할 때 "lookupReference" 메서드 사용.</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="nx">Ext</span><span class="p">.</span><span class="nx">define</span><span class="p">(</span><span class="dl">'</span><span class="s1">MyApp.view.foo.Foo</span><span class="dl">'</span><span class="p">,</span> <span class="p">{</span>
    <span class="na">extend</span><span class="p">:</span> <span class="dl">'</span><span class="s1">Ext.panel.Panel</span><span class="dl">'</span><span class="p">,</span>
    <span class="na">xtype</span><span class="p">:</span> <span class="dl">'</span><span class="s1">foo</span><span class="dl">'</span><span class="p">,</span>
    <span class="na">controller</span><span class="p">:</span> <span class="dl">'</span><span class="s1">foo</span><span class="dl">'</span><span class="p">,</span>

    <span class="na">tbar</span><span class="p">:</span> <span class="p">[{</span>
        <span class="na">xtype</span><span class="p">:</span> <span class="dl">'</span><span class="s1">button</span><span class="dl">'</span><span class="p">,</span>
        <span class="na">text</span><span class="p">:</span> <span class="dl">'</span><span class="s1">Add</span><span class="dl">'</span><span class="p">,</span>
        <span class="na">handler</span><span class="p">:</span> <span class="dl">'</span><span class="s1">onAdd</span><span class="dl">'</span>
    <span class="p">}],</span>

    <span class="na">items</span><span class="p">:</span> <span class="p">[{</span>
        <span class="na">xtype</span><span class="p">:</span> <span class="dl">'</span><span class="s1">grid</span><span class="dl">'</span><span class="p">,</span>
        <span class="na">reference</span><span class="p">:</span> <span class="dl">'</span><span class="s1">fooGrid</span><span class="dl">'</span>  <span class="c1">// XXX: reference 선언</span>
        <span class="p">...</span>
    <span class="p">}]</span>
<span class="p">});</span>

<span class="nx">Ext</span><span class="p">.</span><span class="nx">define</span><span class="p">(</span><span class="dl">'</span><span class="s1">MyApp.view.foo.FooController</span><span class="dl">'</span><span class="p">,</span> <span class="p">{</span>
    <span class="na">extend</span><span class="p">:</span> <span class="dl">'</span><span class="s1">Ext.app.ViewController</span><span class="dl">'</span><span class="p">,</span>
    <span class="na">alias</span><span class="p">:</span> <span class="dl">'</span><span class="s1">controller.foo</span><span class="dl">'</span><span class="p">,</span>

    <span class="na">onAdd</span><span class="p">:</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
        <span class="kd">var</span> <span class="nx">grid</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">lookupReference</span><span class="p">(</span><span class="dl">'</span><span class="s1">fooGrid</span><span class="dl">'</span><span class="p">);</span>  <span class="c1">// XXX: reference 찾기</span>
    <span class="p">}</span>
<span class="p">});</span>
</code></pre></div>
<p>이것은 "fooGrid"의 itemId를 할당하고 난후 "this.down('#fooGrid')"를 수행하는 것과 유사.</p>

<p>차이점은 잘드러나지 않지만, 분명히 매우 다르다.</p>

<p>첫번째로 <code>reference</code> 설정은 컴포넌트와 이를 소유하는 View를 스스로 등록하도록 인도.
(예제에서는 뷰 컨트롤러의 존재로 식별 됨)</p>

<p>두번째, <code>lookupReference</code> 메서드는 레퍼런스의 갱신이 필요한지 알기 위해 캐시를 찾아본다.
만약 모든 것이 좋다면, 이 메서드는 캐시로부터 레퍼런스를 리턴한다.</p>

<p>이 과정을 설명하기 위한 pseudo 코드:</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="nx">lookupReference</span><span class="p">:</span> <span class="p">(</span><span class="nx">reference</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">cache</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">references</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">cache</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">Ext</span><span class="p">.</span><span class="nx">fixReferences</span><span class="p">();</span> <span class="c1">// fix all references</span>
        <span class="nx">cache</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">references</span><span class="p">;</span> <span class="c1">// now the cache is valid</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">cache</span><span class="p">[</span><span class="nx">reference</span><span class="p">];</span>
<span class="p">}</span>
</code></pre></div>
<p>다른 말로 표현하면, 컨테이너에 아이템을 추가 또는 제거에 따른 링크 손상이 없고, 탐색이 필요 없다는 것.</p>

<h3 id="encapsulatio">Encapsulatio (추상화)</h3>

<p>controller refs 설정을 이용한 선택자 사용은 매우 유연하지만 동시에 명백한 위험도 존재.</p>

<p>선택자의 실상은 컴포넌트 계층구조의 모든 레벨에 걸쳐 모든 것을 다 검사하다는 것으로 매우 강력하면서도 실수하기 쉽다는 것이다.</p>

<p>예: 컨트롤러는 분리된 환경에서는 100% 독립적으로 주어진 일을 처리하지만 새로운 뷰가 존재할 경우 원하지 않는 일치가 발생할 수 있다.</p>

<p>이러한 문제는 확실한 연습을 통해 관리 가능하지만, <strong>listeners</strong> 와 <strong>reference</strong> 를
<strong>View Controller</strong> 와 함께 사용하게 되면 문제는 간단히 풀리기 어렵게 된다.</p>

<p>왜냐하면 <strong>listener</strong> 와 <strong>reference</strong> 설정은
오직 자체적인 <strong>View Controller</strong> 에 의해 소유되어 연결되기 때문.</p>

<p><strong>View</strong> 는 고유한 레퍼런스 값을 자유롭게 선택할 수 있으며,
그러한 이름들은 <strong>View</strong> 생성자에게 노출되지 않음.</p>

<p>유사하게, <strong>listener</strong> 는 그들을 소유한 <strong>View Controller</strong> 에 의해 처리되고,
잘못된 선택자에 의한 다른 <strong>Controller</strong> 에서 처리될 수 없도록 되어 있음.</p>

<p><strong>listener</strong> 가 적합한 선택자에게 공개되어 있는 것은 선택자 기반의 접근에
요구되는 두 메커니즘이 서로 잘 작동하기 때문이라고 할 수 있음.</p>

<p><strong>Model</strong> 의 완성을 위해 <strong>View</strong> 는 이벤트를 생성해야 함.
생성된 이벤트는 <strong>View</strong> 가 소유한 <strong>View Controller</strong> 에 의해 처리될 것.</p>

<p>아래는 <strong>View Controller</strong> 의 Helper 메서드인 <code>fireViewEvent</code>:</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="nx">Ext</span><span class="p">.</span><span class="nx">define</span><span class="p">(</span><span class="dl">'</span><span class="s1">MyApp.view.foo.FooControlller</span><span class="dl">'</span><span class="p">,</span> <span class="p">{</span>
    <span class="na">extend</span><span class="p">:</span><span class="dl">'</span><span class="s1">Ext.app.ViewController</span><span class="dl">'</span><span class="p">,</span>
    <span class="na">alias</span><span class="p">:</span><span class="dl">'</span><span class="s1">controller.foo</span><span class="dl">'</span><span class="p">,</span>

    <span class="na">onAdd</span><span class="p">:</span><span class="kd">function</span><span class="p">(){</span>
        <span class="kd">var</span> <span class="nx">record</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">MyApp</span><span class="p">.</span><span class="nx">model</span><span class="p">.</span><span class="nx">Thing</span><span class="p">();</span>
        <span class="kd">var</span> <span class="nx">grid</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">lookupReference</span><span class="p">(</span><span class="dl">'</span><span class="s1">fooGrid</span><span class="dl">'</span><span class="p">);</span>
        <span class="nx">grid</span><span class="p">.</span><span class="nx">store</span><span class="p">.</span><span class="nx">add</span><span class="p">(</span><span class="nx">record</span><span class="p">);</span>

        <span class="k">this</span><span class="p">.</span><span class="nx">fireViewEvent</span><span class="p">(</span><span class="dl">'</span><span class="s1">addrecord</span><span class="dl">'</span><span class="p">,</span><span class="k">this</span><span class="p">,</span><span class="nx">record</span><span class="p">);</span>  <span class="c1">// XXX: 추가</span>
    <span class="p">}</span>
<span class="p">});</span>
</code></pre></div>
<p><strong>View</strong> 에 <strong>listener</strong> 추가:</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="nx">Ext</span><span class="p">.</span><span class="nx">define</span><span class="p">(</span><span class="dl">'</span><span class="s1">MyApp.view.bar.Bar</span><span class="dl">'</span><span class="p">,</span> <span class="p">{</span>
    <span class="na">extend</span><span class="p">:</span> <span class="dl">'</span><span class="s1">Ext.panel.Panel</span><span class="dl">'</span><span class="p">,</span>
    <span class="na">xtype</span><span class="p">:</span> <span class="dl">'</span><span class="s1">bar</span><span class="dl">'</span><span class="p">,</span>
    <span class="na">controller</span><span class="p">:</span> <span class="dl">'</span><span class="s1">bar</span><span class="dl">'</span><span class="p">,</span>

    <span class="na">items</span><span class="p">:</span> <span class="p">[{</span>
        <span class="na">xtype</span><span class="p">:</span> <span class="dl">'</span><span class="s1">foo</span><span class="dl">'</span><span class="p">,</span>
        <span class="na">listeners</span><span class="p">:</span> <span class="p">{</span>
            <span class="na">collapse</span><span class="p">:</span> <span class="dl">'</span><span class="s1">onCollapse</span><span class="dl">'</span><span class="p">,</span>
            <span class="na">addrecord</span><span class="p">:</span> <span class="dl">'</span><span class="s1">onAddRecord</span><span class="dl">'</span>  <span class="c1">// XXX: 추가</span>
        <span class="p">}</span>
    <span class="p">}]</span>
<span class="p">});</span>
</code></pre></div>
<h3 id="listeners-and-event-domains">Listeners and Event Domains</h3>

<p>Ext JS 4.2</p>

<ul>
<li><p>MVC 이벤트 디스패처는 <strong>Event Domains</strong> 의 도입과 함께 사용됨.</p></li>
<li><p><strong>Event Domains</strong> 이벤트가 발사되면 이를 가로채서 선택자 매칭에 의해 제어되는</p></li>
</ul>

<p><strong>Controller</strong> 에게 이벤트를 배포.</p>

<ul>
<li>"component" <strong>Event Domains</strong> 은 다른 도메인이 제한된 선택자를 갖기 때문에</li>
</ul>

<p>전체 컴포넌트 쿼리 선택자를 갖음.</p>

<p>Ext JS 5+</p>

<ul>
<li><p>view <strong>Event Domains</strong></p></li>
<li><p>각각의 <strong>View Controller</strong> 은 view <strong>Event Domains</strong> 라</p></li>
</ul>

<p>불리는 새로운 타입의 <strong>Event Domains</strong> 의 인스턴스를 생성.</p>

<ul>
<li>
<strong>View Controller</strong> 가 속한 <strong>View</strong> 에 명시적으로 범위를 한정하여 표준으로</li>
</ul>

<p><code>listen</code>과 <code>control</code> 메서드를 사용할 수 있도록 허용.</p>

<ul>
<li>또한 자체적으로 <strong>View</strong> 를 매칭하기 위한 특별한 선택자를 추가.</li>
</ul>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="nx">Ext</span><span class="p">.</span><span class="nx">define</span><span class="p">(</span><span class="dl">'</span><span class="s1">MyApp.view.foo.FooController</span><span class="dl">'</span><span class="p">,</span> <span class="p">{</span>
    <span class="na">extend</span><span class="p">:</span> <span class="dl">'</span><span class="s1">Ext.app.ViewController</span><span class="dl">'</span><span class="p">,</span>
    <span class="na">alias</span><span class="p">:</span> <span class="dl">'</span><span class="s1">controller.foo</span><span class="dl">'</span><span class="p">,</span>

    <span class="na">control</span><span class="p">:</span> <span class="p">{</span>
        <span class="dl">'</span><span class="s1">#</span><span class="dl">'</span><span class="p">:</span> <span class="p">{</span>  <span class="c1">// matches the view itself</span>
            <span class="na">collapse</span><span class="p">:</span> <span class="dl">'</span><span class="s1">onCollapse</span><span class="dl">'</span>
        <span class="p">},</span>
        <span class="na">button</span><span class="p">:</span> <span class="p">{</span>
            <span class="na">click</span><span class="p">:</span> <span class="dl">'</span><span class="s1">onAnyButtonClick</span><span class="dl">'</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">});</span>
</code></pre></div>
<p>위 코드에서 리스너와 선택자의 중요한 차이점을 볼 수 있다.</p>

<p>"button" 선택자</p>

<ul>
<li><p>지금의 뷰 혹은 지금 뷰를 상속하는 자식 뷰에 속한 아무 버튼을 찾을 것.</p></li>
<li><p>버튼 선택자의 탐색은 상속 계층에 상관하지 않고 심지어 버튼이 4번째 상속된 View에 있을 경우라도 해당.</p></li>
</ul>

<p>다른 표현으로 하자면, 선택자 기반의 핸들러는 추상화 범위를 상관하지 않는 다는 것이다.</p>

<p>이러한 속성은 Ext.app.Controller 속성과 함께 일관되며, 제한된 상황에서 때론 유용하게 사용될 수 있다.</p>

<p><strong>Event Domain</strong></p>

<ul>
<li><p>중첩적으로 구성되며 View 계층에서 발생시키는 이벤트에 대해 효과적으로 대응.</p></li>
<li><p>이벤트가 발생 시</p></li>
</ul>

<ol>
<li><p>모든 표준 listener에게 전달</p></li>
<li><p>소유하고 있는 View Controller에게 전달</p></li>
<li><p>계층구조에 따라 부모 뷰컨트롤러에게 순차적으로 전달</p></li>
<li><p>Ext.app.Controller를 파생한 컨트롤러에 의해 처리되는 표준 "component" 이벤트 도메인으로 전달</p></li>
</ol>

<h3 id="life-cycle">Life cycle</h3>

<p>대형 어플리케이션 개발 시</p>

<p>일반적인 기법</p>

<p>처음으로 컨트롤러가 필요할 때 동적으로 생성하는 것이다.</p>

<p>이러한 동적 생성기법은 어플리케이션 로딩 시간을 줄여주고, 필요한 모든 컨트롤러를 활성화 하지 않음으로서 실행 시의 성능을 개선하는 효과가 있다.</p>

<p>이전 버전에서는 한번 컨트롤러가 생성되면 생성된 컨트롤러는 어플리케이션 종료 시까지 계속 살아있게 되는 단점이 있었다. 생성된 컨트롤러를 소멸 시키는 것이 불가능 했기 때문에 점유하고 있는 리소스 회수도 불가능 했다. 또한 이전 버전의 컨트롤러는 비현실적으로 연결된 뷰를 아예 갖지 않거나 제한 없는 수로 연결이 가능하기도 했었다.</p>

<p>그러나 View Controller는 컴포넌트 생명주기의 가장 처음에 생성되고, 뷰의 전체 생명주기에 대해 연동된다.
View 소멸시, View Controller 함께 소멸. 이 의미는 뷰 컨트롤러에 대해 연결된 뷰가 전혀 없는지, 혹은 아주 많은지 강제로 그 상태를 관리할 필요가 없다는 것을 뜻함.</p>

<p>이러한 1-대-1 관계는 레퍼런스 추적이 간소화 되었으며, 소멸된 컴포넌트에 의한 누수가 이제 더 이상 없다는 것을 의미.</p>

<p>View Controller 생명주기 동안 메서드 구현 시 참고할 중요사항:</p>

<ul>
<li>
<p>beforeInit</p>

<ul>
<li>View의 <code>initComponent</code> 메서드가 호출되기 전,</li>
</ul>

<p>View 조작을 수행하기 원할 때 오버라이드할 수 있음.
- 이 메서드는 컴포넌트 생성자가 <code>initConfig</code> 메서드 호출을 수행하는 동안</p>

<p>Controller가 생성되면 즉시 호출 됨.</p>
</li>
<li>
<p>init</p>

<ul>
<li>
<code>initComponent</code> 가 View에서 호출되면 조금 있다가 실행 됨.</li>
<li>시점 상 View가 초기화 된 후 컨트롤러 초기화를 수행하는 단계에 해당 됨.</li>
</ul>
</li>
<li><p>initViewModel - View의 ViewModel이 정의 되어 있을 경우, ViewModel이 생성되면 호출 됨.</p></li>
<li><p>destroy - <code>callParnet</code> 호출을 통해 인스턴스를 제거하고 리소스를 반환 함.</p></li>
</ul>

</div>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/blog/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">Portal2312&#39;s blog</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">Portal2312&#39;s blog</li><li><a class="u-email" href="mailto:portal2312@gmail.com">portal2312@gmail.com</a></li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/portal2312"><svg class="svg-icon"><use xlink:href="/blog/assets/minima-social-icons.svg#github"></use></svg> <span class="username">portal2312</span></a></li><li><a href="https://www.twitter.com/portal2312"><svg class="svg-icon"><use xlink:href="/blog/assets/minima-social-icons.svg#twitter"></use></svg> <span class="username">portal2312</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>Welcome to my blog.</p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
