< ls 명령어 >

ls -altr (수정순 + 역순)
ls -alcr (만든순 + 역순)
ls -altrc (수정순 + 역순 + 정렬후 만든순으로 보여줌)

?ls -l : 현재 directory의 file과 directory
?ls -la : 점(.)으로 시작하는 file/directory 포함
?ls -lt : 최근에 변경된 순으로 정렬
?ls -lu : 최근에 접근한 순으로 정렬
?ls -ls : 크기순으로 정렬
?ls -li : 각 file 마다 연계된 inode 표시
?ls -ln : user/group ID의 숫자를 표시
?ls -lh : 사람이 쉽게 읽을 수 있도록 사이즈 표시 (K, M, ...)
?ls -lR : sub-directory를 recursive하게 표시

당신이 file을 list할 때 다른 type의 file을 다르게 표시하는 방법이 있습니다.
?ls -F : file type 별로 문자를 추가시킴
symbolic link(@), directory(/), pipe(|), executable(*), socket(=)
?ls --color=always : type 별로 다른 색으로 표현
?ls -C : column으로 표현



< Linux - find 명령어>
1. 형식 : find [path] [options] [actions]
1. path     : find를 수행할 대상경로
1) .    : 현재 경로 이하
2) /    : 시스템 최하위 경로
3) ~ID : 사용자계정(ID)의 Home경로이하
4) /경로

2. options : 검색옵션

-empty   : 비어있는 파일(단, 일반파일 또는 일반 디렉토리에 한함)
-uid [N] : 지정된 [N]값의UID를 갖는 파일
-gid [N] : 지정된 [N]값의 GID를 갖는 파일
-group   : [그룹명] : 지정한 그룹명에 소속된 파일
-name    : 지정된 형식의 패턴을 가지는 파일
-newer [파일] : 지정한 "파일"보다 더 최근에 변경된 적이 있는 파일
-used [N] : 파일이 변경된 이후 최근 [N]일 이후에 액세스된 적이 있는 파일
-user [uname] : 지정된 [uname]의 소유로 된 모든 파일.(UID로 지정가능)
-amin [N] : 최근 [N]분 이전에 액세스(access)된 적이 있는 파일
-anewer [파일] : 지정한 "파일"보다 더 최근에 액세스(access)된 적이 있는 파일
-atime [N] : 최근 [N]*24시간 전에 액세스된 적이 있는 파일
-mmin [N] : 최근 [N]분 이전에 변경된 적이 있는 파일
-mtime [N] : 최근 [N]*24시간 이전에 변경된 적이 있는 파일
-executable : 실행 가능한 파일
-readable : 읽기 가능한 파일
-writable : 쓰기 가능한 파일
-fstype [type] : 지정한 파일시스템타임(type)에 존재하는 파일
-nogroup : 소속 그룹이 존재하지 않는 파일
-nouser : 소속 사용자(ID)가 존재하지 않는 파일
-path [패턴] : 파일명이 "패턴"에 매칭되는 파일
-perm [모드] : "모드"에서 지정된 퍼미션과 일치하는 퍼미션을 가진 파일만 해당됨,
"-perm g=w"로 지정했을 경우 퍼미션이 0020인것만 해당됨.
-perm -[모드] : "모드"에서 지정된 퍼미션을 가진 모든 파일"
              "-perm -g=w"로 지정했을 경우 그룹소유자에 쓰기권한이있는 모든파일이 해당됨.
-regex [패턴] : "패턴"에서 지정한 정규표현식에 매칭되는 파일
-size [n][b,c,w,k,M,G] : 지정된 [n]단위의 디스크공간을 사용하는 파일. 
                                   b(디폴트), c, w, k, M, G등이 올수 있음
-type [타입] : 지정한 파일타입에 해당하는 파일. ( b, c, d, p, f, l, s등이 있음 )
-I='' --ignore=''  : 예외, 제외, 유형(=*.pyc)

※ 위의 [n]값은 +n은 n보다 큰 값을 의미하고, -n은  n보다 작은값을 의미하며, n은 정확하게 n값만을 의미한다.


3. actions : 검색 후 검색된 파일들을 대상으로 어떤 작업을 수행할것인가를 지정
find명령어 내에서 사용가능한 연산자들이다.

( )                        : 괄호안의 연산이 먼저 행해짐
! [expr]                 : [expr] 이 거짓일때 참, 참일때 거짓이 됨 
-not [expr]            : 위의 "! [expr]"과 동일함 (POSIX 호환용)
[expr1] [expr2]      : AND의 의미 (= [expr1] -and [expr2] : POSIX호환용), (= [expr1] -a [expr2] )
[expr1] -or [expr2] : OR의 의미 (= [expr1] -o [expr2] : POSIX호환용은 아님)


 ※ "find / -empty -exec ls -l  {} \;"의 의미파악하기
 
find /                = 최상위디렉토리(/)를 대상으로 
-empty              = 크기가 0인 파일 혹은 비어있는 디렉토리를 검색하겠음
-exec               = 검색된 파일을 대상으로 명령어를 실행하겠다.
ls -l                 = ls -l명령어 실행
{}                    = 검색된 파일을 하나씩 대입시키기 위한 용도로 사용됨
\                    = escape문자
;                      = shell로 부터 보호해서 find명령이 넘어갈수없게 함,
 
#명령어 마지막에 넣어주는 "\;"는 그냥 무조건 넣어주면 된다고 생각하는게 편할듯함.

다시한번풀이) find / -empty를 해서 찾은 내용이 만약 /data/temp.bak파일이라면 ls -l /data/temp.bak를 실행하겠다는 뜻,
물론 하나의 파일이 아닌 다른 파일이 검색된다면 다른 또한 ls -l [검색된파일절대경로] 의 형식으로 검색이 됨.
ls -l로 디렉토리를 검색할시 빈디렉토리에 대해선 total 0라고 뜨기때문에 비어있는 디렉토리의 경로를 알수가 없다, ls의 -d옵션을 넣어줘야만 빈디렉토리의 경로를 알수 있음.
 
중요1, -exec옵션을 사용시 "\;"는 반드시 넣어줘야 함
중요2, 명령어 {}(대괄호) 와 \(백슬래시)의 사이는 반드시 띄어져야함
중요3, \(백슬래시)와 ;(세미콜론)의 사이는 절때 떨어질수 없음, 어떠한 여백도 오면 안됨
중요4, -exec를 통해서 alias명령어는 사용이 안되는듯 하다.


- 예외하기
  ls -I*.pyc (대문자 붙여서)


## Find

1) 크기가 0이거나 빈디렉토리 검색하기
find / -empty -exec ls -ld {} \;
find / -empty ?ls

2) 지정한 UID소유의 모든 파일을 검색하기
find / -uid 500 -exec ls -ld {} \;
= uid가 500인 사용자가 소유한 모든 파일을 검색하여 ls-ld형식으로 출력

3) UID가 아닌 사용자계정명으로 소유한 모든 파일 검색
find / -user youngjae -print
= youngjae사용자계정이 소유한 모든 파일을 검색하여 표준출력형태로 출력

4) 특정사용자의 홈디렉토리에서 특정파일 검색하기
find ~youngjae -name '*.dat' -exec ls -l {} \;
= youngjae계정의 홈디렉토리내에서 .dat로 끝나는 모든 파일을 찾은후 ls -l형식으로 출력

5) 검색된 파일 바로 삭제하기
find ~youngjae -name '*.bak' -exec rm -f {} \;
= youngjae계정의 홈디렉토리내에서 .bak로 끝나는 모든 파일 삭제

6) 사이즈가 큰 파일들을 검색하기
find / -size +100M -exec ls -lh {} \;
= 파일사이즈가 100M이상인 파일을 검색하여 ls -lh형식으로 출력

7) 두개의 검색조건과 일치하는 파일 검색하기
find /home ! -user youngjae -and -name '*.dat' -exec ls -l {} \;
= /home의 파일소유자 youngjae가 아닌 파일중 .dat로 끝나는 모든파일 검색하여 ls ?l로 출력.

8) 지정한 퍼미션을 가지고 있는 파일 검색하기
find / -perm 4755 -exec ls -l {} \;
= 파일시스템 전체에서 SetUID퍼미션과 755 퍼미션을 가진 파일을 찾은후 ls -l형식으로 출력.

9)  파일의 변경시간을 기준으로 원하는 파일 검색하기
find /home -mmin -30 -exec ls -ld {} \;
= /home디렉토리에서 최근 30분사이에 변경된 파일을 검색하여 ls -ld형식으로 출력
즉, 30분 전부터 현재까지 변경된 파일을 의미한다.

※ 위에서 분으로 표시되는 n값에 대한 해석
-mmin n = 정확히 n분이전에 변경된 파일, n분보다 더 적게도, 크게도 아니다. 딱 n분 전이다.
-mmin -n = 최근 n분사이에 변경된 파일을 의미한다. (n분전 ~ 현재)
-mmin +n = n분 이전에 변경된 파일을 의미한다. (가장처음 ~ n분전)

10 )파일의 실행(access)시간을 기준으로 원하는 파일 검색하기
find /home -atime +2 -exec ls -ld {} \;
= /home디렉토리내에서 2시간전 혹은 그보다 더 이전에 사용된 파일을 찾은 후 ls -ld으로 출력

11) 지정한 파일보다 더 최근에 사용된 적이 있거나 변경된 적이 있는 파일 검색
find /home -anewer /home/youngjae/linux.dat -exec ls -ld {} \;
= /home디렉토리내에 /home/youngjae/linux.dat파일의 실행시간 또는 변경된시간보다 더 최근에 변경되었거나 실행되었던 파일을 찾아 ls -ld형식으로 출력

12 )특정 파일타입의 파일들만 검색하기
find /home -type l -exec ls -l {} \;
= /home디렉토리내에서 심볼릭링크파일만 찾아 ls -l형식으로 출력

※ 파일타입
-type b = 블록장치파일(block special file)
-type c = 문자장치파일(character special file)
-type d = 디렉토리(directory)
-type p = FIFO파일(first in first out)
-type f = 일반파일(refular file)
-type l = 심볼릭링크파일(symbolic link file)
-type s = 소켓파일(socket file)

13) root소유의 SetUID, SetGID, StickyBit파일 검색하기
find / -user root -perm 4755 -exec ls -l {} \;
= 파일시스템 전체에서 root소유의 SetUID파일을 찾아 ls -l형식으로 출력
root소유의 SetUID파일은 보안상 상당히 중요한 파일이다.

※ 전체적으로 find명령어를 공부하면서 이해가 안되는 부분이 상당수 있음,
-or 연산자를 이용하여 조건을 2개를 사용한 상태에서 액션옵션을 주게 되면, -or 연산자 뒤쪽에 주었던 옵션에 대해서만 액션옵션이 수행되며 -or연산자 앞쪽은 무시가 됐다.
지식인을 통하여 알아낸 답변
= find /home \( -type l -o -user user2 \) -print
/home디렉토리내에 심볼릭링크파일과 user2소유인 파일을 출력 괄호 이용하기



- 예외하기

1. 예제로 살펴보기

[예제 1] 2009가 포함된 파일을 찾는다. 단 파일명이 디렉토리에 해당되면 해당 디렉토리 이하는 찾지 않는다.

$ find (전체 보기)
./
./check/check_list_2008_12.php
./check/check_list_2009_05.php
./check/check_list_2009_06.php
./2007_10_mobile
./2008_01_highlight
./2008_01_highlight/view.pl
./2008_01_highlight/view.sh
./2009_03_MSIE8
./2009_03_MSIE8/get_MSIE8.sh
./2009_05_apache
./2009_05_game
./2009_05_game/2009_05.log
$ find . -name "*2009*" -prune
./check/check_list_2009_05.php
./check/check_list_2009_06.php
./2009_03_MSIE8
./2009_05_apache
./2009_05_game

./2009_05_game/ 디렉토리 이하에 2009_05.log 파일이 있지만, -prune옵션으로 해당 디렉토리 이하는 찾지 않았다.

[예제 2] ./foo/bar 디렉토리는 제외하고, *.txt 파일을 찾아라.

$ find . ! \( -path './foo/bar' -prune \) -name "*.txt"
$ find . ! \( -type d -path './foo/bar' -prune \) -name "*.txt" (보다 정확한 표현)

[예제 3] ./foo/bar 디렉토리와 ./coffeenix/temp 디렉토리는 제외하고, *.bak 파일을 찾아라.

$ find . ! \( \( -path './foo/bar' -o -path './coffeenix/temp' \) -prune \) -name "*.bak"
$ find . ! \( \( -type d -path './foo/bar' -o -path './coffeenix/temp' \) -prune \) -name "*.bak" (보다 정확한 표현)

[예제 4] ./2008로 시작하는 디렉토리는 제외하고, .*.bak 파일을 찾아라.

$ find . ! \( -path './2008*' -prune \) -name "*.bak"
$ find . ! \( -type d -path './2008*' -prune \) -name "*.bak" (보다 정확한 표현)