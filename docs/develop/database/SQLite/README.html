<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.6.1 -->
<title>SQLite | Portal2312&#39;s blog</title>
<meta name="generator" content="Jekyll v3.8.6" />
<meta property="og:title" content="SQLite" />
<meta name="author" content="mkkim" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Documentation" />
<meta property="og:description" content="Documentation" />
<link rel="canonical" href="http://localhost:4000/blog/docs/develop/database/SQLite/README.html" />
<meta property="og:url" content="http://localhost:4000/blog/docs/develop/database/SQLite/README.html" />
<meta property="og:site_name" content="Portal2312&#39;s blog" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2019-11-06T09:31:12+09:00" />
<script type="application/ld+json">
{"description":"Documentation","headline":"SQLite","dateModified":"2019-11-06T09:31:12+09:00","datePublished":"2019-11-06T09:31:12+09:00","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/blog/docs/develop/database/SQLite/README.html"},"url":"http://localhost:4000/blog/docs/develop/database/SQLite/README.html","author":{"@type":"Person","name":"mkkim"},"@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href='/blog/assets/main.css'><link type="application/atom+xml" rel="alternate" href="http://localhost:4000/blog/feed.xml" title="Portal2312's blog" /><script src='/blog/dist/js/common.bundle.js'></script>
</head>
<body><header class="site-header" role="banner">
  <div class="wrapper">
    <a class="site-title" rel="author" href="/blog/">Portal2312&#39;s blog</a>
    <nav class="site-nav">
    <input type="checkbox" id="nav-trigger" class="nav-trigger" />
    <label for="nav-trigger">
      <span class="menu-icon">
        <svg viewBox="0 0 18 15" width="18px" height="15px">
          <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
        </svg>
      </span>
    </label>

    <div class="trigger"><a class="page-link" href="/blog/about.html">
            About
          </a><a class="page-link" href="/blog/posts.html">
            Posts
          </a><a class="page-link" href="/blog/history.html">
            History
          </a><a class="page-link" href="/blog/docs/index.html">
            Docs
          </a></div>
  </nav>
  </div>
  <div class="scroll-indicator-container">
  <div class="scroll-indicator-bar" id="scrollIndicatorBar"></div>
</div>

</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <h1>SQLite</h1>

  <div>
    <h2>Table of contents</h2>
    <ul class="section-nav">
<li class="toc-entry toc-h1"><a href="#documentation">Documentation</a>
<ul>
<li class="toc-entry toc-h2"><a href="#features">Features</a></li>
<li class="toc-entry toc-h2"><a href="#usage">Usage</a></li>
</ul>
</li>
<li class="toc-entry toc-h1"><a href="#reference-url">Reference.URL</a></li>
</ul><h1 id="documentation">
<a class="anchor" href="#documentation" aria-hidden="true"><span class="octicon octicon-link"></span></a>Documentation</h1>

<h2 id="features">
<a class="anchor" href="#features" aria-hidden="true"><span class="octicon octicon-link"></span></a>Features</h2>

<ul>
<li>
<p>Zero-Configuration</p>

<ul>
<li>"설치" 할 필요가 없다.</li>
<li>"설정" 절차가 없음.</li>
<li>시작될 필요가 없는 서버 프로세스를 정지 또는 구성 없다.</li>
<li>New DB 인스턴스를 만들거나 User 액세스 권한을 할당하려면 Admin 에 대한 필요가 없음.</li>
<li>SQLite는 어떤 구성 파일을 사용하지 않습니다.</li>
<li>아무것도 SQLite는가 실행중인 시스템을 알려 할 필요가 없습니다.</li>
<li>어떤 작업은 시스템 충돌 또는 정전 후 복구하는 데 필요하지 않습니다.</li>
<li>문제를 해결하기 위해 아무것도 없다.</li>
</ul>
</li>
<li><p>Serverless (서버 없음)</p></li>
</ul>

<p>대부분 SQL 데이터베이스 엔진은 별도의 서버 프로세스로서 구현된다.
  데이터베이스에 액세스하고자하는 프로그램은 서버에 요청을 전송하고 결과를 다시 수신하는 프로세스 간 통신 (일반적으로 TCP / IP)의 일종을 이용하여 서버와 통신한다.</p>

<p>SQLite는 이런 식으로 작동하지 않습니다. SQLite는, 데이터베이스는 디스크의 데이터베이스 파일로부터 직접 기록에 액세스하고자하는 프로세스. 더 중간 서버 프로세스가 없습니다.</p>

<p>서버없는 것을 장점과 단점이 있습니다. 가장 큰 장점은, 설정, 설치, 구성, 초기화, 관리하고, 문제를 해결하기 위해 별도의 서버 프로세스가 없다는 것입니다.
  이 SQLite는이 "제로 구성"데이터베이스 엔진 인 이유 중 하나입니다.
  SQLite는 사용하는 프로그램은 실행하기 전에 데이터베이스 엔진을 설정하기 위한 행정 지원이 필요하지 않습니다.
  디스크를 액세스 할 수있는 프로그램은 SQLite는 데이터베이스를 사용할 수있다.</p>

<p>한편, 서버를 사용하는 데이터베이스 엔진이 클라이언트 응용 프로그램의 버그에서 더 나은 보호를 제공 할 수 있습니다 - 클라이언트에서 길잃은 포인터를 할 수있는 서버에없는 메모리가 손상. 서버가 하나의 영구 프로세스이기 때문에, 그것을 미세한 입자 로킹 나은 동시성 수보다 정밀하게 제어 할 수 데이터베이스 액세스이다.</p>

<p>대부분의 SQL 데이터베이스 엔진은 클라이언트 / 서버 기반으로합니다. 서버없는 것을이 중 SQLite는 그 다수의 애플리케이션들이 동시에 동일한 데이터베이스에 액세스 할 수의 필자가 알고있는 유일한 것이다.</p>

<ul>
<li>
<p>Single Database File</p>

<ul>
<li>아무 곳이나 디렉토리 계층에 위치 할 수있는 하나의 일반 디스크 파일입니다.</li>
</ul>
</li>
<li>
<p>Stable Cross-Platform Database File (안정적인 크로스-플랫폼 데이터베이스 파일)</p>

<ul>
<li>파일 형식은 크로스 플랫폼, 모든 시스템은 동일한 파일 형식을 사용.</li>
<li>하나의 시스템에 작성된 DB 파일에 복사하고 다른 아키텍처를 다른 컴퓨터에서 사용 가능.</li>
<li>빅 - 엔디안 또는 리틀 엔디안, 32 bit 또는 64 bit는 중요하지 않음.</li>
<li>또한, 개발자들은 SQLite는 최신 버전의 읽기 및 이전 데이터베이스 파일을 작성할 수 있도록 안정적이고 호환 파일 형식을 유지하기로 약속했다. (대부분의 다른 SQL 데이터베이스 엔진은 최신 버전의 소프트웨어로 업그레이드 할 때 자주 한 플랫폼에서 다른 플랫폼으로 이동할 때 덤프하고 데이터베이스를 복원 할 필요합니다)</li>
</ul>
</li>
<li>
<p>Compact (실속있는)</p>

<ul>
<li>크기에 최적화 할 때 사용할 수있는 모든과 전체 SQLite는 라이브러리입니다 크기 500KiB 이하 (GNU 컴파일러 스위트에서 "크기"유틸리티를 사용하여 ix86에에 측정.)</li>
<li>불필요한 기능은 더욱 감소 컴파일 시간에 비활성화 할 수 있습니다 300KiB 아래에 라이브러리의 크기를 원하는 경우.</li>
</ul>
</li>
<li><p>Manifest typeing (매니페스트 입력)</p></li>
</ul>

<p>대부분의 SQL 데이터베이스 엔진은 정적 입력을 사용합니다. 데이터 형식이 테이블과 특정 데이터 유형의 값에서 각 컬럼과 연관된 해당 컬럼에 저장 될 수 있습니다.</p>

<p>SQLite는 매니페스트 입력을 사용하여이 제한을 완화. 매니페스트 입력에서 데이터 유형은 값 자체의 속성이며, 열의있는 값은 저장되지 않습니다. SQLite는 따라서 사용자가 해당 컬럼의 선언 된 유형에 관계없이 모든 컬럼에 모든 데이터 유형의 값을 저장할 수 있습니다. (: 정수 PRIMARY KEY 열 수도에만 저장 정수 그리고 SQLite는 컬럼의 선언 된 데이터 유형 때 수에 값을 강요하는 시도가이 규칙에 예외이다.).</p>

<p>지금까지 우리가 말할 수있는, SQL 언어 사양은 매니페스트 입력을 사용할 수 있습니다. 그럼에도 불구하고, 대부분의 다른 SQL 데이터베이스 엔진은 정적으로 입력하고, 그래서 어떤 사람들은 매니페스트 입력의 사용은 SQLite는 버그가 있다고 생각합니다. 하지만 SQLite는의 저자는 매우 강력하게이 기능이라고 생각합니다. SQLite는의 매니페스트 입력의 사용은 티클이나 Python과 같이 동적으로 입력 된 프로그래밍 언어와 함께 사용 특히, 사용하는 SQLite는보다 안정적이고 쉽게하기 위해 실제로 입증 신중한 디자인 결정이다.</p>

<ul>
<li>Variable-length records (가변 길이 레코드)</li>
</ul>

<p>대부분의 다른 SQL 데이터베이스 엔진은 대부분 테이블의 각 행에 대해 디스크 공간의 고정 된 양을 할당. 그들은에 BLOB과 격렬하게 다양한 길이 될 수 CLOB의 처리를위한 특별한 트릭을 재생할 수 있습니다. 그러나 대부분의 테이블에, 당신이라면 데이터베이스 엔진에 관계없이 실제로 해당 열에 저장 정보의 양의 디스크 공간이 100 바이트를 할당하는 VARCHAR (100)이 될 수있는 열을 선언합니다.</p>

<p>SQLite는 반대로, 실제로는 연속 된 정보를 저장하는 데 필요한 디스크 공간의 양을 사용한다.</p>

<p>당신은 VARCHAR (100) 열에서 하나의 문자를 저장하는 경우, 디스크 공간 만 단일 바이트가 소비된다.</p>

<p>(실제로는 두 바이트 - 데이터 유형의 길이를 기록하는 각각의 컬럼의 처음에 오버 헤드가 있다.)</p>

<p>SQLite는 의한 가변 길이 레코드의 사용은 많은 장점을 가지고있다. 그것은 분명, 작은 데이터베이스 파일에 발생합니다. 와 디스크에서 이동 적은 정보가 있기 때문에 또한, 데이터베이스 실행 속도합니다. 그리고 가변 길이 레코드를 사용함으로써 SQLite는 대신 정적 타이핑 매니페스트 입력을 채택 할 수있다.</p>

<ul>
<li>Readable source code (읽을 수있는 소스 코드)</li>
</ul>

<p>SQLite 소스 코드는 평균 프로그래머 읽고 액세스 할 수 있도록 설계되어 있음.</p>

<ul>
<li>SQL statements compile into virtual machine code (SQL 문은 가상 머신 코드로 컴파일)</li>
</ul>

<p>모든 SQL 데이터베이스 엔진은 명령문의 작업을 수행하는 데 사용되는 내부 데이터 구조의 일종으로, 각 SQL 문을 컴파일한다. 그러나 대부분의 SQL 엔진 내부 데이터 구조는 상호 구조와 오브젝트의 복잡한 웹된다. SQLite는에서, 문장의 컴파일 된 형태의 표현과 같은 기계 언어의 짧은 프로그램입니다. 데이터베이스의 사용자는이 볼 수있는 가상 컴퓨터 언어를 앞두고 붙이는 것에 의해 EXPLAIN 쿼리에 키워드를.</p>

<p>SQLite는의 가상 머신의 사용은 도서관의 발전에 큰 도움이되고있다. 가상 머신은 SQLite는과 백 엔드 (가상 컴퓨터 코드를 실행하고 결과를 계산하는 부분 (SQL 문을 구문 분석하고 가상 머신 코드를 생성하는 부분)의 프론트 엔드 사이에 선명하고 잘 정의 된 연결을 제공합니다. ) 가상 머신은 개발자가 명확하게 볼 SQLite는 디버깅에 엄청난 도움이됩니다 그것을 컴파일 각 문장으로 일을하려고 무엇 쉽게 읽을 수있는 형태로 할 수 있습니다. 실행하면서 인쇄 각 가상 기계 명령어와 그 결과 -이 컴파일 방법에 따라, SQLite는 또한 가상 머신의 실행을 추적하는 기능이 있습니다.</p>

<ul>
<li><p>Pubile domain (공개)</p></li>
<li>
<p>SQL language extensions (SQL 언어 확장)</p>

<ul>
<li>Explain 스 키워드 및 매니페스트 입력.</li>
<li>지원 ATTACH 및 DETACH 여러 개의 독립적인 DB 가 동일한 쿼리에서 함께 사용할 수 있도록 명령을.</li>
<li>사용자에 의한 추가.</li>
</ul>
</li>
</ul>

<h2 id="usage">
<a class="anchor" href="#usage" aria-hidden="true"><span class="octicon octicon-link"></span></a>Usage</h2>

<ul>
<li><p>자동완성은 아쉽게도 readline 으로 한다고 하는데 나는 잘 안된다.</p></li>
<li><p>Query 는 일반 SQL 과 비슷한데, 다만 SQLite Commands 알아야 함.</p></li>
<li><p>SQLite3 Comamnds 는 OneLine Doc 또는 .help 를 보고했다.</p></li>
<li>
<p>File Create (현재 작업한 내용, 처음에만)</p>
<div class="highlight"><pre><code class="language-" data-lang="">.backup 파일명.db
</code></pre></div>
</li>
<li>
<p>File Update (모든 수정)</p>
<div class="highlight"><pre><code class="language-" data-lang="">.dump 파일명.db
</code></pre></div>
</li>
<li>
<p>Files Load (옵션은 확인해서 추가한 내용임)</p>
<div class="highlight"><pre><code class="language-" data-lang="">&gt; sqlite3 -column -header 파일명.db
</code></pre></div>
</li>
</ul>

<h1 id="reference-url">
<a class="anchor" href="#reference-url" aria-hidden="true"><span class="octicon octicon-link"></span></a><em>Reference.URL</em>
</h1>

<p><a href="https://sqlite.org/docs.html">https://sqlite.org/docs.html</a></p>

<p><a href="https://sqlite.org/different.html">https://sqlite.org/different.html</a></p>

<p><a href="https://sqlite.org/datatype3.html">https://sqlite.org/datatype3.html</a></p>

<p><a href="http://www.sqlite.org/cli.html">http://www.sqlite.org/cli.html</a></p>

  </div>

<div>
  <h1 id="documentation">Documentation</h1>

<h2 id="features">Features</h2>

<ul>
<li>
<p>Zero-Configuration</p>

<ul>
<li>"설치" 할 필요가 없다.</li>
<li>"설정" 절차가 없음.</li>
<li>시작될 필요가 없는 서버 프로세스를 정지 또는 구성 없다.</li>
<li>New DB 인스턴스를 만들거나 User 액세스 권한을 할당하려면 Admin 에 대한 필요가 없음.</li>
<li>SQLite는 어떤 구성 파일을 사용하지 않습니다.</li>
<li>아무것도 SQLite는가 실행중인 시스템을 알려 할 필요가 없습니다.</li>
<li>어떤 작업은 시스템 충돌 또는 정전 후 복구하는 데 필요하지 않습니다.</li>
<li>문제를 해결하기 위해 아무것도 없다.</li>
</ul>
</li>
<li><p>Serverless (서버 없음)</p></li>
</ul>

<p>대부분 SQL 데이터베이스 엔진은 별도의 서버 프로세스로서 구현된다.
  데이터베이스에 액세스하고자하는 프로그램은 서버에 요청을 전송하고 결과를 다시 수신하는 프로세스 간 통신 (일반적으로 TCP / IP)의 일종을 이용하여 서버와 통신한다.</p>

<p>SQLite는 이런 식으로 작동하지 않습니다. SQLite는, 데이터베이스는 디스크의 데이터베이스 파일로부터 직접 기록에 액세스하고자하는 프로세스. 더 중간 서버 프로세스가 없습니다.</p>

<p>서버없는 것을 장점과 단점이 있습니다. 가장 큰 장점은, 설정, 설치, 구성, 초기화, 관리하고, 문제를 해결하기 위해 별도의 서버 프로세스가 없다는 것입니다.
  이 SQLite는이 "제로 구성"데이터베이스 엔진 인 이유 중 하나입니다.
  SQLite는 사용하는 프로그램은 실행하기 전에 데이터베이스 엔진을 설정하기 위한 행정 지원이 필요하지 않습니다.
  디스크를 액세스 할 수있는 프로그램은 SQLite는 데이터베이스를 사용할 수있다.</p>

<p>한편, 서버를 사용하는 데이터베이스 엔진이 클라이언트 응용 프로그램의 버그에서 더 나은 보호를 제공 할 수 있습니다 - 클라이언트에서 길잃은 포인터를 할 수있는 서버에없는 메모리가 손상. 서버가 하나의 영구 프로세스이기 때문에, 그것을 미세한 입자 로킹 나은 동시성 수보다 정밀하게 제어 할 수 데이터베이스 액세스이다.</p>

<p>대부분의 SQL 데이터베이스 엔진은 클라이언트 / 서버 기반으로합니다. 서버없는 것을이 중 SQLite는 그 다수의 애플리케이션들이 동시에 동일한 데이터베이스에 액세스 할 수의 필자가 알고있는 유일한 것이다.</p>

<ul>
<li>
<p>Single Database File</p>

<ul>
<li>아무 곳이나 디렉토리 계층에 위치 할 수있는 하나의 일반 디스크 파일입니다.</li>
</ul>
</li>
<li>
<p>Stable Cross-Platform Database File (안정적인 크로스-플랫폼 데이터베이스 파일)</p>

<ul>
<li>파일 형식은 크로스 플랫폼, 모든 시스템은 동일한 파일 형식을 사용.</li>
<li>하나의 시스템에 작성된 DB 파일에 복사하고 다른 아키텍처를 다른 컴퓨터에서 사용 가능.</li>
<li>빅 - 엔디안 또는 리틀 엔디안, 32 bit 또는 64 bit는 중요하지 않음.</li>
<li>또한, 개발자들은 SQLite는 최신 버전의 읽기 및 이전 데이터베이스 파일을 작성할 수 있도록 안정적이고 호환 파일 형식을 유지하기로 약속했다. (대부분의 다른 SQL 데이터베이스 엔진은 최신 버전의 소프트웨어로 업그레이드 할 때 자주 한 플랫폼에서 다른 플랫폼으로 이동할 때 덤프하고 데이터베이스를 복원 할 필요합니다)</li>
</ul>
</li>
<li>
<p>Compact (실속있는)</p>

<ul>
<li>크기에 최적화 할 때 사용할 수있는 모든과 전체 SQLite는 라이브러리입니다 크기 500KiB 이하 (GNU 컴파일러 스위트에서 "크기"유틸리티를 사용하여 ix86에에 측정.)</li>
<li>불필요한 기능은 더욱 감소 컴파일 시간에 비활성화 할 수 있습니다 300KiB 아래에 라이브러리의 크기를 원하는 경우.</li>
</ul>
</li>
<li><p>Manifest typeing (매니페스트 입력)</p></li>
</ul>

<p>대부분의 SQL 데이터베이스 엔진은 정적 입력을 사용합니다. 데이터 형식이 테이블과 특정 데이터 유형의 값에서 각 컬럼과 연관된 해당 컬럼에 저장 될 수 있습니다.</p>

<p>SQLite는 매니페스트 입력을 사용하여이 제한을 완화. 매니페스트 입력에서 데이터 유형은 값 자체의 속성이며, 열의있는 값은 저장되지 않습니다. SQLite는 따라서 사용자가 해당 컬럼의 선언 된 유형에 관계없이 모든 컬럼에 모든 데이터 유형의 값을 저장할 수 있습니다. (: 정수 PRIMARY KEY 열 수도에만 저장 정수 그리고 SQLite는 컬럼의 선언 된 데이터 유형 때 수에 값을 강요하는 시도가이 규칙에 예외이다.).</p>

<p>지금까지 우리가 말할 수있는, SQL 언어 사양은 매니페스트 입력을 사용할 수 있습니다. 그럼에도 불구하고, 대부분의 다른 SQL 데이터베이스 엔진은 정적으로 입력하고, 그래서 어떤 사람들은 매니페스트 입력의 사용은 SQLite는 버그가 있다고 생각합니다. 하지만 SQLite는의 저자는 매우 강력하게이 기능이라고 생각합니다. SQLite는의 매니페스트 입력의 사용은 티클이나 Python과 같이 동적으로 입력 된 프로그래밍 언어와 함께 사용 특히, 사용하는 SQLite는보다 안정적이고 쉽게하기 위해 실제로 입증 신중한 디자인 결정이다.</p>

<ul>
<li>Variable-length records (가변 길이 레코드)</li>
</ul>

<p>대부분의 다른 SQL 데이터베이스 엔진은 대부분 테이블의 각 행에 대해 디스크 공간의 고정 된 양을 할당. 그들은에 BLOB과 격렬하게 다양한 길이 될 수 CLOB의 처리를위한 특별한 트릭을 재생할 수 있습니다. 그러나 대부분의 테이블에, 당신이라면 데이터베이스 엔진에 관계없이 실제로 해당 열에 저장 정보의 양의 디스크 공간이 100 바이트를 할당하는 VARCHAR (100)이 될 수있는 열을 선언합니다.</p>

<p>SQLite는 반대로, 실제로는 연속 된 정보를 저장하는 데 필요한 디스크 공간의 양을 사용한다.</p>

<p>당신은 VARCHAR (100) 열에서 하나의 문자를 저장하는 경우, 디스크 공간 만 단일 바이트가 소비된다.</p>

<p>(실제로는 두 바이트 - 데이터 유형의 길이를 기록하는 각각의 컬럼의 처음에 오버 헤드가 있다.)</p>

<p>SQLite는 의한 가변 길이 레코드의 사용은 많은 장점을 가지고있다. 그것은 분명, 작은 데이터베이스 파일에 발생합니다. 와 디스크에서 이동 적은 정보가 있기 때문에 또한, 데이터베이스 실행 속도합니다. 그리고 가변 길이 레코드를 사용함으로써 SQLite는 대신 정적 타이핑 매니페스트 입력을 채택 할 수있다.</p>

<ul>
<li>Readable source code (읽을 수있는 소스 코드)</li>
</ul>

<p>SQLite 소스 코드는 평균 프로그래머 읽고 액세스 할 수 있도록 설계되어 있음.</p>

<ul>
<li>SQL statements compile into virtual machine code (SQL 문은 가상 머신 코드로 컴파일)</li>
</ul>

<p>모든 SQL 데이터베이스 엔진은 명령문의 작업을 수행하는 데 사용되는 내부 데이터 구조의 일종으로, 각 SQL 문을 컴파일한다. 그러나 대부분의 SQL 엔진 내부 데이터 구조는 상호 구조와 오브젝트의 복잡한 웹된다. SQLite는에서, 문장의 컴파일 된 형태의 표현과 같은 기계 언어의 짧은 프로그램입니다. 데이터베이스의 사용자는이 볼 수있는 가상 컴퓨터 언어를 앞두고 붙이는 것에 의해 EXPLAIN 쿼리에 키워드를.</p>

<p>SQLite는의 가상 머신의 사용은 도서관의 발전에 큰 도움이되고있다. 가상 머신은 SQLite는과 백 엔드 (가상 컴퓨터 코드를 실행하고 결과를 계산하는 부분 (SQL 문을 구문 분석하고 가상 머신 코드를 생성하는 부분)의 프론트 엔드 사이에 선명하고 잘 정의 된 연결을 제공합니다. ) 가상 머신은 개발자가 명확하게 볼 SQLite는 디버깅에 엄청난 도움이됩니다 그것을 컴파일 각 문장으로 일을하려고 무엇 쉽게 읽을 수있는 형태로 할 수 있습니다. 실행하면서 인쇄 각 가상 기계 명령어와 그 결과 -이 컴파일 방법에 따라, SQLite는 또한 가상 머신의 실행을 추적하는 기능이 있습니다.</p>

<ul>
<li><p>Pubile domain (공개)</p></li>
<li>
<p>SQL language extensions (SQL 언어 확장)</p>

<ul>
<li>Explain 스 키워드 및 매니페스트 입력.</li>
<li>지원 ATTACH 및 DETACH 여러 개의 독립적인 DB 가 동일한 쿼리에서 함께 사용할 수 있도록 명령을.</li>
<li>사용자에 의한 추가.</li>
</ul>
</li>
</ul>

<h2 id="usage">Usage</h2>

<ul>
<li><p>자동완성은 아쉽게도 readline 으로 한다고 하는데 나는 잘 안된다.</p></li>
<li><p>Query 는 일반 SQL 과 비슷한데, 다만 SQLite Commands 알아야 함.</p></li>
<li><p>SQLite3 Comamnds 는 OneLine Doc 또는 .help 를 보고했다.</p></li>
<li>
<p>File Create (현재 작업한 내용, 처음에만)</p>
<div class="highlight"><pre><code class="language-" data-lang="">.backup 파일명.db
</code></pre></div>
</li>
<li>
<p>File Update (모든 수정)</p>
<div class="highlight"><pre><code class="language-" data-lang="">.dump 파일명.db
</code></pre></div>
</li>
<li>
<p>Files Load (옵션은 확인해서 추가한 내용임)</p>
<div class="highlight"><pre><code class="language-" data-lang="">&gt; sqlite3 -column -header 파일명.db
</code></pre></div>
</li>
</ul>

<h1 id="reference-url"><em>Reference.URL</em></h1>

<p><a href="https://sqlite.org/docs.html" rel="nofollow" target="_blank">https://sqlite.org/docs.html</a></p>

<p><a href="https://sqlite.org/different.html" rel="nofollow" target="_blank">https://sqlite.org/different.html</a></p>

<p><a href="https://sqlite.org/datatype3.html" rel="nofollow" target="_blank">https://sqlite.org/datatype3.html</a></p>

<p><a href="http://www.sqlite.org/cli.html" rel="nofollow" target="_blank">http://www.sqlite.org/cli.html</a></p>

</div>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/blog/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">Portal2312&#39;s blog</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">Portal2312&#39;s blog</li><li><a class="u-email" href="mailto:portal2312@gmail.com">portal2312@gmail.com</a></li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/portal2312"><svg class="svg-icon"><use xlink:href="/blog/assets/minima-social-icons.svg#github"></use></svg> <span class="username">portal2312</span></a></li><li><a href="https://www.twitter.com/portal2312"><svg class="svg-icon"><use xlink:href="/blog/assets/minima-social-icons.svg#twitter"></use></svg> <span class="username">portal2312</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>Welcome to my blog.</p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
