<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.6.1 -->
<title>HTTP 개요 | Portal2312&#39;s blog</title>
<meta name="generator" content="Jekyll v3.8.6" />
<meta property="og:title" content="HTTP 개요" />
<meta name="author" content="mkkim" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="HTTP는 HTML 문서와 같은 리소스들을 가져올 수 있도록 해주는 프로토콜(protocol)입니다." />
<meta property="og:description" content="HTTP는 HTML 문서와 같은 리소스들을 가져올 수 있도록 해주는 프로토콜(protocol)입니다." />
<link rel="canonical" href="http://localhost:4000/blog/docs/develop/protocol/HTTP/01_overview.html" />
<meta property="og:url" content="http://localhost:4000/blog/docs/develop/protocol/HTTP/01_overview.html" />
<meta property="og:site_name" content="Portal2312&#39;s blog" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2019-11-06T09:31:12+09:00" />
<script type="application/ld+json">
{"description":"HTTP는 HTML 문서와 같은 리소스들을 가져올 수 있도록 해주는 프로토콜(protocol)입니다.","headline":"HTTP 개요","dateModified":"2019-11-06T09:31:12+09:00","datePublished":"2019-11-06T09:31:12+09:00","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/blog/docs/develop/protocol/HTTP/01_overview.html"},"url":"http://localhost:4000/blog/docs/develop/protocol/HTTP/01_overview.html","author":{"@type":"Person","name":"mkkim"},"@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href='/blog/assets/main.css'><link type="application/atom+xml" rel="alternate" href="http://localhost:4000/blog/feed.xml" title="Portal2312's blog" /><script src='/blog/dist/js/common.bundle.js'></script>
</head>
<body><header class="site-header" role="banner">
  <div class="wrapper">
    <a class="site-title" rel="author" href="/blog/">Portal2312&#39;s blog</a>
    <nav class="site-nav">
    <input type="checkbox" id="nav-trigger" class="nav-trigger" />
    <label for="nav-trigger">
      <span class="menu-icon">
        <svg viewBox="0 0 18 15" width="18px" height="15px">
          <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
        </svg>
      </span>
    </label>

    <div class="trigger"><a class="page-link" href="/blog/about.html">
            About
          </a><a class="page-link" href="/blog/posts.html">
            Posts
          </a><a class="page-link" href="/blog/history.html">
            History
          </a><a class="page-link" href="/blog/docs/index.html">
            Docs
          </a></div>
  </nav>
  </div>
  <div class="scroll-indicator-container">
  <div class="scroll-indicator-bar" id="scrollIndicatorBar"></div>
</div>

</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <h1>HTTP 개요</h1>

  <div>
    <h2>Table of contents</h2>
    <ul class="section-nav">
<li class="toc-entry toc-h2"><a href="#http">HTTP 기반 시스템의 컴포넌트</a>
<ul>
<li class="toc-entry toc-h3"><a href="#client">Client: 사용자 에이전트</a></li>
<li class="toc-entry toc-h3"><a href="#web-server">Web Server</a></li>
<li class="toc-entry toc-h3"><a href="#proxy">Proxy</a></li>
</ul>
</li>
<li class="toc-entry toc-h2"><a href="#http">HTTP의 기초적인 측면</a>
<ul>
<li class="toc-entry toc-h3"><a href="#http">HTTP은 간단합니다</a></li>
<li class="toc-entry toc-h3"><a href="#http">HTTP은 확장 가능합니다</a></li>
<li class="toc-entry toc-h3"><a href="#http">HTTP은 상태가 없지만, 세션은 있습니다</a></li>
<li class="toc-entry toc-h3"><a href="#http">HTTP와 커넥션</a></li>
</ul>
</li>
<li class="toc-entry toc-h2"><a href="#http">HTTP로 제어할 수 있는 것</a></li>
<li class="toc-entry toc-h2"><a href="#http">HTTP 흐름</a></li>
<li class="toc-entry toc-h2"><a href="#http">HTTP 메시지</a>
<ul>
<li class="toc-entry toc-h3"><a href="#request">Request</a></li>
<li class="toc-entry toc-h3"><a href="#response">Response</a></li>
</ul>
</li>
<li class="toc-entry toc-h2"><a href="#part-65436afb15d">결론</a></li>
<li class="toc-entry toc-h2"><a href="#references">References</a></li>
</ul><p>HTTP는 HTML 문서와 같은 리소스들을 가져올 수 있도록 해주는 프로토콜(protocol)입니다.</p>

<p>그것은 보통 브라우저인 수신자에 의해 요청이 초기화되는 것을 의미하는, 웹과 클라이언트-서버 모델 상에서 모든 데이터 교환의 기초입니다.</p>

<p>하나의 완전한 문서는 페치(Fetch)된 또 다른 하위 문서, 텍스트, 레이아웃 설명, 이미지, 비디오, 스크립트 등으로 구성됩니다.</p>

<p><img src="./img/Fetching_a_page.png" alt="Fetching_a_page"></p>

<p>클라이언트와 서버들은 (데이터 스트림과 대조적으로) 개별적인 메시지 교환에 의해 통신합니다.</p>

<p>보통 브라우저인 클라이언트에 의해 전송되는 메시지를 리퀘스트(request) 라고 부르며, 그에 대해 서버에서 응답으로 전송되는 메시지를 리스폰(response)라고 부릅니다.</p>

<p><img src="./img/HTTP%20&amp;%20layers.png" alt="HTTP &amp; layers"></p>

<p>1990년대 초에 설계된 HTTP는 거듭하여 진화해온 확장 가능한 프로토콜입니다.</p>

<p>HTTP는 애플리케이션 계층의 프로토콜로, 신뢰 가능한 전송 프로토콜이라면 이론상으로는 무엇이든 사용할 수 있으나 TCP 혹은 암호화된 TCP 연결인 TLS을 통해 전송합니다.</p>

<p>그것의 확장성 덕분에, 오늘날 하이퍼텍스트 문서 뿐만 아니라, 이미지와 비디오 혹은 HTML 폼 결과와 같은 내용을 서버로 포스트(POST)하기 위해서도 사용됩니다.</p>

<p>HTTP는 또한 온디멘드 방식으로 웹 페이지를 갱신하기 위해 문서의 일부를 가져오는데 사용될 수도 있습니다.</p>

<hr>

<h2 id="http">
<a class="anchor" href="#http" aria-hidden="true"><span class="octicon octicon-link"></span></a>HTTP 기반 시스템의 컴포넌트</h2>

<p>HTTP는 클라이언트-서버 프로토콜입니다: 요청은 하나의 개체, 사용자 에이전트(또는 그것을 대신하는 프록시)에 의해 전송됩니다.</p>

<p>대부분의 경우, 사용자 에이전트는 브라우저지만, 무엇이든 될 수 있습니다.</p>

<p>예를 들어, 검색 엔진 인덱스를 채워넣고 유지하기 위해 웹을 돌아다니는 로봇이 그러한 경우입니다.</p>

<p>각각의 개별적인 요청들은 서버로 보내져 처리되어 response라고 불리는 객체를 서버로부터 돌려받습니다.</p>

<p>예를 들자면, 요청과 응답 사이에 많은 개체들이 존재하는 가운데, 다른 동작을 수행하며 게이트웨이 혹은 caches로써 활동하는 proxies로써 총괄적으로 고안된 것도 있습니다.</p>

<p><code>Client</code> &lt;--&gt; <code>Proxy</code> &lt;--&gt; <code>Proxy</code> &lt;--&gt; <code>Server</code></p>

<p>실제로는 브라우저와 요청을 처리하는 서버 사이에는 좀 더 많은 컴퓨터들이 존재합니다: 라우터, 모뎀 등이 있죠.</p>

<p>웹의 계층적인 설계 덕분에, 이들은 네트워크와 전송 계층 내로 숨겨집니다.</p>

<p>HTTP은 애플리케이션 계층의 최상위에 있습니다.</p>

<p>네트워크 문제를 분석하는 것도 중요하지만, 기본 레이어들은 HTTP의 명세와는 거의 관련이 없습니다.</p>

<p>p.s Client와 Server 사이의 Request and Responses가 진행되는 가운데에, 실제로는 그 사이에 여러 컴퓨터를 거쳐서 이루어지겠지만, 이에 대한 기술적인 문제는 다른 좀더 낮은 수준의 계층에서 신경써질 문제이므로 HTTP 계층과는 거의 관련이 없습니다.</p>

<h3 id="client">
<a class="anchor" href="#client" aria-hidden="true"><span class="octicon octicon-link"></span></a>Client: 사용자 에이전트</h3>

<p>문자 그대로, 사용자 에이전트는 사용자를 대신하여 동작하는 모든 도구입니다.
실제적으로, 이 역할은 <strong>브라우저</strong>에 의해 수행됩니다; 엔지니어들과 자신들의 애플리케이션을 디버그하는 웹 개발자들이 사용하는 프로그램들은 예외입니다.</p>

<p>브라우저는 <strong>항상</strong> <em>Request</em>를 보내는 개체입니다.
그것은 결코 서버가 될 수 없습니다(수년에 걸쳐 서버 초기화된 메시지를 시뮬레이션하기 위해 몇 가지 메커니즘이 추가되어 왔지만).</p>

<p>웹 페이지를 표시하기 위해, 브라우저는 페이지의 HTML 문서를 가져오기 위한 request를 전송한 뒤, 파일을 구문 분석하여 실행해야 할 스크립트 그리고 페이지 내 포함된 하위 리소스들(보통 이미지와 비디오)을 잘 표시하기 위한 레이아웃 정보(CSS)에 대응하는 추가적인 요청들을 가져옵니다.</p>

<p>그런 뒤에 브라우저는 완전한 문서인 웹 페이지를 표시하기 위해 그런 리소스들을 혼합합니다.</p>

<p>브라우저에 의해 실행된 스크립트는 이후 단계에서 좀 더 많은 리소스들을 가져올 수 있으며 브라우저는 그에 따라 웹 페이지를 갱신하게 됩니다.</p>

<p>웹 페이지는 하이퍼텍스트 문서로, 표시된 텍스트의 일부는 사용자가 사용자 에이전트를 제어하고 웹을 돌아다닐 수 있도록 새로운 웹 페이지를 가져오기 위해 실행(보통 마우스 클릭에 의해)될 수 있는 링크임을 뜻합니다.</p>

<p>브라우저는 <em>HTTP Request</em> 내에서 이런 지시 사항들을 변환하고 <em>HTTP Response</em>을 해석하여 사용자에게 명확한 응답을 표시합니다.</p>

<h3 id="web-server">
<a class="anchor" href="#web-server" aria-hidden="true"><span class="octicon octicon-link"></span></a>Web Server</h3>

<p>통신 채널의 반대편에는 <strong>Client</strong>에 의한 요청에 대한 문서를 제공하는 서버가 존재합니다.
Server는 사실 상 논리적으로 단일 기계입니다.
이는 로드(로드 밸런싱) 혹은 그때 그때 다른 컴퓨터(캐시, DB 서버, e-커머스 서버 등과 같은)들의 정보를 얻고 완전하게 혹은 부분적으로 문서를 생성하는 소프트웨어의 복잡한 부분을 공유하는 서버들의 집합일 수도 있기 때문입니다.</p>

<p>Server는 반드시 단일 서버일 필요는 없으며 여러 개의 서버들이 동일한 머신 위에서 호스트가 될 수도 있습니다.</p>

<p>HTTP/1.1과 Host 헤더를 이용하여, 동일한 IP 주소를 공유할 수도 있습니다.</p>

<h3 id="proxy">
<a class="anchor" href="#proxy" aria-hidden="true"><span class="octicon octicon-link"></span></a>Proxy</h3>

<p>브라우저와 서버 사이에는, 많은 컴퓨터들과 머신들을 통해서 HTTP 메시지를 릴레이(relay)합니다.</p>

<p>웹 스택의 계층 구조 덕분에, 그들 중 대부분은 전송, 네트워크 혹은 물리적 수준에서 동작하며, (그들이 성능 상 상당한 영향을 가지고 있음에도) HTTP 계층에서는 눈에 보이지 않습니다.</p>

<p>애플리케이션 계층에서 그렇게 릴레이(relay)하는 것을 일반적으로 <strong>Proxy</strong>라고 부릅니다.</p>

<p>그들은 눈에 보이거나 그렇지 않을 수도 있으며(프록시를 통해 요청이 변경되거나 변경되지 않는 경우를 말함) 다양한 기능들을 수행할 수 있습니다:</p>

<ul>
<li>캐싱 (캐시는 브라우저 캐시처럼 공개되거나 비공개될 수 있습니다)</li>
<li>필터링 (바이러스 백신 스캔, 유해 컨텐츠 차단 등과 같은)</li>
<li>여러 서버들이 서로 다른 요청을 처리하도록 해주는 로드 밸런싱</li>
<li>다른 리소스에 접근하도록 제어해주는 인증</li>
<li>이력 정보를 저장해주는 로깅</li>
</ul>

<hr>

<h2 id="http">
<a class="anchor" href="#http" aria-hidden="true"><span class="octicon octicon-link"></span></a>HTTP의 기초적인 측면</h2>

<h3 id="http">
<a class="anchor" href="#http" aria-hidden="true"><span class="octicon octicon-link"></span></a>HTTP은 간단합니다</h3>

<p>HTTP 메시지를 프레임 내로 캡슐화하도록 하는 HTTP/2에서 공개된 몇 가지 복잡한 내용이 있기는 하지만, HTTP는 일반적으로 사람이 읽을 수 있으며 간단하게 고안되었습니다.</p>

<p>HTTP 메시지들은 사람이 읽을 수 있고 이해하기 가능하도록 하여, 테스트하기 쉽고 초심자의 진입장벽을 낮췄습니다.</p>

<h3 id="http">
<a class="anchor" href="#http" aria-hidden="true"><span class="octicon octicon-link"></span></a>HTTP은 확장 가능합니다</h3>

<p>HTTP/1.0에서 소개된, HTTP 헤더는 프로토콜을 확장하고 실험하기 극도로 쉽게 만들어주었습니다.</p>

<p>새로운 기능은 클라이언트와 서버 사이에서 새로운 규약을 만들 수 있게 합니다.</p>

<h3 id="http">
<a class="anchor" href="#http" aria-hidden="true"><span class="octicon octicon-link"></span></a>HTTP은 상태가 없지만, 세션은 있습니다</h3>

<p>HTTP는 상태가 없습니다:</p>

<p>동일한 연결 상에서든 아닌든 성공적으로 완료된 두 개의 요청 사이에는 연결고리가 없습니다.</p>

<p>예를 들자면, 이것은 e-커머스 쇼핑 바구니처럼, 일관된 방식으로 사용자가 페이지와 상호작용하길 원할 때 문제가 됩니다.</p>

<p>하지만, <strong>헤더</strong> 확장성을 사용하여, 동일한 컨텍스트, 동일한 상태를 공유하기 위해 각각의 요청들에 세션을 만들도록 HTTP <strong>쿠키</strong>가 추가되었습니다.</p>

<p>HTTP의 핵심은 상태가 없는 것이지만 <strong>쿠키</strong>의 사용은 상태가 있는 <strong>세션</strong>을 만들도록 해줍니다.</p>

<h3 id="http">
<a class="anchor" href="#http" aria-hidden="true"><span class="octicon octicon-link"></span></a>HTTP와 커넥션</h3>

<p>연결은 전송 계층에서 제어되므로 근본적으로 HTTP 영역 밖입니다.</p>

<p>HTTP는 연결될 수 있도록 하는 근본적인 전송 프로토콜을 요구하지 않습니다만, 그저 메시지 손실이 없는(적어도 오류 메시지가 없지 않은) 신뢰도 있는 연결을 요구할 뿐입니다.</p>

<p>인터넷 상의 가장 일반적인 두 개의 전송 프로토콜 중에서 <strong>TCP</strong>는 신뢰성이 있으며 <strong>UDP</strong>는 그렇지 않습니다.</p>

<p>그러므로 HTTP는 필수는 아니지만 연결 기반이 될 수도 있는 <strong>TCP</strong>에 의존합니다.</p>

<p>HTTP/1.0에서는 요청/응답 교환에 대한 각각의 TCP 연결을 열었고, 두 개의 주요 문제점을 가지고 있습니다:
연결을 여는데는 메시지 각자의 왕복(round-trip)을 필요로 하므로 <strong>느립니다.</strong></p>

<p>그러나 그런 각각의 메시지들이 전송되고 규칙적으로 전송되는 경우에 좀 더 효과적으로 변합니다:
잦은 통신이 있는(warm) 커넥션이 한가한(cold) 커넥션보다 좀 더 효율적입니다.</p>

<p>이러한 결함을 개선하기 위해, HTTP/1.1은 (구현하기 어렵다고 입증된)파이프라이닝 개념과 지속적인 연결의 개념을 도입했습니다:
기본적인 TCP 연결을 Connection 헤더를 사용해 부분적으로 제어할 수 있습니다.
HTTP/2는 연결을 좀 더 활기차게 유지하는데 도움이 되도록, 단일 연결 상으로 메시지를 다중 전송(multiplex)하여 한 걸음 더 나아갔습니다.</p>

<p>HTTP에 더 알맞은 좀 더 나은 전송 프로토콜을 설계하는 실험이 진행 중에 있습니다. 예를 들어, 구글은 좀 더 신뢰성있고 효과적인 전송 프로토콜을 제공하기 위해 UDP를 잘 처리하여 빌드한 [QUIC]을 가지고 실험 중에 있습니다.</p>

<hr>

<h2 id="http">
<a class="anchor" href="#http" aria-hidden="true"><span class="octicon octicon-link"></span></a>HTTP로 제어할 수 있는 것</h2>

<p>HTTP의 확장 가능한 특성은 수년 간에 걸쳐 웹의 점점 더 많은 기능들을 제어하도록 허용되어 왔습니다. 캐시 혹은 인증 메서드는 HTTP에 초기부터 제어해왔던 기능이며, 반면에 origin 제약사항을 완화시키는 조치는 2010년에 들어서 추가되었습니다.</p>

<p>다음은 HTTP 사용하여 제어 가능한 일반적인 기능 목록입니다.</p>

<ul>
<li>캐시:</li>
</ul>

<p>HTTP로 문서가 캐시되는 방식을 제어할 수 있습니다. 서버는 캐시 대상과 기간을 프록시와 클라이언트에 지시할 수 있고 클라이언트는 저장된 문서를 무시하라고 중간 캐시 프록시에게 지시할 수 있습니다.</p>

<ul>
<li>origin 제약사항을 완화하기:</li>
</ul>

<p>스누핑과 다른 프라이버시 침해를 막기 위해, 브라우저는 웹 사이트 간의 엄격한 분리를 강제합니다. 동일한 origin으로부터 온 페이지만이 웹 페이지의 전체 정보에 접근할 수 있죠. 그런 제약 사항은 부담이 되지만, 서버는 HTTP 헤더를 통해 그것을 완화시킬 수 있습니다. 그런 덕분에 문서는 다른 도메인으로부터 전달된 정보를 패치워크할 수 있습니다(그렇게 하려면 어떤 경우에 보안과 관련된 사항이 있을 수도 있습니다).</p>

<ul>
<li>인증:</li>
</ul>

<p>어떤 페이지들은 보호되어 오로지 특정 사용자만이 그것에 접근할 수도 있습니다. 기본 인증은 Authenticate와 그와 유사한 헤더들을 사용해 HTTP에 의해 직접 제공될 수 있으며 혹은 HTTP 쿠키를 사용해 특정 세션을 설정하여 이루어질 수도 있습니다.</p>

<ul>
<li>프록시와 터널링:</li>
</ul>

<p>서버 혹은 클라이언트 혹은 그 둘 모두는 종종 인트라넷에 위치하며 다른 개체들에게 그들의 실제 주소를 숨기기도 합니다. HTTP 요청은 네트워크 장벅을 가로지르기 위해 프록시를 통해 나가게 되죠. 모든 프록시가 HTTP 프록시는 아니며, SOCKS 프로토콜을 사용하는 어떤 프록시들 같은 경우 저수준에서 동작합니다(프록시에 의해 처리될 수 있는 ftp와 같은 다른 프로토콜도 마찬가지입니다).</p>

<ul>
<li>세션:</li>
</ul>

<p>쿠키 사용은 서버 상태를 요청과 연결하도록 해줍니다. 이것은 HTTP가 기본적으로 상태없는 프로토콜임에도 세션을 만들어주는 계기가 됩니다. 이것은 e-커머스 쇼핑 바구니를 위해서 유용할 뿐만 아니라 출력 구성을 허용하는 모든 사이트에 대해서 유용합니다.</p>

<hr>

<h2 id="http">
<a class="anchor" href="#http" aria-hidden="true"><span class="octicon octicon-link"></span></a>HTTP 흐름</h2>

<p>클라이언트가 서버와 통신하고자 할 때, 최종 서버가 됐든 중간 프록시가 됐든, 다음 단계의 과정을 수행합니다:</p>

<ol>
<li>TCP 연결을 엽니다:</li>
</ol>

<p>TCP 연결은 request를 보내거나 여러 사람에게 response을 보내는데 사용됩니다.
  클라이언트는 새 연결을 열거나 기존 연결을 재사용하거나 서버에 대한 여러 TCP 연결을 열 수 있습니다.</p>

<ol>
<li>HTTP 메시지를 전송합니다:</li>
</ol>

<p>HTTP 메시지(HTTP/2 이전의)는 인간이 읽을 수 있습니다.
  HTTP/2에서는 이런 간단한 메시지가 프레임 속으로 캡슐화되어, 직접 읽는게 불가능하지만 원칙은 동일합니다.</p>
<div class="highlight"><pre><code class="language-" data-lang="">  GET / HTTP/1.1
  Host: developer.mozilla.org
  Accept-Language: fr
</code></pre></div>
<ol>
<li>서버에 의해 전송된 응답을 읽어들입니다:</li>
</ol>
<div class="highlight"><pre><code class="language-" data-lang="">  HTTP/1.1 200 OK
  Date: Sat, 09 Oct 2010 14:28:02 GMT
  Server: Apache
  Last-Modified: Tue, 01 Dec 2009 20:18:22 GMT
  ETag: "51142bc1-7449-479b075b2891b"
  Accept-Ranges: bytes
  Content-Length: 29769
  Content-Type: text/html

  &lt;!DOCTYPE html... (here comes the 29769 bytes of the requested web page)
</code></pre></div>
<ol>
<li>커넥션을 닫거나 다른 요청들을 위해 재사용합니다.</li>
</ol>

<p>HTTP 파이프라이닝이 활성화되면, 첫번째 응답을 완전히 수신할 때까지 기다리지 않고 여러 요청을 보낼 수 있습니다.</p>

<p>HTTP 파이프라이닝은 오래된 소프트웨어와 현재 버전이 공존하고 있는, 기존의 네트워크 상에서 구현하기 어렵다는게 입증되었으며, HTTP/2의 프레임 속 다중 요청의 좀 더 견고한 메커니즘으로 교체되고 있습니다.</p>

<hr>

<h2 id="http">
<a class="anchor" href="#http" aria-hidden="true"><span class="octicon octicon-link"></span></a>HTTP 메시지</h2>

<p>HTTP/1.1와 초기 HTTP 메시지는 사람이 읽을 수 있습니다.</p>

<p>HTTP/2에서, 이 메시지들은 새로운 이진 구조인 프레임 안으로 임베드되어, 헤더의 압축과 다중화와 같은 최적화를 가능케 합니다.</p>

<p>본래의 HTTP 메시지의 일부분만이 HTTP의 이 버전 내에서 전송된다고 할지라도, 각 메시지의 시맨틱들은 변화하지 않으며 클라이언트는 본래의 HTTP/1.1 요청을 (가상으로) 재구성합니다; 그러므로 HTTP/1.1 포맷 내에서 HTTP/2를 이해하는 것은 여전히 유용합니다.</p>

<p>HTTP 메시지의 두 가지 타입인 request와 response은 각자의 특성있는 형식을 가지고 있습니다.</p>

<h3 id="request">
<a class="anchor" href="#request" aria-hidden="true"><span class="octicon octicon-link"></span></a>Request</h3>

<p>HTTP Request의 예제:</p>

<p><img src="./img/HTTP_Request.png" alt="HTTP_Request"></p>

<p>request는 다음의 요소들로 구성됩니다:</p>

<ul>
<li><p>보통 <code>GET</code>, <code>POST</code> 같은 동사 혹은 <code>OPTIONS</code>나 <code>HEAD</code>와 같은 명사의 HTTP 메서드는 클라이언트가 실행하고자 하는 동작을 정의합니다.
일반적으로, 클라이언트는 리소스를 가져오거나(<code>GET</code>을 사용하여) HTML 폼의 데이터를 전송(<code>POST</code>를 사용하여)하려고 하지만, 다른 경우에는 다른 동작이 요구될 수도 있습니다.</p></li>
<li><p>가져오려는 리소스의 경로로, protocol (http://), domain (여기서는 developer.mozilla.org), 또는 TCP port (여기서는 80)인 요소들을 제거한 리소스의 URL입니다.</p></li>
<li><p>HTTP 프로토콜의 버전.</p></li>
<li><p>서버에 대한 추가 정보를 전달하는 선택적 헤더들.</p></li>
<li><p>POST와 같은 몇 가지 메서드를 위한, 전송된 리소스를 포함하는 response의 본문과 유사한 본문.</p></li>
</ul>

<h3 id="response">
<a class="anchor" href="#response" aria-hidden="true"><span class="octicon octicon-link"></span></a>Response</h3>

<p>응답의 예시:</p>

<p><img src="./img/HTTP_Response.png" alt="HTTP_Response"></p>

<p>Response은 다음의 요소들로 구성됩니다:</p>

<ul>
<li>HTTP 프로토콜의 버전.</li>
<li>요청의 성공 여부와, 그 이유를 나타내는 상태 코드.</li>
<li>아무런 영향력이 없는, 상태 코드의 짧은 설명을 나타내는 상태 메시지.</li>
<li>요청과 비슷한, HTTP 헤더들.</li>
<li>선택 사항으로, 요청의 경우보다는 좀 더 일반이며 가져온 리소스가 포함되는 본문.</li>
</ul>

<hr>

<h2 id="part-65436afb15d">
<a class="anchor" href="#part-65436afb15d" aria-hidden="true"><span class="octicon octicon-link"></span></a>결론</h2>

<p>HTTP는 사용이 쉬운 확장 가능한 프로토콜입니다.</p>

<p>헤더를 쉽게 추가하는 능력을 지닌 클라이언트-서버 구조는 HTTP가 웹의 확장된 수용력과 함께 발전할 수 있게 합니다.</p>

<p>HTTP/2가 성능 향상을 위해 HTTP 메시지를 프레임 내로 임베드하여 약간의 복잡함을 더했을지라도, 애플리케이션의 관점에서 볼 때, 메시지의 기본적인 구조는 HTTP/1.0이 릴리즈된 이후와 동일합니다. 세션의 흐름은 여전히 단순하여, 간단한 HTTP 메시지 모니터를 이용한 조사와 디버그를 가능하게 해줍니다.</p>

<hr>

<h2 id="references">
<a class="anchor" href="#references" aria-hidden="true"><span class="octicon octicon-link"></span></a>References</h2>

<p><a href="https://developer.mozilla.org/ko/docs/Web/HTTP/Overview">https://developer.mozilla.org/ko/docs/Web/HTTP/Overview</a></p>

  </div>

<div>
  <p>HTTP는 HTML 문서와 같은 리소스들을 가져올 수 있도록 해주는 프로토콜(protocol)입니다.</p>

<p>그것은 보통 브라우저인 수신자에 의해 요청이 초기화되는 것을 의미하는, 웹과 클라이언트-서버 모델 상에서 모든 데이터 교환의 기초입니다.</p>

<p>하나의 완전한 문서는 페치(Fetch)된 또 다른 하위 문서, 텍스트, 레이아웃 설명, 이미지, 비디오, 스크립트 등으로 구성됩니다.</p>

<p><img src="./img/Fetching_a_page.png" alt="Fetching_a_page"></p>

<p>클라이언트와 서버들은 (데이터 스트림과 대조적으로) 개별적인 메시지 교환에 의해 통신합니다.</p>

<p>보통 브라우저인 클라이언트에 의해 전송되는 메시지를 리퀘스트(request) 라고 부르며, 그에 대해 서버에서 응답으로 전송되는 메시지를 리스폰(response)라고 부릅니다.</p>

<p><img src="./img/HTTP%20&amp;%20layers.png" alt="HTTP &amp; layers"></p>

<p>1990년대 초에 설계된 HTTP는 거듭하여 진화해온 확장 가능한 프로토콜입니다.</p>

<p>HTTP는 애플리케이션 계층의 프로토콜로, 신뢰 가능한 전송 프로토콜이라면 이론상으로는 무엇이든 사용할 수 있으나 TCP 혹은 암호화된 TCP 연결인 TLS을 통해 전송합니다.</p>

<p>그것의 확장성 덕분에, 오늘날 하이퍼텍스트 문서 뿐만 아니라, 이미지와 비디오 혹은 HTML 폼 결과와 같은 내용을 서버로 포스트(POST)하기 위해서도 사용됩니다.</p>

<p>HTTP는 또한 온디멘드 방식으로 웹 페이지를 갱신하기 위해 문서의 일부를 가져오는데 사용될 수도 있습니다.</p>

<hr>

<h2 id="http">HTTP 기반 시스템의 컴포넌트</h2>

<p>HTTP는 클라이언트-서버 프로토콜입니다: 요청은 하나의 개체, 사용자 에이전트(또는 그것을 대신하는 프록시)에 의해 전송됩니다.</p>

<p>대부분의 경우, 사용자 에이전트는 브라우저지만, 무엇이든 될 수 있습니다.</p>

<p>예를 들어, 검색 엔진 인덱스를 채워넣고 유지하기 위해 웹을 돌아다니는 로봇이 그러한 경우입니다.</p>

<p>각각의 개별적인 요청들은 서버로 보내져 처리되어 response라고 불리는 객체를 서버로부터 돌려받습니다.</p>

<p>예를 들자면, 요청과 응답 사이에 많은 개체들이 존재하는 가운데, 다른 동작을 수행하며 게이트웨이 혹은 caches로써 활동하는 proxies로써 총괄적으로 고안된 것도 있습니다.</p>

<p><code>Client</code> &lt;--&gt; <code>Proxy</code> &lt;--&gt; <code>Proxy</code> &lt;--&gt; <code>Server</code></p>

<p>실제로는 브라우저와 요청을 처리하는 서버 사이에는 좀 더 많은 컴퓨터들이 존재합니다: 라우터, 모뎀 등이 있죠.</p>

<p>웹의 계층적인 설계 덕분에, 이들은 네트워크와 전송 계층 내로 숨겨집니다.</p>

<p>HTTP은 애플리케이션 계층의 최상위에 있습니다.</p>

<p>네트워크 문제를 분석하는 것도 중요하지만, 기본 레이어들은 HTTP의 명세와는 거의 관련이 없습니다.</p>

<p>p.s Client와 Server 사이의 Request and Responses가 진행되는 가운데에, 실제로는 그 사이에 여러 컴퓨터를 거쳐서 이루어지겠지만, 이에 대한 기술적인 문제는 다른 좀더 낮은 수준의 계층에서 신경써질 문제이므로 HTTP 계층과는 거의 관련이 없습니다.</p>

<h3 id="client">Client: 사용자 에이전트</h3>

<p>문자 그대로, 사용자 에이전트는 사용자를 대신하여 동작하는 모든 도구입니다.
실제적으로, 이 역할은 <strong>브라우저</strong>에 의해 수행됩니다; 엔지니어들과 자신들의 애플리케이션을 디버그하는 웹 개발자들이 사용하는 프로그램들은 예외입니다.</p>

<p>브라우저는 <strong>항상</strong> <em>Request</em>를 보내는 개체입니다.
그것은 결코 서버가 될 수 없습니다(수년에 걸쳐 서버 초기화된 메시지를 시뮬레이션하기 위해 몇 가지 메커니즘이 추가되어 왔지만).</p>

<p>웹 페이지를 표시하기 위해, 브라우저는 페이지의 HTML 문서를 가져오기 위한 request를 전송한 뒤, 파일을 구문 분석하여 실행해야 할 스크립트 그리고 페이지 내 포함된 하위 리소스들(보통 이미지와 비디오)을 잘 표시하기 위한 레이아웃 정보(CSS)에 대응하는 추가적인 요청들을 가져옵니다.</p>

<p>그런 뒤에 브라우저는 완전한 문서인 웹 페이지를 표시하기 위해 그런 리소스들을 혼합합니다.</p>

<p>브라우저에 의해 실행된 스크립트는 이후 단계에서 좀 더 많은 리소스들을 가져올 수 있으며 브라우저는 그에 따라 웹 페이지를 갱신하게 됩니다.</p>

<p>웹 페이지는 하이퍼텍스트 문서로, 표시된 텍스트의 일부는 사용자가 사용자 에이전트를 제어하고 웹을 돌아다닐 수 있도록 새로운 웹 페이지를 가져오기 위해 실행(보통 마우스 클릭에 의해)될 수 있는 링크임을 뜻합니다.</p>

<p>브라우저는 <em>HTTP Request</em> 내에서 이런 지시 사항들을 변환하고 <em>HTTP Response</em>을 해석하여 사용자에게 명확한 응답을 표시합니다.</p>

<h3 id="web-server">Web Server</h3>

<p>통신 채널의 반대편에는 <strong>Client</strong>에 의한 요청에 대한 문서를 제공하는 서버가 존재합니다.
Server는 사실 상 논리적으로 단일 기계입니다.
이는 로드(로드 밸런싱) 혹은 그때 그때 다른 컴퓨터(캐시, DB 서버, e-커머스 서버 등과 같은)들의 정보를 얻고 완전하게 혹은 부분적으로 문서를 생성하는 소프트웨어의 복잡한 부분을 공유하는 서버들의 집합일 수도 있기 때문입니다.</p>

<p>Server는 반드시 단일 서버일 필요는 없으며 여러 개의 서버들이 동일한 머신 위에서 호스트가 될 수도 있습니다.</p>

<p>HTTP/1.1과 Host 헤더를 이용하여, 동일한 IP 주소를 공유할 수도 있습니다.</p>

<h3 id="proxy">Proxy</h3>

<p>브라우저와 서버 사이에는, 많은 컴퓨터들과 머신들을 통해서 HTTP 메시지를 릴레이(relay)합니다.</p>

<p>웹 스택의 계층 구조 덕분에, 그들 중 대부분은 전송, 네트워크 혹은 물리적 수준에서 동작하며, (그들이 성능 상 상당한 영향을 가지고 있음에도) HTTP 계층에서는 눈에 보이지 않습니다.</p>

<p>애플리케이션 계층에서 그렇게 릴레이(relay)하는 것을 일반적으로 <strong>Proxy</strong>라고 부릅니다.</p>

<p>그들은 눈에 보이거나 그렇지 않을 수도 있으며(프록시를 통해 요청이 변경되거나 변경되지 않는 경우를 말함) 다양한 기능들을 수행할 수 있습니다:</p>

<ul>
<li>캐싱 (캐시는 브라우저 캐시처럼 공개되거나 비공개될 수 있습니다)</li>
<li>필터링 (바이러스 백신 스캔, 유해 컨텐츠 차단 등과 같은)</li>
<li>여러 서버들이 서로 다른 요청을 처리하도록 해주는 로드 밸런싱</li>
<li>다른 리소스에 접근하도록 제어해주는 인증</li>
<li>이력 정보를 저장해주는 로깅</li>
</ul>

<hr>

<h2 id="http">HTTP의 기초적인 측면</h2>

<h3 id="http">HTTP은 간단합니다</h3>

<p>HTTP 메시지를 프레임 내로 캡슐화하도록 하는 HTTP/2에서 공개된 몇 가지 복잡한 내용이 있기는 하지만, HTTP는 일반적으로 사람이 읽을 수 있으며 간단하게 고안되었습니다.</p>

<p>HTTP 메시지들은 사람이 읽을 수 있고 이해하기 가능하도록 하여, 테스트하기 쉽고 초심자의 진입장벽을 낮췄습니다.</p>

<h3 id="http">HTTP은 확장 가능합니다</h3>

<p>HTTP/1.0에서 소개된, HTTP 헤더는 프로토콜을 확장하고 실험하기 극도로 쉽게 만들어주었습니다.</p>

<p>새로운 기능은 클라이언트와 서버 사이에서 새로운 규약을 만들 수 있게 합니다.</p>

<h3 id="http">HTTP은 상태가 없지만, 세션은 있습니다</h3>

<p>HTTP는 상태가 없습니다:</p>

<p>동일한 연결 상에서든 아닌든 성공적으로 완료된 두 개의 요청 사이에는 연결고리가 없습니다.</p>

<p>예를 들자면, 이것은 e-커머스 쇼핑 바구니처럼, 일관된 방식으로 사용자가 페이지와 상호작용하길 원할 때 문제가 됩니다.</p>

<p>하지만, <strong>헤더</strong> 확장성을 사용하여, 동일한 컨텍스트, 동일한 상태를 공유하기 위해 각각의 요청들에 세션을 만들도록 HTTP <strong>쿠키</strong>가 추가되었습니다.</p>

<p>HTTP의 핵심은 상태가 없는 것이지만 <strong>쿠키</strong>의 사용은 상태가 있는 <strong>세션</strong>을 만들도록 해줍니다.</p>

<h3 id="http">HTTP와 커넥션</h3>

<p>연결은 전송 계층에서 제어되므로 근본적으로 HTTP 영역 밖입니다.</p>

<p>HTTP는 연결될 수 있도록 하는 근본적인 전송 프로토콜을 요구하지 않습니다만, 그저 메시지 손실이 없는(적어도 오류 메시지가 없지 않은) 신뢰도 있는 연결을 요구할 뿐입니다.</p>

<p>인터넷 상의 가장 일반적인 두 개의 전송 프로토콜 중에서 <strong>TCP</strong>는 신뢰성이 있으며 <strong>UDP</strong>는 그렇지 않습니다.</p>

<p>그러므로 HTTP는 필수는 아니지만 연결 기반이 될 수도 있는 <strong>TCP</strong>에 의존합니다.</p>

<p>HTTP/1.0에서는 요청/응답 교환에 대한 각각의 TCP 연결을 열었고, 두 개의 주요 문제점을 가지고 있습니다:
연결을 여는데는 메시지 각자의 왕복(round-trip)을 필요로 하므로 <strong>느립니다.</strong></p>

<p>그러나 그런 각각의 메시지들이 전송되고 규칙적으로 전송되는 경우에 좀 더 효과적으로 변합니다:
잦은 통신이 있는(warm) 커넥션이 한가한(cold) 커넥션보다 좀 더 효율적입니다.</p>

<p>이러한 결함을 개선하기 위해, HTTP/1.1은 (구현하기 어렵다고 입증된)파이프라이닝 개념과 지속적인 연결의 개념을 도입했습니다:
기본적인 TCP 연결을 Connection 헤더를 사용해 부분적으로 제어할 수 있습니다.
HTTP/2는 연결을 좀 더 활기차게 유지하는데 도움이 되도록, 단일 연결 상으로 메시지를 다중 전송(multiplex)하여 한 걸음 더 나아갔습니다.</p>

<p>HTTP에 더 알맞은 좀 더 나은 전송 프로토콜을 설계하는 실험이 진행 중에 있습니다. 예를 들어, 구글은 좀 더 신뢰성있고 효과적인 전송 프로토콜을 제공하기 위해 UDP를 잘 처리하여 빌드한 [QUIC]을 가지고 실험 중에 있습니다.</p>

<hr>

<h2 id="http">HTTP로 제어할 수 있는 것</h2>

<p>HTTP의 확장 가능한 특성은 수년 간에 걸쳐 웹의 점점 더 많은 기능들을 제어하도록 허용되어 왔습니다. 캐시 혹은 인증 메서드는 HTTP에 초기부터 제어해왔던 기능이며, 반면에 origin 제약사항을 완화시키는 조치는 2010년에 들어서 추가되었습니다.</p>

<p>다음은 HTTP 사용하여 제어 가능한 일반적인 기능 목록입니다.</p>

<ul>
<li>캐시:</li>
</ul>

<p>HTTP로 문서가 캐시되는 방식을 제어할 수 있습니다. 서버는 캐시 대상과 기간을 프록시와 클라이언트에 지시할 수 있고 클라이언트는 저장된 문서를 무시하라고 중간 캐시 프록시에게 지시할 수 있습니다.</p>

<ul>
<li>origin 제약사항을 완화하기:</li>
</ul>

<p>스누핑과 다른 프라이버시 침해를 막기 위해, 브라우저는 웹 사이트 간의 엄격한 분리를 강제합니다. 동일한 origin으로부터 온 페이지만이 웹 페이지의 전체 정보에 접근할 수 있죠. 그런 제약 사항은 부담이 되지만, 서버는 HTTP 헤더를 통해 그것을 완화시킬 수 있습니다. 그런 덕분에 문서는 다른 도메인으로부터 전달된 정보를 패치워크할 수 있습니다(그렇게 하려면 어떤 경우에 보안과 관련된 사항이 있을 수도 있습니다).</p>

<ul>
<li>인증:</li>
</ul>

<p>어떤 페이지들은 보호되어 오로지 특정 사용자만이 그것에 접근할 수도 있습니다. 기본 인증은 Authenticate와 그와 유사한 헤더들을 사용해 HTTP에 의해 직접 제공될 수 있으며 혹은 HTTP 쿠키를 사용해 특정 세션을 설정하여 이루어질 수도 있습니다.</p>

<ul>
<li>프록시와 터널링:</li>
</ul>

<p>서버 혹은 클라이언트 혹은 그 둘 모두는 종종 인트라넷에 위치하며 다른 개체들에게 그들의 실제 주소를 숨기기도 합니다. HTTP 요청은 네트워크 장벅을 가로지르기 위해 프록시를 통해 나가게 되죠. 모든 프록시가 HTTP 프록시는 아니며, SOCKS 프로토콜을 사용하는 어떤 프록시들 같은 경우 저수준에서 동작합니다(프록시에 의해 처리될 수 있는 ftp와 같은 다른 프로토콜도 마찬가지입니다).</p>

<ul>
<li>세션:</li>
</ul>

<p>쿠키 사용은 서버 상태를 요청과 연결하도록 해줍니다. 이것은 HTTP가 기본적으로 상태없는 프로토콜임에도 세션을 만들어주는 계기가 됩니다. 이것은 e-커머스 쇼핑 바구니를 위해서 유용할 뿐만 아니라 출력 구성을 허용하는 모든 사이트에 대해서 유용합니다.</p>

<hr>

<h2 id="http">HTTP 흐름</h2>

<p>클라이언트가 서버와 통신하고자 할 때, 최종 서버가 됐든 중간 프록시가 됐든, 다음 단계의 과정을 수행합니다:</p>

<ol>
<li>TCP 연결을 엽니다:</li>
</ol>

<p>TCP 연결은 request를 보내거나 여러 사람에게 response을 보내는데 사용됩니다.
  클라이언트는 새 연결을 열거나 기존 연결을 재사용하거나 서버에 대한 여러 TCP 연결을 열 수 있습니다.</p>

<ol>
<li>HTTP 메시지를 전송합니다:</li>
</ol>

<p>HTTP 메시지(HTTP/2 이전의)는 인간이 읽을 수 있습니다.
  HTTP/2에서는 이런 간단한 메시지가 프레임 속으로 캡슐화되어, 직접 읽는게 불가능하지만 원칙은 동일합니다.</p>
<div class="highlight"><pre><code class="language-" data-lang="">  GET / HTTP/1.1
  Host: developer.mozilla.org
  Accept-Language: fr
</code></pre></div>
<ol>
<li>서버에 의해 전송된 응답을 읽어들입니다:</li>
</ol>
<div class="highlight"><pre><code class="language-" data-lang="">  HTTP/1.1 200 OK
  Date: Sat, 09 Oct 2010 14:28:02 GMT
  Server: Apache
  Last-Modified: Tue, 01 Dec 2009 20:18:22 GMT
  ETag: "51142bc1-7449-479b075b2891b"
  Accept-Ranges: bytes
  Content-Length: 29769
  Content-Type: text/html

  &lt;!DOCTYPE html... (here comes the 29769 bytes of the requested web page)
</code></pre></div>
<ol>
<li>커넥션을 닫거나 다른 요청들을 위해 재사용합니다.</li>
</ol>

<p>HTTP 파이프라이닝이 활성화되면, 첫번째 응답을 완전히 수신할 때까지 기다리지 않고 여러 요청을 보낼 수 있습니다.</p>

<p>HTTP 파이프라이닝은 오래된 소프트웨어와 현재 버전이 공존하고 있는, 기존의 네트워크 상에서 구현하기 어렵다는게 입증되었으며, HTTP/2의 프레임 속 다중 요청의 좀 더 견고한 메커니즘으로 교체되고 있습니다.</p>

<hr>

<h2 id="http">HTTP 메시지</h2>

<p>HTTP/1.1와 초기 HTTP 메시지는 사람이 읽을 수 있습니다.</p>

<p>HTTP/2에서, 이 메시지들은 새로운 이진 구조인 프레임 안으로 임베드되어, 헤더의 압축과 다중화와 같은 최적화를 가능케 합니다.</p>

<p>본래의 HTTP 메시지의 일부분만이 HTTP의 이 버전 내에서 전송된다고 할지라도, 각 메시지의 시맨틱들은 변화하지 않으며 클라이언트는 본래의 HTTP/1.1 요청을 (가상으로) 재구성합니다; 그러므로 HTTP/1.1 포맷 내에서 HTTP/2를 이해하는 것은 여전히 유용합니다.</p>

<p>HTTP 메시지의 두 가지 타입인 request와 response은 각자의 특성있는 형식을 가지고 있습니다.</p>

<h3 id="request">Request</h3>

<p>HTTP Request의 예제:</p>

<p><img src="./img/HTTP_Request.png" alt="HTTP_Request"></p>

<p>request는 다음의 요소들로 구성됩니다:</p>

<ul>
<li><p>보통 <code>GET</code>, <code>POST</code> 같은 동사 혹은 <code>OPTIONS</code>나 <code>HEAD</code>와 같은 명사의 HTTP 메서드는 클라이언트가 실행하고자 하는 동작을 정의합니다.
일반적으로, 클라이언트는 리소스를 가져오거나(<code>GET</code>을 사용하여) HTML 폼의 데이터를 전송(<code>POST</code>를 사용하여)하려고 하지만, 다른 경우에는 다른 동작이 요구될 수도 있습니다.</p></li>
<li><p>가져오려는 리소스의 경로로, protocol (http://), domain (여기서는 developer.mozilla.org), 또는 TCP port (여기서는 80)인 요소들을 제거한 리소스의 URL입니다.</p></li>
<li><p>HTTP 프로토콜의 버전.</p></li>
<li><p>서버에 대한 추가 정보를 전달하는 선택적 헤더들.</p></li>
<li><p>POST와 같은 몇 가지 메서드를 위한, 전송된 리소스를 포함하는 response의 본문과 유사한 본문.</p></li>
</ul>

<h3 id="response">Response</h3>

<p>응답의 예시:</p>

<p><img src="./img/HTTP_Response.png" alt="HTTP_Response"></p>

<p>Response은 다음의 요소들로 구성됩니다:</p>

<ul>
<li>HTTP 프로토콜의 버전.</li>
<li>요청의 성공 여부와, 그 이유를 나타내는 상태 코드.</li>
<li>아무런 영향력이 없는, 상태 코드의 짧은 설명을 나타내는 상태 메시지.</li>
<li>요청과 비슷한, HTTP 헤더들.</li>
<li>선택 사항으로, 요청의 경우보다는 좀 더 일반이며 가져온 리소스가 포함되는 본문.</li>
</ul>

<hr>

<h2 id="part-65436afb15d">결론</h2>

<p>HTTP는 사용이 쉬운 확장 가능한 프로토콜입니다.</p>

<p>헤더를 쉽게 추가하는 능력을 지닌 클라이언트-서버 구조는 HTTP가 웹의 확장된 수용력과 함께 발전할 수 있게 합니다.</p>

<p>HTTP/2가 성능 향상을 위해 HTTP 메시지를 프레임 내로 임베드하여 약간의 복잡함을 더했을지라도, 애플리케이션의 관점에서 볼 때, 메시지의 기본적인 구조는 HTTP/1.0이 릴리즈된 이후와 동일합니다. 세션의 흐름은 여전히 단순하여, 간단한 HTTP 메시지 모니터를 이용한 조사와 디버그를 가능하게 해줍니다.</p>

<hr>

<h2 id="references">References</h2>

<p><a href="https://developer.mozilla.org/ko/docs/Web/HTTP/Overview" rel="nofollow" target="_blank">https://developer.mozilla.org/ko/docs/Web/HTTP/Overview</a></p>

</div>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/blog/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">Portal2312&#39;s blog</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">Portal2312&#39;s blog</li><li><a class="u-email" href="mailto:portal2312@gmail.com">portal2312@gmail.com</a></li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/portal2312"><svg class="svg-icon"><use xlink:href="/blog/assets/minima-social-icons.svg#github"></use></svg> <span class="username">portal2312</span></a></li><li><a href="https://www.twitter.com/portal2312"><svg class="svg-icon"><use xlink:href="/blog/assets/minima-social-icons.svg#twitter"></use></svg> <span class="username">portal2312</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>Welcome to my blog.</p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
